# Counting and Reasoning with Plans

David Speck1, Markus Hecher2,3, Daniel Gnad4, Johannes K. Fichte4, Augusto B. Correˆa1,

1University of Basel, Switzerland 2Univ. Artois, CNRS, UMR 8188, Centre de Recherche en Informatique de Lens (CRIL), F-62300 Lens, France 3CSAIL, Massachusetts Institute of Technology, United States 4Linko¨ping University, Sweden 5University of Oxford, United Kingdom davidjakob.speck $@$ unibas.ch, hecher $@$ mit.edu, {daniel.gnad,johannes.fichte}@liu.se, augusto.blaascorrea@chch.ox.ac.u

# Abstract

Classical planning asks for a sequence of operators reaching a given goal. While the most common case is to compute a plan, many scenarios require more than that. However, quantitative reasoning on the plan space remains mostly unexplored. A fundamental problem is to count plans, which relates to the conditional probability on the plan space. Indeed, qualitative and quantitative approaches are well-established in various other areas of automated reasoning.

We present the first study to quantitative and qualitative reasoning on the plan space. In particular, we focus on polynomially bounded plans. On the theoretical side, we study its complexity, which gives rise to rich reasoning modes. Since counting is hard in general, we introduce the easier notion of facets, which enables understanding the significance of operators. On the practical side, we implement quantitative reasoning for planning. Thereby, we transform a planning task into a propositional formula and use knowledge compilation to count different plans. This framework scales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning functions and explainable planning.

# Introduction

The overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that transforms the current state into a goal state. While in some scenarios a single plan is sufficient, in others, it may not be clear which plan is preferable based on the description of the planning task. To address this, solvers like top- $\mathbf { \nabla } \cdot \mathbf { k }$ or top-quality planners have been developed to enumerate the $k$ shortest plans or all plans up to a certain length bound allowing for post hoc consideration of the plan space and selection (Katz et al. 2018; Katz and Sohrabi 2020; Speck, Mattmu¨ller, and Nebel 2020; von Tschammer, Mattmu¨ller, and Speck 2022; Chakraborti et al. 2024). Although this paradigm has been successfully applied in practical areas such as malware detection (Boddy et al. 2005) and scenario planning for risk management (Sohrabi et al. 2018), it remains an indirect method for reasoning about the plan space of a planning task.

Considering fundamental problems in computer science, such as the propositional satisfiability problem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more directed reasoning schemes exist that are anchored around counting. The most prominent and canonical counting problem is #SAT, also called model counting, which asks to compute the number of models of a formula. While #SAT is considered computationally harder than asking whether a single model exists (SAT), it also allows for automated reasoning about the solution space (Darwiche 2001; Darwiche and Marquis 2002). Recent competitions illustrate that, despite high computational complexity, state-of-the-art solvers are effective in practice (Fichte, Hecher, and Hamiti 2021). Due favorable reasoning power and vast applications, counting techniques have been extended to other fields (Aziz et al. 2015; Fichte et al. 2017; Hahn et al. 2022; Eiter, Hecher, and Kiesel 2024).

In this paper, we bridge the gap between model counting and classical planning by introducing a new framework for reasoning and analyzing plan space. To do so, we consider all plans for a given planning task with polynomially bounded length, consistent with the approach used in topquality planning (Katz and Sohrabi 2020).

Contributions Our main contributions are as follows:

1. We introduce a taxonomy of counting and reasoning problems for classical planning with polynomially bounded plan lengths and establish the computational complexity of these problems.   
2. We identify a class of reasoning problems on the plan space, called facet reasoning, that are as hard as polynomially bounded planning and thus can be solved more efficiently than counting problems.   
3. We present a practical tool, Planalyst, that builds on existing planning and knowledge compilation techniques to answer plan-space reasoning queries and demonstrate its practical feasibility.

In more detail, on the theoretical side, we formally define a taxonomy of counting and reasoning problems for planning and analyze the computational complexity of these problems. Among other results, we show that the problem of probabilistic reasoning about the plan space such as determining how many plans contain a given operator is ${ \bf C } _ { = } ^ { \mathrm { P } }$ - complete, which is considered computationally harder than counting the number of plans, known to be #P-complete (Speck, Mattmu¨ller, and Nebel 2020). We also introduce the notion of facet reasoning in the context of planning, which has origins in computational complexity (Papadimitriou and Yannakakis 1982) and is well studied in ASP (Alrabbaa, Rudolph, and Schweizer 2018; Fichte, Gaggl, and Rusovac 2022). We show that facet reasoning in planning is NPcomplete, and thus probably much simpler than counting the number of plans. This theoretical result is significant because it allows more efficient answers to complex reasoning queries about the plan space, such as identifying which operators can complement a given partial plan and which provide more flexibility for further complementation.

On the practical side, we present a solution to the studied counting and reasoning problems by transforming a planning task into a propositional formula, where satisfying assignments correspond one-to-one to plans, followed by subsequent knowledge compilation into a d-DNNF (Darwiche and Marquis 2002). We implement this as a tool called Planalyst, which builds on existing tools from planning (Rintanen 2014) and knowledge compilation (Lagniez and Marquis 2017; Sundermann et al. 2024) and thus readily allows plan counting and automated reasoning in plan space. Empirically, we compare Planalyst to state-of-the-art topquality planners on the computationally challenging problem of counting plans, and show that our tool performs favorably, especially when the plan space is large and reasoning over trillions of plans is critical. Finally, by constructing a d-DNNF, our approach not only supports plan counting, but can also answer reasoning questions such as conditional probability, faceted reasoning, and unbiased uniform plan sampling, all through efficient d-DNNF queries.

# Related Work

Darwiche and Marquis (2002) detailed the theoretical capabilities and limitations of normal forms in knowledge compilation. Established propositional knowledge compilers are c2d (Darwiche 1999) and d4 (Lagniez and Marquis 2017), new developments are extensions of SharpSAT-TD (Kiesel and Eiter 2023). Incremental and approximate counting has been considered for ASP (Kabir et al. 2022; Fichte et al. 2024). In SAT and ASP, advanced enumeration techniques have also been studied (Masina, Spallitta, and Sebastiani 2023; Spallitta, Sebastiani, and Biere 2024; Gebser, Kaufmann, and Schaub 2009; Alviano et al. 2023), which can be beneficial for counting if the number of solutions is sufficiently low or when (partial) solutions need to be materialized. Exact uniform sampling using knowledge compilation has also been implemented (Lai, Meel, and Yap 2021). Model counting has been applied to probabilistic planning in the past (Domshlak and Hoffmann 2007). In classical planning and grounding, Correˆa et al. (2023) argued that grounding is infeasible for some domains if the number of operators in a planning task is too high. Therefore, they manually employed model counting, but did not develop extended reasoning techniques or counting tools for planning. Fine-grained reasoning modes and facets have been studied for ASP (Alrabbaa, Rudolph, and Schweizer 2018; Fichte, Gaggl, and Rusovac 2022; Fichte, Hecher, and Nadeem 2022; Rusovac et al. 2024; Eiter et al. 2024) and significance notions based on facets (Bo¨hl, Gaggl, and Rusovac 2023).

# Preliminaries

We assume that the reader is familiar with basics of propositional logic (Kleine Bu¨ning and Lettmann 1999) and computational complexity (Papadimitriou 1994). Below, we follow standard definitions (Bylander 1994; Speck, Mattmu¨ller, and Nebel 2020) to summarize basic notations for planning.

Basics For an integer $i$ , we define $[ i ] : = \{ 0 , 1 , \ldots , i \}$ . We abbreviate the domain of a function $f : \mathcal { D } \ \to \ \mathcal { R }$ by $\operatorname { d o m } ( f )$ . By $f ^ { - 1 } : \mathcal { R } \to \mathcal { D }$ we denote the inverse function $f ^ { - 1 } : = \{ f ( d ) \to d \mid d \in \operatorname { d o m } ( f ) \}$ of function $f$ , if it exists. Let $\sigma = \langle s _ { 1 } , s _ { 2 } , . . . , s _ { \ell } \rangle$ be a sequence, then we write $s \in \sigma$ if $s = s _ { i }$ for some $ 1 \leq i \leq \ell$ and $\nabla ( \sigma )$ the set of elements that occur in $\sigma$ , i.e., $\nabla ( \sigma ) : = \{ s \ | \ \dot { s } \in \sigma \}$ . For a propositional formula $F$ , we abbreviate by $\operatorname { v a r s } ( F )$ the variables that occur in $F$ and by $\operatorname { M o d } ( F )$ the set of all models of $F$ and the number of models by $\Dot { \# } ( F ) : = | \operatorname { M o d } ( F ) |$ .

Computational Complexity We follow standard terminology in computational complexity (Papadimitriou 1994) and the Polynomial Hierarchy (PH) (Stockmeyer and Meyer 1973; Stockmeyer 1976; Wrathall 1976). The complexity class $\boldsymbol { \mathrm { D } } ^ { \mathsf { P } }$ captures the (independent) combination of an NP and a coNP problem, i.e., ${ \bf D } ^ { \mathsf { P } } \ : = \ \{ L _ { 1 } \cap L _ { 2 } \ | L _ { 1 } \ \in$ NP, $, L _ { 2 } ~ \in ~ \mathsf { c o N P } \}$ (Papadimitriou and Yannakakis 1982). Class PP (Gill 1977) refers to those decision problems that can be characterized by a nondeterministic Turing machine, such that the positive instances are those where at least $1 / 2$ of the machine’s paths are accepting. Counting class $\# \mathsf { P }$ captures counting problems that can be solved by counting the number of accepting paths of a nondeterministic Turing machine (Valiant 1979). Class ${ \bf C } _ { = } ^ { \mathrm { P } }$ (Fenner et al. 1999) refers to decision problems that can be characterized via nondeterministic Turing machines where positive instances are those with the same number of accepting and rejecting paths.

Classical Planning A planning task is a tuple $\boldsymbol { \Pi } \ =$ $\langle \mathcal { A } , \mathcal { O } , \mathcal { Z } , \mathcal { G } \rangle$ , where $\mathcal { A }$ is a finite set of propositional state variables. A (partial) state $s$ is a total (partial) mapping $s :$ $\mathcal { A }  \{ 0 , 1 \}$ . For a state $s$ and a partial state $p$ , we write $s \ \models \ p$ if $s$ satisfies $p$ , more formally, $p ^ { - 1 } ( 0 ) \subseteq s ^ { - 1 } ( 0 )$ and $p ^ { - 1 } ( 1 ) \subseteq s ^ { - 1 } ( 1 )$ . $\mathcal { O }$ is a finite set of operators, where each operator is a tuple $o = \langle \mathrm { p r e } _ { o } , \mathrm { e f f } _ { o } \rangle$ of partial states, called preconditions and effects. An operator $o \in { \mathcal { O } }$ is $a p$ - plicable in a state $s$ if $s \ \models \ p \ v { r } \mathrm { e } _ { o }$ . Applying operator $o$ to state $s , s [ [ o ] ]$ for short, yields state $s ^ { \prime }$ , where $s ^ { \prime } ( a ) : = \mathrm { e f f } _ { o } ( a )$ , if $a \in \mathrm { d o m } ( \mathrm { e f f } _ { o } )$ and $\dot { s } ^ { \prime } ( a ) : = s ( a )$ , otherwise. Finally, $\mathcal { T }$ is the initial state of $\Pi$ and $\mathcal { G }$ a partial state called goal condition. A state $^ { s _ { * } }$ is a goal state if $s _ { * } \mapsto \mathcal { G }$ . Let $\Pi$ be a planning task. A plan $\pi = \langle o _ { 0 } , \ldots , o _ { n - 1 } \rangle$ is a sequence of applicable operators that generates a sequence of states $s _ { 0 } , \ldots , s _ { n }$ , where $s _ { 0 } = \mathcal { I }$ , $s _ { n }$ is a goal state, and $s _ { i + 1 } ~ = ~ s _ { i } [ [ o _ { i } ] ]$ for every $i \in [ n - 1 ]$ . Furthermore, we let $\pi ( i ) : = o _ { i }$ JandK denote by $| \pi |$ the length of a plan $\pi$ . We denote the set of all plans by Plans $( \Pi )$ and the set of all plans of length at most $\ell$ by ${ \mathrm { P l a n s } } _ { \ell } ( \Pi )$ and call it occasionally plan space as done in the literature (Russell and Norvig 1995).

A plan $\pi$ is optimal if there is no plan $\pi ^ { \prime } \in \mathrm { P l a n s } ( \Pi )$ where $| \pi ^ { \prime } | < | \pi |$ . The notion naturally extends to boundedlength plans. Deciding or counting plans is computationally hard. More precisely, the BOUNDED-PLAN-EXIST problem, which asks to decide whether there exists a plan of length at most $\ell$ , is PSPACE-complete (Bylander 1994). The #BOUNDED-PLAN problem, which asks to output the number of plans of length at most $\ell$ , remains PSPACEcomplete (Speck, Mattmu¨ller, and Nebel 2020). We say that a plan is polynomially bounded if we restrict the length to be polynomial in the instance size, i.e., the length $\ell$ of $\Pi$ is bounded by $\ell \leq \| \Pi \| ^ { c }$ for some constant $c$ , where $\| \Pi \|$ is the encoding size of $\Pi$ . For a planning problem $\mathbb { P }$ with input $\ell$ that bounds the length of a plan, we abbreviate by POLY- $\mathbb { P }$ the problem $\mathbb { P }$ where $\ell$ is polynomially bounded. Then, the complexity drops. POLY-BOUNDED-PLAN-EXIST is NPcomplete (Bylander 1994) and #POLY-BOUNDED-PLAN is #P-complete, and the decision problem POLY-BOUNDEDTOP-K-EXIST is PP-hard, which asks to decide, given in addition an integer $k$ , whether there are at least $k$ different plans of length up to $\ell$ (Speck, Mattmu¨ller, and Nebel 2020).

<html><body><table><tr><td>Name</td><td>Given</td><td>Task</td><td>Compl.</td><td>Ref.</td></tr><tr><td>POLY-BOUNDED-PLAN-EXIST</td><td>II,e</td><td>π ∈Planse(II)</td><td>NP-c</td><td>[1]</td></tr><tr><td>POLY-BRAVE-PLAN-EXIST</td><td>II,l,o</td><td>π∈Planse(II) :o∈π</td><td>NP-c</td><td>Lem. 6</td></tr><tr><td>POLY-CAUTIOUS-PLAN-EXIST</td><td>II,l,o</td><td>∀π ∈ Planse(II) : o∈ π</td><td>coNP-c</td><td>Lem. 6</td></tr><tr><td>POLY-BOUNDED-TOP-K-EXIST</td><td>II,l</td><td>Planse|≥k</td><td>PP-h</td><td>[2]</td></tr><tr><td>#POLY-BOUNDED-PLAN</td><td>II,e</td><td>Planse</td><td>#P-c</td><td>[2]</td></tr><tr><td>POLY-PROBABILISTIC-REASON</td><td>II,l, Q,p</td><td>Pe[II,Q] = p</td><td>C_-c</td><td>Thm. 9</td></tr><tr><td>FACETREASON</td><td>II,l,o</td><td>0 EFe(II)</td><td>NP-c</td><td>Thm. 10</td></tr><tr><td>ATLEAST-K-FACETS</td><td>II,e,k</td><td>|Fe(II)|≥k</td><td>NP-c</td><td>Lem. 11</td></tr><tr><td>ATMOST-K-FACETS</td><td>II,e,k</td><td>jJFe(II)|≤k</td><td>coNP-c</td><td>Cor. 12</td></tr><tr><td>EXACT-K-FACETS</td><td>I,e, k</td><td>|JFe(II)| = k</td><td>DP-c</td><td>Thm. 13</td></tr></table></body></html>

Table 1: Computational Complexity of Qualitative and Quantitative Reasoning Problems. We let Π be a planning task, $\boldsymbol { \ell } \in  { \mathbb { N } } _ { 0 }$ with $\ell \leq p o l y ( \Pi )$ , $o \in { \mathcal { O } }$ , $\boldsymbol { k } \in \mathbb { N } _ { o }$ , $0 \leq p \leq 1$ , and $Q$ a query. [1]: (Bylander 1994), [2]: (Speck, Mattmu¨ller, and Nebel 2020).

![](images/7fecf98c609b5ecad11062c0780a7e5b7139d599351d4285fc0168ab2f5a01ca.jpg)  
Figure 1: State space of our running example task $\Pi _ { 1 }$ . The initial state is denoted by $s _ { 0 }$ ; the goal state is denoted by $s _ { * }$ .

Example 1 (Running Example). Consider a planning task $\Pi _ { 1 }$ consisting of a scenario with a slightly chaotic researcher, who has to wake up and give a talk at AAAI. Depending on how late they are, they can go straight to the talk without any preparation. However, they could also spend time getting ready. Less pleasant to the audience, they could also continue sleeping and not give the talk at all. Figure 1 illustrates the state space. The initial state is $s _ { 0 }$ , and the single goal state is $^ { s _ { * } }$ . The labels in each edge identify the operator being applied. We can easily identify two plans:

$( i )$ wake-up; get-ready; go-to-AAAI; give-talk.   
$( i i )$ wake-up; go-to-AAAI; give-talk.

Plan (i) has length 4, while Plan (ii) has length 3. Observe that action sleep does not appear in any plan.

Landmarks A fact landmark is a state variable that occurs in every plan (Porteous, Sebastia, and Hoffmann 2001). An operator landmark is an operator that occurs in every plan (Richter, Helmert, and Westphal 2008; Karpas and Domshlak 2009). We can extend these notions to bounded landmarks where we assume bounded length $\ell$ .

Example 2. Consider planning task $\Pi _ { 1 }$ from Example 1. We observe that wake-up, go-to-AAAI, and give-talk are operator landmarks.

Planning as Satisfiability (SAT) Let $\Pi = \langle \mathcal { A } , \mathcal { O } , \mathcal { I } , \mathcal { G } \rangle$ be a planning task and $\ell > 0$ an integer to bound the length of a potential plan. We can employ a standard technique to encode finding a plan into a propositional formula and ask for its satisfiability (SAT) (Kautz and Selman 1992; Rintanen 2012). In more detail, we can construct a formula $F _ { \leq \ell } ^ { \mathrm { p l a n } }$ [Π] whose models are in one-to-one correspondence with the $\ell \cdot$ - bounded plans of $\Pi$ . For space reasons, we present only the core idea. The variables are as follows: $\operatorname { v a r s } ( F _ { \leq \ell } ^ { \mathrm { p l a n } } ) = \{ a ^ { i } \mid$ $a \in \mathcal { A } , i \in [ \ell ] \} \cup \{ o ^ { i } \mid o \in \mathcal { O } , i \in [ \ell ] \}$ . Variable $a ^ { i }$ indicates the value of state variable $a$ at the $i$ -th step of the plan. Hence, if $M \in \operatorname { M o d } ( F _ { \leq \ell } ^ { \mathrm { p l a n } } [ \Pi ] )$ and $a ^ { \ell } \in M$ , then state variable $a$ has value 1 after applying operators $o ^ { 0 } , \ldots , o ^ { \ell - 1 }$ to the initial state. We assume sequential encodings, where the following constraints hold.

1. a set of clauses encoding the value of each state variable at the initial state;   
2. a set of clauses encoding the value of each state variable in the goal condition;   
3. a set of clauses guaranteeing that no two operators are chosen at the same step; and   
4. a set of clauses guaranteeing the consistency of state variables after an operator is applied. If $o ^ { i }$ is true and the effect of operator $o$ makes $a$ true, then $a ^ { i + 1 }$ must be true.

Since plans might be shorter than $\ell$ , we move “unused” steps to the end using the formula $\Lambda _ { i \in [ \ell ] } ( \bigwedge _ { o \in { \mathcal { O } } } \neg o ^ { i } \ $ $\textstyle \bigwedge _ { o \in { \mathcal { O } } } \neg o ^ { i + 1 } )$ , which encodes that if no operator was assigned at step $i$ , then no operator can be assigned at step $_ { i + 1 }$ . Thereby, we obtain a one-to-one mapping between models of $F _ { \leq \ell } ^ { \mathrm { p l a n } } [ \mathrm { I I } ]$ and $l$ -bounded plans for the task.

# From Qualitative to Quantitative Reasoning

Classical planning aims at finding one plan or enumerating certain plans. But what if we want plans that contain a certain operator, or to count the number of possible plans given certain assumptions, or if we want to identify the frequency of an operator among all possible plans? Currently, there is no unified reasoning tool to deal with these types of questions. We introduce more detailed qualitative and quantitative reasoning modes for planning and analyze its complexity. We start with two extreme reasoning modes that consider whether an operator is part of some or all plans.

Definition 3. Let $\Pi = \langle { \mathcal { A } } , { \mathcal { O } } , { \mathcal { T } } , { \mathcal { G } } \rangle$ be a planning task, $o \in$ $\mathcal { O }$ an operator, and $\ell$ an integer. We define the

• brave operator by $\begin{array} { r } { B \mathcal { O } _ { \ell } ( \Pi ) : = \bigcup _ { \pi \in \mathrm { P l a n s } _ { \ell } ( \Pi ) } \bigtriangledown \big ( \pi \big ) } \end{array}$ and • cautious operator by $\begin{array} { r } { \mathcal { C O } _ { \ell } ( \Pi ) : = \bigcap _ { \pi \in \mathrm { P l a n s } _ { \ell } ( \Pi ) } \bigtriangledown \big ( \pi \big ) . } \end{array}$ .

The problem POLY-BRAVE-PLAN-EXIST asks to decide whether $o \in \ B \mathcal { O } _ { \ell } ( \Pi )$ . The problem POLY-CAUTIOUSPLAN-EXIST asks to decide whether $o \in \mathcal { C } \mathcal { O } _ { \ell } ( \Pi )$ .

Note that we use $\nabla ( \cdot )$ to convert sequences into sets, as we aim only for an operator occurring at any time-point.

Remark 4. Our definition of cautious operators is similar to operator landmarks (Zhu and Givan 2003), but for plans with up to a given bounded length.

Example 5. Consider task $\Pi _ { 1 }$ from Example 1 and Plans (i) and (ii). Furthermore, let $\ell = 4$ . Then, the brave and cautious operators of our task are the following:

$$
\begin{array} { r l } & { \mathcal { B } \mathcal { O } _ { \ell } ( \Pi _ { 1 } ) = \{ \mathrm { w a k e - u p , g e t - r e a d y , g o - t o - A A A I , g i v e - t a l k } \} , } \\ & { \mathcal { C } \mathcal { O } _ { \ell } ( \Pi _ { 1 } ) = \{ \mathrm { w a k e - u p , g o - t o - A A A I , g i v e - t a l k } \} . } \end{array}
$$

Operator get-ready is brave but not cautious, as it appears in Plan (i) but not in Plan (ii). Operator sleep is neither brave nor cautious, as it does not appear in any plan.

Lemma 6 $( \star ^ { 1 } )$ . The problem POLY-BRAVE-PLAN-EXIST is NP-complete and the problem POLY-CAUTIOUS-PLANEXIST is coNP-complete.

To find brave operators in practice, we can employ a standard SAT (Audemard and Simon 2018) or ASP solver (Gebser et al. 2011, 2014; Alviano et al. 2015). For cautious operators, we can employ a dedicated backbone solver (Biere, Froleyks, and Wang 2023) or again ASP solvers.

# Probability Reasoning

Both problems POLY-BRAVE-PLAN-EXIST and POLYCAUTIOUS-PLAN-EXIST give rise to extreme reasoning modes on plans. Cautious reasoning is quite strict and so unlikely to hold in general. Brave reasoning is too general and permissive, and thus quite weak in practice. Figure 2 illustrates the two reasoning modes and a more fine-grained mode, which we introduce below. This new mode asks whether the conditional probability of an operator is above a given threshold. It generalizes the known POLY-BOUNDEDTOP-K-EXIST planning problem, which only asks whether at least $k$ plans exists. The crucial ingredient is counting the number of possible plans and relating them to the number of possible plans which contain a given operator. More formally: Let $\bar { \Pi } = \langle \mathcal { A } , \mathcal { O } , \mathcal { Z } , \mathcal { G } \rangle$ be a planning task, $o$ be an operator. We abbreviate the set of all plans of $\Pi$ containing $o$ by ${ \mathrm { P l a n s } } _ { \ell } ( \Pi , o ) : = \{ \pi ~ | ~ \pi ~ \in { \mathrm { ~ P l a n s } } _ { \ell } ( \Pi ) , o ~ \in ~ \pi \}$ . Then, we define the conditional probability of $o$ in plans of $\pi$ by $\begin{array} { r } { \mathbb { P } _ { \ell } [ \Pi , o ] : = \frac { | \operatorname { P l a n s } _ { \ell } ( \Pi , o ) | } { \operatorname* { m a x } ( 1 , | \operatorname { P l a n s } _ { \ell } ( \Pi ) | ) } } \end{array}$ ma|x(P1l,a|nPslℓa(nΠs,ℓo()|Π)|) . Note that the usage of max prevents division by zero in case of no possible plan. Analogously, we can talk about operator $o$ in position $i$ by replacing $o \in \pi$ with $o = \pi ( i )$ . With the help of conditional probability, we can define a fine-grained reasoning mode.

![](images/e2ecaa43f415f2080f5a19d5e5f94a0fd335d617210776ee03fca36da0e61238.jpg)  
Figure 2: Quantitative reasoning is a fine-grained reasoning mode between brave and cautious reasoning. It asks whether a literal matches $\geq p \cdot 1 0 0 \%$ of the plans for planning task $\Pi$ .

To be more flexible, we define $a$ query $Q$ as a propositional formula in conjunctive normal form (CNF) and assume its meaning as expected. We let $Q$ contain variables corresponding to the set $\mathcal { A }$ of state variables, the set $\mathcal { O }$ of operators, as well as of states and operators in position $i$ (similar to $F _ { \leq \ell } ^ { \mathrm { p l a n } } )$ . Let $\pi \in \mathrm { P l a n s } _ { \ell } ( \bar { \Pi } )$ be a plan with $\pi = \langle o _ { 0 } , \ldots , o _ { n - 1 } \bar { \rangle }$ that generates sequence $s _ { 0 } , \ldots , s _ { n } .$ . $\pi$ satisfies a variable $v \in { \mathcal { A } }$ if there is some $i \in [ \ell ]$ such that $s _ { i } ( v ) = 1$ ; satisfies an operator $o \in \mathcal { O }$ if there is some $i \in [ \ell ]$ such that $\pi ( i ) ~ = ~ o$ , analogously for fixed time-points $i$ . Then, $\pi$ satisfies $\neg v$ if $\pi$ does not satisfy $v$ . A plan $\pi$ satisfies a clause $C$ in $Q$ , if $\pi$ satisfies one of its literals; $\pi$ satisfies $Q$ , denoted $\pi \models Q$ , if it satisfies every clause in $Q$ . We define $\operatorname { P l a n s } _ { \ell } ( \Pi , Q ) : = \{ \pi \mid \pi \in \operatorname { P l a n s } _ { \ell } ( \Pi ) , \pi \mid = Q \}$ .

Definition 7 (Probability Reasoning). Let $\Pi = \langle \mathcal { A } , \mathcal { O } , \mathcal { Z } , \mathcal { G } \rangle$ be a planning task, $\ell > 0$ be an integer, $Q$ be a query, and $0 { \le } p { \le } 1$ with $p \in \mathbb { Q }$ . Then, probability reasoning on $Q$ asks if Pℓ[Π, Q] = p, where Pℓ[Π, Q] := ma|xP(l1a,|nPsℓl(anΠs,ℓQ()Π|)|) .

Example 8 (Probability Reasoning). Again, consider planning task $\Pi _ { 1 }$ from Example 1 and let $\ell = 4 .$ . Take the following probability reasoning queries: (i) $\mathbb { P } _ { \ell } [ \Pi _ { 1 }$ , wake-up] $= 1$ , (ii) $\mathbb { P } _ { \ell } [ \Pi _ { 1 }$ , get-ready] $= 0 . 5$ , and (iii) $\mathbb { P } _ { \ell } [ \Pi _ { 1 } , \mathrm { s l e e p } ] \ = \ 0$ . Reasoning (i) illustrates that the researcher must always use operator wake-up to reach a goal; (ii) indicates that getready occurs in half of the plans; (iii) allows us to conclude that no plan uses operator sleep. More complex queries might ask for the probability of a plan containing both wakeup and sleep, or at least one of them:

$$
\begin{array} { r l } & { \mathbb { P } _ { \ell } [ \Pi _ { 1 } , \mathrm { w a k e - u p } \land \mathrm { s l e e p } ] = 0 , } \\ & { \mathbb { P } _ { \ell } [ \Pi _ { 1 } , \mathrm { w a k e - u p } \lor \mathrm { s l e e p } ] = 1 . } \end{array}
$$

Probability reasoning can be achieved by counting twice, which is computationally hard. In more detail, we obtain:

Theorem $\textbf { 9 } \left( \star \right)$ . The problem POLY-PROBABILISTICREASON is ${ \bf C } _ { = } ^ { \mathrm { P } }$ -complete.

# Faceted Reasoning

Above, we introduced three different reasoning modes, namely brave, probability, cautious reasoning. Unfortunately the most precise reasoning mode —the probability mode— is the computational most expensive one and requires to count plans. Therefore, we turn our attention to reasoning that is less hard than probabilistic reasoning and allows us still to filter plans and quantify uncertainty among plans. We call this reasoning faceted reasoning following terminology from combinatorics (Papadimitriou and Yannakakis 1982) and ASP (Alrabbaa, Rudolph, and Schweizer 2018). At the heart of these tasks is a combination of brave and cautious reasoning. These are particularly useful if we want to develop plans gradually/incrementally to see at a given time point, which operators are still possible or have the biggest effect. We focus on operators that belong to some (brave) but not to all plans (cautious).

More formally, for a planning task $\Pi$ and an integer $\ell$ , we let $\mathcal { F } _ { \ell } ^ { + } ( \Pi ) : = B \mathcal { O } _ { \ell } ( \dot { \Pi } ) \setminus \mathcal { C } \bar { \mathcal { O } } _ { \ell } ( \Pi )$ and call the elements of $\mathcal { F } _ { \ell } ^ { + } ( \Pi )$ inclusive facets. In addition, we distinguish excluding facets $\mathcal { F } _ { \ell } ^ { - } ( \Pi )$ , which indicate that operators are not part of a plan. More formally, we let $\mathcal { F } _ { \ell } ^ { - } : = \{ \neg o ~ | ~ o ~ \in$ ${ \mathcal { F } } ^ { + } ( \Pi ) \}$ and define the set $\mathcal { F } _ { \ell } ( \Pi )$ of all facets by $\mathcal { F } _ { \ell } ( \Pi ) : =$ $\mathcal { F } _ { \ell } ^ { + } ( \Pi ) \cup \mathcal { F } _ { \ell } ^ { - } ( \Pi )$ . Interestingly, a facet $p \in \{ o , \lnot o \}$ is directly related to uncertainty, since the operator $o$ can either be included in or be excluded from a plan. When we enforce that a facet $p \in \{ o , \neg o \}$ is present in a plan, which we abbreviate by $\Pi [ p ]$ , we immediately reduce uncertainty on operators among the plans. Based on this understanding, we define the notion of significance for a planning task $\Pi = \langle \mathcal { A } , \mathcal { O } , \mathcal { Z } , \mathcal { G } \rangle$ and an operator $o \in \mathcal { O }$ :

$$
\mathbb { S } _ { \ell } ( \Pi , o ) : = \frac { | \mathcal { F } _ { \ell } ( \Pi ) | - | \mathcal { F } _ { \ell } ( \Pi [ o ] ) | } { | \mathcal { F } _ { \ell } ( \Pi ) | } .
$$

Note that the notion of significance is particularly interesting when we already have a prefix $\omega _ { k } = \langle o _ { 0 } , \ldots , \ldots , o _ { k } \rangle$ and are interested in plans that complete the prefix. Here, facets can assist in understanding which operator is the most significant for the next step or some step in the future. Furthermore, we can include state variables into significance notations without effect on the complexity. We omit these cases from the presentation due to space constraints and readability of our introduced notion.

# Computational Aspects of Facets

Next, we study the computational complexity for problems related to facets. We limit ourselves to including facets, assume the case where an operator occurs in some step, and we omit prefixes in the following. These restrictions have only a negligible effect on the complexity. We start with a natural reasoning problem: The FACETREASON problem asks, given a planning task $\Pi$ and an operator $o \in { \mathcal { O } }$ , to decide whether $o \in \mathcal { F } ( \Pi )$ . We start with a lower and upper bound on the FACETREASON problem.

Theorem 10 $( { \star } )$ . Let Π be a planning task and $o \in { \mathcal { O } }$ . The problem FACETREASON is NP-complete.

Next, we look into counting facets and first observe that the number of facets is bound by $0 \le | \mathcal { F } ( \Pi ) | \le | \mathcal { O } |$ for a planning task $\Pi$ . Therefore, we consider a parameterized version by taking a bound $k$ on the number of facets as input. Then, the problem EXACT-K-FACETS asks, given a planning task $\Pi$ and an integer $k$ , to decide whether $| \mathcal { F } ( \bar { \Pi } ) | = k \bar { \ }$ . Before, we look into upper and lower bounds by the problems ATLEAST-K-FACETS and ATMOST-K-FACETS, which ask whether $| { \mathcal { F } } ( \Pi ) | \geq k$ and $| { \mathcal { F } } ( \Pi ) | \leq k$ , respectively.

Lemma 11 $( \star )$ . Let Π be a planning task, and $\boldsymbol { \ell } \in \mathbb { N } , \boldsymbol { k } \in \mathbb { N } _ { 0 }$ be integers. ATLEAST-K-FACETS is NP-complete.

Corollary 12 $( { \star } )$ . Let Π be a planning task, $\ell \in \mathbb { N }$ , $\boldsymbol { k } \in \mathbb { N } _ { 0 }$ .   
Then, the problem ATMOST-K-FACETS is coNP-complete.

Both results together yield $\boldsymbol { \mathrm { D } } ^ { \mathsf { P } }$ -completeness.

Theorem ${ \bf 1 3 } \left( \star \right)$ . Let Π be a program, and $\ell \in \mathbb { N }$ , $k \in \mathbb { N } _ { 0 } b e$ integers. The problem EXACT-K-FACETS is $\boldsymbol { \mathrm { D } } ^ { \mathsf { P } }$ -complete.

# Discussion: Applications of Plan Reasoning

Our new reasoning modes offer a rich framework to query the solution space of planning tasks. In Remark 4, we discussed the connection between landmarks and cautious reasoning. Similarly, with brave and cautious reasoning it is easy to answer questions such as “does operator $o$ appear on any plan?”, or “does partial state $p$ occur on any trajectory?”

The expressiveness of the queries goes way beyond and can be leveraged in many existing planning techniques. For example, determining the set of operators that are always or never part of a plan is important for learning pruning functions (Gnad et al. 2019). We can generalize these more global queries to reason about operators being only (never) applied in states that satisfy certain conditions, which is essential for learning policies (Krajnansky´ et al. 2014; Bonet and Geffner 2015). Furthermore, brave and cautious reasoning can be helpful for model debugging, offering a convenient tool to find out if an operator expected to occur in a plan does in fact never appear (Lin, Grastien, and Bercher 2023; Gragera et al. 2023). In over-subscription planning (Smith 2004), we can determine the achievability of soft goals or compute the achievable maximum set of soft goals by answering multiple queries. This can be utilized in explainable planning, providing reasons for the absence of solutions that achieve the desired set of soft goals (Eifler et al. 2020; Krarup et al. 2021). We can even generalize the notion of soft goals to desired state atoms that are achieved along a plan, but which might no longer hold in the goal.

With faceted reasoning, we are able to answer plan-space queries without actually counting the number of solutions. This reduces the complexity of answering queries to NPcompleteness, making reasoning much more practically usable. What makes facet reasoning particularly interesting is that it allows to efficiently answer conditional queries, such as “if I want operator $o$ to occur at step $k$ , how much choice is left for the remaining operators?”. Similar to previous work in ASP, facet reasoning allows for an interactive querying mode in which users can gain insights about the particular solution space of a planning task (Fichte, Gaggl, and Rusovac 2022). For tasks with a large set of plans that cannot possibly be navigated manually, facets offer the possibility to systematically navigate the solution space, narrowing down the set of plans by committing to desired operators. The Planalyst tool, which we describe in more detail in the next section, enables this form of interactive exploration in the context of classical planning.

# Empirical Evaluation

We implemented our reasoning framework for classical planning as a tool called Planalyst. Therefore, we transform planning tasks into SAT formulas based on the Madagascar planner (Rintanen 2011, 2014). To efficiently carry out counting, we use d4 (Lagniez and Marquis 2017; Audemard, Lagniez, and Miceli 2022), which compiles (potentially large) formulas into a specialized normal form called d-DNNF (Darwiche and Marquis 2002), enabling fast reasoning. Finally, we reason over the plan space via counting queries using the ddnnife reasoner (Sundermann et al. 2024), which works in poly-time on d-DNNFs.

# Experimental Setup

We focus on solving #BOUNDED-PLAN, i.e., counting the number of plans, which is the computationally hardest problem studied above. This allows us to address all reasoning questions discussed, including computing conditional probabilities. For each task of the benchmark set, we defined an upper bound by collecting known bounds from planning.domains (Muise 2016) and running winning planners from the most recent International Planning Competitions (IPC) (Taitler et al. 2024). In the experiments, we count plans of length up to a multiplicative factor $c \in$ $\{ 1 . 0 , 1 . 1 , \bar { 1 } . 2 , 1 . 3 , 1 . 4 , \bar { 1 } . 5 \}$ of the collected upper bounds. We consider two different configurations for our approach: Count, which only counts the number of plans, and Enum, which additionally enumerates all plans, resulting in a novel top-quality planner for classical planning with unit operator costs. For comparison, we have chosen two top-quality planners, ${ \tt K } ^ { * }$ (Katz et al. 2018) and SymK (Speck, Mattmu¨ller, and Nebel 2020), both of which can be readily used to count the number of plans as they enumerate them, and both of which are considered to scale well to large numbers of plans. We ran both baseline planners in their recommended configurations2: $\mathtt { K } ^ { * }$ , which implements orbit-space search (Katz and Lee 2023) with the landmark-cut heuristic (Helmert and Domshlak 2009), and SymK, which implements a variant of bidirectional symbolic search (Torralba et al. 2017). For enumeration approaches $\mathrm { \nabla { K ^ { * } } }$ , SymK, Enum), we let these solvers enumerate the plans only internally to avoid writing billions (or more) of plans to the disk. All experiments ran on Intel Xeon Silver 4114 processors running at $2 . 2 \ : \mathrm { G H z }$ . We used a time limit of 30 minutes and a memory limit of 6 GiB per task. Our benchmarks include all optimal planning domains from IPCs 1998-2023 with unit operator costs and without conditional effects or axioms. Source code, benchmarks, and data are available online (Speck et al. 2024).

Coverage   
#Plans   
Table 2: (Left): Coverage, i.e., the number of tasks where the number of plans within a multiplicative factor of a length bound was found by ${ \tt K } ^ { * }$ , SymK, and our SAT-based approaches, Count and Enum. Count only counts plans, while Enum additionally enumerates them. (Right): Statistics on the number of plans in the benchmark set, considering the length bound determined by the four solvers.   

<html><body><table><tr><td>Lound</td><td></td><td>xuks</td><td>umu</td><td>tunoo</td><td></td><td></td><td></td></tr><tr><td>×1.0</td><td>351</td><td>309</td><td>253</td><td>335</td><td>>1015</td><td>>1013</td><td>>10²</td></tr><tr><td>×1.1</td><td>289</td><td>231</td><td>182</td><td>300</td><td>>1015</td><td>>1013</td><td>>104</td></tr><tr><td>×1.2</td><td>212</td><td>173</td><td>130</td><td>251</td><td>>1015</td><td>>1013</td><td>>105</td></tr><tr><td>×1.3</td><td>177</td><td>135</td><td>101</td><td>210</td><td>>1018</td><td>>1015</td><td>>105</td></tr><tr><td>×1.4</td><td>142</td><td>112</td><td>77</td><td>189</td><td>>1021</td><td>>1018</td><td>>106</td></tr><tr><td>×1.5</td><td>112</td><td>91</td><td>61</td><td>170</td><td>>1021</td><td>>1018</td><td>>106</td></tr></table></body></html>

# Overall Performance

Table 2 (left) compares the coverage, i.e., the number of tasks for which different approaches can determine the number of plans, for different multiplicative length bounds. $\mathtt { K } ^ { * }$ has the best coverage for a length bound of 1.0. Our enumeration approach, Enum, ranks overall last, although being able to solve a notable number of tasks by first creating a dDNNF, followed by a subsequent enumeration query for all models, and finally mapping them to actual plans. For the 1.0 bound, our counting approach Count performs worse than $\mathtt { K } ^ { * }$ , but has better coverage than the SymK planner. When considering higher length bounds, the counting approach, Count, has the highest coverage. The gap between Count and the other approaches gets larger as the length bound increases. This can be explained by the increasing number of plans, see Table 2 (right), where enumeration becomes less feasible due to the large plan space. This highlights the usefulness of our approach for sampling or reasoning in tasks with huge plan spaces. For example, in scenarios where end-users want to understand the plan space, enumerating over a sextillion $( 1 0 ^ { 2 1 } )$ different plans is infeasible, but counting them (and using the related reasoning) is possible. Moreover, a decent performance with larger bounds gives us more flexibility for problems where a good bound is not easily available but an over-approximation is, e.g., using a non-admissible heuristic to come up with a bound.

# Domain-Wise Performance

Table 3 shows a domain-wise comparison of the different approaches for the two extreme bounds in our experiments, 1.0 and 1.5. For both bounds, the performance differs a lot depending on the domain. Our SAT-based approach performs particularly well in the blocksworld and psr-small domains in both cases. In blocksworld, the largest task that we could still solve had $1 . 5 \cdot 1 0 ^ { 9 }$ plans, while in psr-small the largest solved task had $8 . 9 \cdot 1 0 ^ { 1 2 }$ . In contrast, ${ \tt K } ^ { * }$ could only count up to a 10 million plans in these domains.

Bound: $\times 1$ Bound: $\times 1 . 5$   
Table 3: Coverage per domain, i.e., number of tasks per domain where the number of plans within a factor 1.0 or 1.5 of a cost bound was found by ${ \mathrm { K } } ^ { * }$ , SymK, and our SAT-based approaches, Count and Enum. Count only counts plans, while Enum outputs each plan.   

<html><body><table><tr><td>Sum (1094)</td><td>storage ( satelit (36) grid (5) airport (49) (20)</td><td>Domains</td></tr><tr><td>351</td><td>6コｓ叽ｓΠ９ＳνиЗ６ηｓＬコΠＺＺε６ャεＺＳΠν０孔ｓＬ</td><td>K*</td></tr><tr><td>309</td><td>８卯Ｕ９９ＳＳν８わＬⅡＩＬиΠ０Ｚξ９ｃＺＺи８Ｚ０εοＬ</td><td>SymK</td></tr><tr><td>253</td><td>８卯７コＩＳν６めｓ００８ＷＺοεＩ７ＩＳ９７０иοＬ</td><td></td></tr><tr><td></td><td>８иｓＳＺＺＩ９Ｄ６Ｓ８и００８９幻６ａＬｃＩｓ８ｓ０８０ｎ</td><td>Enum</td></tr><tr><td>335|112</td><td></td><td>Count</td></tr><tr><td></td><td>νＳｓＩ０Ｌ７ＩοＺＡＺＺ０ＬＳｎＺοＡＩοＩＩ０ｌο０６０Ｌ ０Ｉ０ＩＷＩＩ０ＬＺ８Ｌ０幻Ｉ０Ｉ０</td><td>K*</td></tr><tr><td>16</td><td>cccI 0 9 0IO 0 80L</td><td>SymK</td></tr><tr><td>1</td><td>乙 9 I ０Ｓ０００Ｉ８ＩＩ００ＩＬＺ００００ 0 0 0I 0 0 L09</td><td>Enum</td></tr><tr><td>170</td><td>$9 →z忆zε v66忆εI- Ｉ０Ｓｏｎ</td><td>Count</td></tr></table></body></html>

The SAT-based approach is less effective in other domains. One reason is that they are less specialized than heuristic and symbolic search approaches to optimal planning. Among other factors, the sequential encoding is not concise enough for some tasks and bounds (e.g., airport), or the grounding algorithm of Madagascar is inferior to those of other planners built on top of the FastDownward grounder (Helmert 2006, 2009), making it impossible to ground certain tasks (e.g., organic-synthesis). It would be interesting to evaluate how other encodings perform (Rintanen 2012), but that brings the additional problem of losing the one-to-one correspondence between plans and SAT models.

For 1.5, counting is more feasible than enumeration in many domains: as the number of plans increases, enumeration becomes less practical. Counting works for many reasoning tasks, e.g., those based on conditional probabilities.

# Beyond Counting

As illustrated above, our Planalyst tool effectively counts plans by compiling into a d-DNNF and performing a counting query. This method can not only answer conditional probability questions, such as the quantity of an operator in plans, but also addresses other reasoning questions more directly and efficiently through d-DNNF queries using ddnnife (Sundermann et al. 2024). Consider reasoning questions about the plan space of a given planning task, while respecting a cost bound. Given the d-DNNF representing the plan space, questions about brave and cautious operators can be answered directly, even without traversing the entire d-DNNF, when the number of plans is known (Sundermann et al. 2024). This can be achieved by traversing the literal nodes of the d-DNNF and collecting the backbone variables, i.e., the variables that are always true (core) or false (dead). In addition, given the d-DNNF, it is possible to uniformly sample plans without enumerating the full set by d-DNNF traversing with ddnnife. This allows to address planning biases when selecting plans (Paredes et al. 2024; Frank et al. 2024) and thus collect unbiased training data for different learning approaches (Shen, Trevizan, and Thie´baux 2020; Areces et al. 2023; Chen, Thie´baux, and Trevizan 2024; Bachor and Behnke 2024). We omit empirical results for these queries, as their overhead is negligible once the d-DNNF is constructed. Our experiments with the Count configuration of Planalyst have shown that this construction is feasible for many planning tasks.

# Conclusion and Future Work

We count plans and reason in the solution space, which is orthogonal to previous works in planning (Katz et al. 2018; Speck, Mattmu¨ller, and Nebel 2020; Katz and Sohrabi 2020). Moreover, we reason about the plan space in the form of queries and introduce faceted reasoning to planning allowing for questions on the significance of operators. Although faceted reasoning is computationally hard (NP-c), it is, under standard theoretical assumptions, significantly more efficient than counting the number of plans (#P-c). Finally, we present our new reasoning tool, Planalyst, which can count the number of plans assuming fixed given length. It also supports different plan space queries. In general, Planalyst is competitive with state-of-the-art top- $\mathbf { \nabla } \cdot \mathbf { k }$ planners and outperforms all other methods when the plan space is too large, i.e., more than 10 million plans.

In the future, we plan to integrate Planalyst into other pipelines, such as goal recognition (Mirsky, Keren, and Geib 2021), grounding via learning (Gnad et al. 2019), and task rewriting (Areces et al. 2014; Elahi and Rintanen 2024), using counting and facet reasoning for guidance. Interesting topics for considerations could be to deal with inconsistencies (Ulbricht 2019) and certifying results (Alviano et al. 2019; Fichte, Hecher, and Roland 2022) as well as explaining reasoning behind decisions (Cabalar, Fandinno, and Mun˜iz 2020). We will study how our framework extends to other encodings, such as parallel operator encodings (Rintanen 2012) or lifted encodings (Ho¨ller and Behnke 2022).