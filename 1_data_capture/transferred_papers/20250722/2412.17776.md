# Efficient Fault-Tolerant Search by Fast Indexing of Subnetworks

Davide Bil\`o1, Keerti Choudhary2, Sarel Cohen3, Tobias Friedrich4, Martin Schirneck5

1Department of Information Engineering, Computer Science and Mathematics, University of L’Aquila, Italy 2Department of Computer Science and Engineering, Indian Institute of Technology Delhi, India 3School of Computer Science, The Academic College of Tel Aviv-Yaffo, Israel 4Hasso Plattner Institute, University of Potsdam, Germany 5Faculty of Computer Science, University of Vienna, Austria davide.bilo $@$ univaq.it, keerti $@$ iitd.ac.in, sarelco $@$ mta.ac.il, tobias.friedrich $@$ hpi.de, martin.schirneck $@$ univie.ac.at

# Abstract

We design sensitivity oracles for error-prone networks. For a network problem $\Pi$ , the data structure preprocesses a network $G = ( V , E )$ and sensitivity parameter $f$ such that, for any set $F \subseteq V \cup E$ of up to $f$ link or node failures, it can report the solution of $\Pi$ in $G \mathrm { - } F$ . We study three network problems $\Pi$ .

• $L$ -HOP SHORTEST PATH: Given $s , t \in V$ , is there a shortest $s$ - $t$ -path in $G \mathrm { - } F$ with at most $L$ links? • $k$ -PATH: Does $G - F$ contain a simple path with $k$ links? • $k$ -CLIQUE: Does $G - F$ contain a clique of $k$ nodes?

Our main technical contribution is a new construction of $( L , f )$ -replacement path coverings $( ( L , f )$ -RPC) in the parameter realm where $f = o ( \log L )$ . An $( L , f )$ -RPC is a family $\mathcal { G }$ of subnetworks of $G$ which, for every $F \subseteq E$ with $| F | \leqslant f$ , has a subfamily $\mathcal G _ { F } \subseteq \mathcal G$ such that (i) no subnetwork in $\mathcal { G } _ { F }$ contains a link of $F$ and (ii) for each $s , t \in V$ , if $G \mathrm { - } F$ contains a shortest $s$ - $t$ -path with at most $L$ links, then some subnetwork in $\mathcal { G } _ { F }$ retains at least one such path. Our $( L , f )$ -RPC has almost the same size as the one by Weimann and Yuster (2013) but it improves the time to query $\mathcal { G } _ { F }$ from $\widetilde { O } ( f ^ { 2 } L ^ { f } )$ to $\widetilde { O } ( f ^ { \frac { 5 } { 2 } } L ^ { o ( 1 ) } )$ . It also improves over the size and qeuery time ofethe $( L , f )$ -RPC by Karthik and Parter (2021) by nearly a factor of $L$ . From this construction, we derive oracles for $L$ -HOP SHORTEST PATH, $k$ -PATH, and $k$ -CLIQUE. Notably, our solution for $k$ -PATH improves the query time of the one by Bil \`o et al. (2022a) for $f = o ( \log k )$ .

# Introduction

Networks are central structures in computer science as they can model different types of relations we encounter in realworld applications. Numerous algorithms and data structures have been developed to solve problems in static networks where nodes and links do not change over time. However, as networks in real life are prone to transient failures, many of these algorithms require recomputations from scratch even when only a few network components are malfunctioning. In many applications one may have an a priori known bound $f$ on the number of simultaneous failures, especially in the context of independent failures where the likelihood of multiple failures decreases exponentially. This is called the fault-tolerant setting or sensitivity analysis and the resulting data structures are called sensitivity oracles. In the past two decades, many sensitivity oracles have been designed for classical network problems, e.g., connectivity (Patrascu and Thorup 2007; Duan and Pettie 2009, 2010, 2017), shortest paths (Cho, Shin, and Oh 2024; Demetrescu et al. 2008; Chechik et al. 2012; Duan and Pettie 2009; Bilo\` et al. 2023; Duan and Ren 2022; Dey and Gupta 2024; Gu and Ren 2021) and routing (Chechik et al. 2012).

We continue this line of work by designing data structures that, given a network problem $\Pi$ , a network $G = ( V , E )$ with $n$ nodes and $m$ links, and a parameter $f$ , preprocesses $G$ into a oracle with sensitivity $f$ that, when queried with a set $F \subseteq V \cup E$ of size $| F | \leqslant f$ , reports a solution for $\Pi$ in $G - F$ . Specifically, we study the following problems $\Pi$ .

• $L$ -HOP SHORTEST PATH: Given two nodes $s , t \in V$ , is there a shortest s-t path in $G \mathrm { - } F$ with at most $L$ links? • $k$ -PATH: Does $G { - } F$ contain a simple path with $k$ links? • $k$ -CLIQUE: Does $G - F$ contain a clique of $k$ nodes?

In fact, we can handle all problems with the property that any certificate solution $S \subseteq G$ for $\Pi$ , like e.g., a $k$ -path, is also a certificate solution of $G ^ { \prime }$ for $\Pi$ , for every $S \subseteq G ^ { \prime } \subseteq G$ . Although we focus on decision problems, our data structures are also capable of reporting a certificate solution.

A naive solution consists in enumerating all possible subnetworks, one for each $F \subseteq V \cup E$ with $| F | \leqslant f$ , and storing a static data structure for each computed subnetwork. This is, however, prohibitively expensive w.r.t. both space and preprocessing time as there are ${ \binom { | V | + | E | } { \leqslant f } } \ = \ \Theta ( n ^ { f } + m ^ { f } )$ subnetworks if node and link failures can occur. We need a more efficient way to construct subnetworks that allow us to make the data structure fault tolerant. Moreover, we also need some compact and time-efficient indexing scheme to quickly access the correct subnetworks upon query.

Our motivation aligns with the work of (Cho, Shin, and Oh 2024), which addresses fault tolerance in dynamic settings such as navigation, logistics, and communication networks, where rapid rerouting is crucial. Similarly, (Blum, Funke, and Storandt 2018) motivates using preprocessing to reduce the search space for path finding. Many real-world networks have a small diameter, and this makes our work relevant as we assume only the existence of all-pairs shortest paths of length bounded by a parameter $L$ . The works by Ouyang, Yuan, Qin, Chang, Zhang, and Lin (2020) and

Table 1: Comparison of $( L , f )$ -replacement path coverings. The sensitivity $f$ and cut-off parameter $L$ satisfy $f = o ( \log L )$ . The number of subnetworks relevant for the failure set $F$ refers to the size $| \mathcal { G } _ { F } |$ , while the query time is the time to compute $\mathcal { G } _ { F }$ .   

<html><body><table><tr><td>O(fLf)</td><td>O（f²Lf）</td><td>O(fLf-IFl)</td><td>randomized</td><td>Weimann and Yuster (2013)</td></tr><tr><td>O(fL)f+1</td><td>O(f²L)</td><td>O(fL)</td><td>deterministic</td><td>Karthik and Parter (2021)</td></tr><tr><td>O(fLf+o(1))</td><td>0（fLo(1))</td><td>O(fLo(1))</td><td>randomized</td><td>Theorem 1</td></tr></table></body></html>

Zhang, Li, and Zhou (2021) align with our aim to enhance robustness in AI systems. We provide combinatorial insights that might be useful to design new time-efficient heuristics.

$( L , f )$ -Replacement Path Coverings. Weimann and Yuster (2013) design the first data structure with sensitivity $f$ for $L$ -HOP SHORTEST PATH. They used it as a building block in a distance sensitivity oracle ( $f$ -DSO), which reports length of general shortest paths in $G \mathrm { - } { \mathcal { F } }$ without the hop-length constraint. Their main tool was an $( L , f )$ - replacement path covering,1 or $( L , f )$ -RPC, a family $\mathcal { G }$ of subnetworks of $G$ which, for every set $F \subseteq E$ with $| F | \leqslant f$ , has a subfamily $\mathcal G _ { F } \subseteq \mathcal G$ such that (i) no subnetwork in $\mathcal { G } _ { F }$ contains an edge in $F$ and (ii) for every pair of nodes $s , t \in V$ , if $G \mathrm { - } F$ contains an $L$ -hop shortest $s$ -t-path, then some subnetwork in $\mathcal { G } _ { F }$ retains such a path. That means, to find the true $^ { \mathbf { \alpha } _ { s - t } }$ -distance in $G - F$ , it is enough to consult the subnetworks in $\mathcal { G } _ { F }$ . Weimann and Yuster (2013) obtained their $( L , f )$ -RPC using $O ( f L ^ { f } \log n )$ copies of $G$ and, in each one, removing any link independently with probability $1 / L$ . Chernoff’s bound shows that w.h.p.2 there are $| \mathcal G _ { F } | = O ( f L ^ { f - | F | } \log n )$ subnetworks that do not contain any link of $F$ and such that, for every $s , t \in V$ , at least one element in $\mathcal { G } _ { F }$ retains an $L$ -hop shortest $^ { s - t }$ path in $G - F$ , if there is any. Unfortunately, due to the randomness, the most efficient way to find $\mathcal { G } _ { F }$ is to go through all subnetworks in $\mathcal { G }$ individually, taking time ${ \cal { O } } ( f ^ { 2 } L ^ { f } \log n )$ .

Karthik and Parter (2021) derandomized this construction via error-correcting codes. For $L \geqslant f$ , their $( L , f )$ -RPC has size $O ( f L \log n ) ^ { \tilde { f } + 1 }$ , which is an $\mathcal { O } ( f ^ { f } L ( \log n ) ^ { f } )$ -factor larger than the solution by Weimann and Yuster. The size of the relevant subfamily $\mathcal { G } _ { F }$ is $\widetilde { O } ( f L )$ ,3 independently of $| F |$ . The huge advantage of the d eterministic construction is the much better query time. They showed how to retrieve $\mathcal { G } _ { F }$ in time $\widetilde O ( f ^ { 2 } L )$ . A side-by-side comparison is given in Table 1.

Wheile the randomized $( L , f )$ -RPC is smaller than the deterministic one, the latter has a much better query time. Thus, a natural question is whether one can design an $\left( L , f \right)$ - RPC whose size is as small as the former and whose query time is at least as efficient as the latter. We answer this question affirmatively. The bottleneck of the construction by Weimann and Yuster (2013) is not randomness, but independence. This is the reason one has to scan all subnetworks in order to find $\mathcal { G }$ . Our construction can be seen as an indexing of the Weimann and Yuster graphs. The crucial difference is that the subnetworks we generate are no longer independent. Instead, the construction process naturally groups them into sampling trees. The query algorithm merely traces a root-toleaf path in the tree by always choosing an arbitrary child node whose subnetwork contains no link of $F$ .

Theorem 1. Let $G$ be a directed/undirected network with n nodes, possibly weighted, and let $f = o ( \log L )$ . We can build a randomized $( L , f )$ -replacement path covering $\mathcal { G }$ of size $\widetilde { O } ( f L ^ { f + o ( 1 ) } )$ such that, given any $F \subseteq V \cup E$ with $| F | \leqslant f$ , computes in time $\widetilde { O } ( f ^ { \frac { 5 } { 2 } } L ^ { o ( 1 ) } )$ a collection $\mathcal G _ { F } \subseteq \mathcal G$ of subnetworks satisfying he following properties w.h.p.:

(i) $| { \mathcal G } _ { F } | = \widetilde O ( f L ^ { o ( 1 ) } ) ,$ ;   
(ii) No subnetwork in $\mathcal { G } _ { F }$ contains an element of $F$ ;   
(iii) For any two nodes $s , t \ \in \ V$ that admits an $L$ -hop shortest s-t path in $G - F$ , there is at least one subnetwork in $\mathcal { G } _ { F }$ that retains one of such paths.

The number of subnetworks in our construction is only an $L ^ { o ( 1 ) }$ -factor away from the one by Weimann and Yuster (2013). The $\widetilde { \cal O } ( f ^ { 5 / 2 } L ^ { o ( 1 ) } )$ -query time is even better then the one by Kaerthik and Parter (2021). The assumption $f =$ $o ( \log L )$ is to ensure that parameters of the $( L , f )$ -RPC scale only logarithmically in the size of the input network $G$ (hidden in the $\widetilde { O }$ -notation). Our construction also works for larger sensiti teies like, e.g., $f = o ( \log ( n ) / \log \log n )$ , a common bound in the literature (Weimann and Yuster 2013), (Chechik, Cohen, Fiat, and Kaplan 2017), (Bilo\`, Chechik, Choudhary, Cohen, Friedrich, and Schirneck 2024), and even up to $f = o ( \log n )$ . However, then the total number of subnetworks, the number of relevant subnetworks $| \mathcal { G } _ { F } |$ , and the query time all increase by an $n ^ { o ( 1 ) }$ -factor.

Next, we apply Theorem 1 to $L$ -HOP SHORTEST PATH.

Theorem 2. Let $G$ be a (directed) network with n nodes and real edge weights that does not contain negative cycles. Let $f = o ( \log L )$ . There exists a randomized $L$ -hop distance oracle with sensitivity $f$ for pairwise $L$ -hop shortest paths that takes space $\widetilde { O } ( f L ^ { f + o ( 1 ) } n ^ { 2 } )$ and has query time $\widetilde { O } ( f ^ { 5 / 2 } L ^ { o ( 1 ) } )$ . The or cele can be preprocessed in time $\widetilde { \cal O } ( f L ^ { f + o ( 1 ) } T _ { A P S P } ) $ , where $T _ { A P S P }$ is the time to compute allpeairs shortest paths in $G$ .

It has often been observed that real-world networks are modeled well by networks with small diameter, see the works of Watts and Strogatz (1998); Albert, Jeong, and Baraba´si (1999); Adamic (1999), the “small-world” networks by Kleinberg (2000), Chung-Lu networks (Chung and Lu 2002), hyperbolic random networks (Friedrich and Krohmer 2018), and the preferential attachment model (Hofstad 2016). Let $D$ be the diameter of an undirected, unweighted network $G$ . By the result of Afek, Bremler-Barr, Kaplan, Cohen, and Merritt (2002) showing that if $G - F$ is still connected, then its diameter is at most $( f { + } 1 ) D$ , Theorem 2 gives a very efficient $f \mathrm { - D S O }$ for general hop-lengths in networks with, say, polylogarithmic diameter.

Table 2: Comparison of fixed-parameter sensitivity oracles for the $k$ -PATH problem. All results are randomized. The last row assumes $f = o ( \log k )$ . The quantity $\omega < 2 . 3 7 1 5 5 2$ is the matrix multiplication exponent.   

<html><body><table><tr><td>（）（）) )'(）fk) (f²）（²）²f.2² poly(n）</td><td>Bilo et al. (2022a)</td></tr><tr><td>f² 2k poly(k) （2k.n²） 2k poly(k) · n~</td><td>Alman and Hirsch (2022)</td></tr><tr><td>O(4f f2-0(1) k0(1)) f+o(1) f+(1) f3/2 . 2𝑘 poly(n) 3/2k</td><td>Theorem 4</td></tr></table></body></html>

Corollary 3. Let $G$ be an undirected, unweighted network with n nodes, m links, and diameter $D = \omega ( 1 )$ . For any constant $f$ , there exists a randomized distance oracle with sensitivity $f$ that takes space ${ \widetilde O } ( D ^ { f + o ( 1 ) } n ^ { 2 } )$ and has query time ${ \widetilde O } ( D ^ { o ( 1 ) } )$ . The oracle cean be preprocessed in time $\widetilde { \cal O } ( D ^ { f + o ( 1 ) } m n )$ or $\widetilde { O } ( D ^ { f + o ( 1 ) } n ^ { \omega } )$ , where $\omega \ : < \ : 2 . 3 7 1 5 5 2$ ise the matrix multip ceation exponent.

On $k$ -PATH and $k$ -CLIQUE. The $k$ -PATH problem is NP-complete when $k$ is given as part of the input. If $k$ is treated as a parameter, however, then the problem turns out to be fixed-parameter tractable (FPT), meaning that it is solvable in time $g ( k ) \cdot \mathsf { p o l y } ( n )$ for some function $g$ . The current-best algorithms are randomized and run in time $1 . 6 6 ^ { k } \cdot \mathsf { p o l y } ( n )$ for undirected networks (Bjo¨rklund, Husfeldt, Kaski, and Koivisto 2017) and $2 ^ { k } { \cdot } { \mathsf { p o l y } } ( n )$ for directed networks (Williams 2009). The best deterministic algorithm runs in time $2 . 5 5 4 ^ { k } \cdot \mathsf { p o l y } ( n )$ (Tsur 2019).

Bilo\`, Casel, Choudhary, Cohen, Friedrich, Lagodzinski, Schirneck, and Wietheger (2022a) introduced fixedparameter sensitivity oracles for FPT-problems. In these oracles the preprocessing time and space requirement must be of the form ${ \dot { \mathbf { \zeta } } } _ { g } ( f , k ) \cdot { \mathsf { \bar { p } } } 0 | \mathbf { \boldsymbol { y } } ( n )$ , and the query time ought to be “significantly faster” than recomputing a solution from scratch. They designed a fixed-parameter oracle with sensitivity $f$ for $k$ -PATH with a query time and space of $\begin{array} { r } { O ( ( \frac { f + k } { f } ) ^ { f } ( \frac { f + k } { k } ) ^ { k } f k \log n ) } \end{array}$ , and a $\textstyle { \big ( } { \frac { { \dot { f } } + k } { f } } { \big ) } ^ { f } { \big ( } { \frac { f + k } { k } } { \big ) } ^ { k } { \dot { f } } 2 ^ { k }$ · $\mathsf { p o l y } ( n )$ preprocessing time. When $f \geqslant k$ , Alman and Hirsch (2022) significantly improved the query time to $f ^ { 2 } 2 ^ { k } \mathsf { p o l y } ( k )$ randomized or $O \bar { ( } f ^ { 2 } 2 ^ { \omega k } )$ deterministic. The space requirement is $O ( 2 ^ { k } ( \log ^ { - } k ) n ^ { 2 } )$ in the randomized case and $O ( 2 ^ { k } k n ^ { 2 } \log n )$ for the deterministic version. The preprocessing time is $2 ^ { k } { \mathsf { p o l y } } ( k ) n ^ { \omega }$ (randomized) or $4 ^ { k } \mathsf { p o l y } ( \bar { k } ) n ^ { \omega }$ (deterministic). See Table 2 for an overview.

We consider the case where $k$ is much larger than $f$ , so our goal is to make the dependence on $k$ as small as possible.

Theorem 4. Let $G$ be a directed, unweighted network with $n$ nodes. Let $f$ and $k$ be two integer parameters with $\begin{array} { r l r } { f } & { { } = } & { o ( \log k ) } \end{array}$ . There exists a randomized fixed-parameter oracle with sensitivity $f$ for $k$ -PATH that takes space $\widetilde { O } \big ( \big ( \frac { k + 4 } { f } \big ) ^ { f + o ( 1 ) } f ^ { 3 / 2 } k \big )$ and has query time $\widetilde { \cal O } ( 4 ^ { f } f ^ { 2 - o ( 1 ) } k ^ { o ( 1 ) } ) ^ { \overline { { { \ } } } } w . h . p$ . The oracle can be preprocessed ien randomized time $( \frac { k + 4 } { f } ) ^ { f + o ( 1 ) } f ^ { 3 / 2 } \ \cdot \ 2 ^ { k } \mathsf { p o l y } ( n )$ . If the network is undirected, the preprocessing time decreases to $( \frac { k + 4 } { f } ) ^ { f + o ( 1 ) } f ^ { 3 / 2 } \cdot 1 . 6 6 ^ { k } \mathsf { p o l y } ( \bar { \boldsymbol { n } } )$ .

During the analysis, it becomes apparent that the path structure is not actually needed, only the fact that the solution has $k$ links. This allows us to extend sensitivity oracles even to networks motifs that are believed not to have an FPT-algorithm, like $k$ -CLIQUE. It is widely believed $k$ - CLIQUE is not solvable in time $g ( k ) \cdot \mathsf { p o l y } ( n )$ as the clique detection problem is $\mathsf { W } [ 1 ]$ -complete. The current best algorithm by Nesˇetˇril and Poljak (1985) computes a clique of $k$ nodes in time $O ( n ^ { \omega k / 2 } )$ . We use it to design the first fixedparameter sensitivity oracle for $k$ -CLIQUE.

Theorem 5. Let $G$ be an undirected, unweighted network with $n$ nodes. Let $f$ and $k$ be two integer parameters with $\begin{array} { r l r } { f } & { { } = } & { o ( \log k ) } \end{array}$ . There exists a randomized oracle with sensitivity $f$ for $k$ -CLIQUE that takes space $\widetilde O ( ( \frac { k ^ { 2 } + 4 } { f } ) ^ { f + o ( 1 ) } f ^ { 3 / 2 } k ^ { 2 } )$ and has query time $\widetilde { \cal O } ( 4 ^ { f } f ^ { 2 - o ( 1 ) } k ^ { o ( 1 ) } )$ w.h.p. The oracle can be preprocessed $\widetilde { O } ( ( \frac { k ^ { 2 } + 4 } { f } ) ^ { f + o ( 1 ) } f ^ { 3 / 2 } \cdot n ^ { \omega k / 2 } )$ .

Outline. We first discuss replacement path coverings in general in the next section, followed by their most common application in $L$ -hop distance sensitivity oracles. Afterwards, we show that similar ideas can also be employed for $k$ -paths, $k$ -cliques, and other graph motifs. We conclude this work by discussing some open questions.

# The Main Tool: Sampling Trees

We turn the idea of removing links to create an $( L , f )$ - replacement path covering upside down. We build a sampling tree having the empty subnetwork as its root and, in each level, any child node takes all the links of its parent and randomly adds new links from $G$ with some probability depending on $f$ and $L$ , and on an additional parameter $h$ that controls the height of the trees. The probability is fine-tuned in such a way that, among the leaves, the likelihood for any link to exist is precisely the same as it was in the construction of Weimann and Yuster (2013). This brings the number of subnetworks back down to $O ( f L ^ { f + o ( 1 ) } \log { n } )$ .

The crucial difference is that the stored subnetworks are no longer independent. Two nodes of the same tree always share at least all links that are stored in their lowest common ancestor. This arrangement of the subnetworks allows for a very efficient query algorithm even though the construction is randomized. Given a query $F \subseteq E$ with $| F | \leqslant f$ , we navigate the sampling tree starting from the root and, in each level, we move to an arbitrary child node whose stored subnetwork does not have any link of $F$ . The flip side of such a simple procedure is that the leaf node we reach may be relevant for $F$ only with a small probability; as it will turn out, exponentially small. In turn, it depends only on the parameter $h$ and not on $f , L$ , or the network size. Optimizing $h$ and repeating the query in sufficiently many independent trees ensures a high success probability.

Detailed Construction. Let $f , L$ be positive integers that may depend on $n$ . The sensitivity $f$ is assumed to be much smaller than the cut-off parameter $L$ , namely, $f = o ( \log L )$ . We now implement the data structure that preserves paths with hop-length most $L$ against up to $f$ failing links or nodes in the network. We focus first on fault tolerance against link failures and later extend it to node failures. For now, let $F \subseteq E$ with $| F | \leqslant f$ . We construct a collection of $K$ sampling trees whose nodes all hold a subnetwork of $G$ . Each sampling tree has height $h$ and any internal node has exactly $\alpha$ children. $K , h$ , and $\alpha$ are parameters to be optimized later.

A single tree has $\alpha ^ { h }$ leaves and $O ( \alpha ^ { h } )$ nodes in total. We associate with each node $x$ a set $A _ { x } \subseteq E$ . Intuitively, $A _ { x }$ are the links that are missing in the network stored in $x$ ; equivalently, node $x$ holds the network $G _ { x } = G - A _ { x }$ . If $x$ is the root of the tree, we set $A _ { x } = E$ so that the corresponding network is the empty network (on the same node set $V$ ). Now let $y$ be a child of some node $x$ , its set $A _ { y } \subseteq A _ { x }$ is obtained by selecting each link in $A _ { x }$ independently with probability $p$ . This construction is iterated until the tree has height $h$ . In the same fashion, we build all the sampling trees $T _ { 0 } , T _ { 1 } , \dots , T _ { K - 1 }$ where each random choice along the way is made independently of all others. The total number of stored subnetworks is ${ \dot { O } } ( K \alpha ^ { h } )$ and the $f$ -covering of $G$ is given by the family $\mathcal { G }$ of all subnetworks that are stored in the leaves of all the $K$ sampling trees.

We will heavily use the fact that the link distribution in the random sets $A _ { x }$ only depends on the depth $r$ of the node $x$ . Moreover, even though two different nodes are not independent, the links present in a single node indeed are. The following lemma has a simple proof by induction over $r$ .

For a positive integer $\ell$ , we denote $\{ 0 , \ldots , \ell - 1 \}$ by $[ \ell ]$

Lemma 6. Let $i \in [ K ]$ be an index and $x$ a node of the tree $T _ { i }$ at depth $r \geqslant 0$ . For any $e \in E$ , we have $\mathrm { P } [ e \in A _ { x } ] = p ^ { r }$ . Moreover, for any two different links $e , e ^ { \prime } \in E$ , the events $e \in A _ { x }$ and $e ^ { \prime } \in A _ { x }$ are independent.

Query Algorithm. For the data structure to be efficient, we need to quickly find $\mathcal { G } _ { F }$ when given a query set $F \subseteq E$ with $| F | \leqslant f$ . The procedure is summarized in Algorithm 1. Recall that the set $A _ { x } \subseteq E$ contains those links that are removed in the subnetwork $G _ { x }$ of the node $x$ . The trees $T _ { 0 } , \dots , T _ { K - 1 }$ are searched individually, starting in the re

# Algorithm 1: Query algorithm.

1 $\mathcal { G } _ { F }  \emptyset$ ;   
2 for $i = 0$ to $K { - } 1$ do   
3 $x \gets$ root of $T _ { i }$ ;   
4 while $x$ is not a leaf do   
5 noChildFound $$ TRUE;   
6 forall children y of $x$ do   
7 if $F \subseteq A _ { y }$ then   
8 $x \gets y$ ;   
9 $n o C h i l d F o u n d \gets \mathrm { F A L S E } .$   
10 break inner for-loop;   
11 if noChildFound then   
12 continue outer for-loop;   
13 ${ \mathcal { G } } _ { F } \gets { \mathcal { G } } _ { F } \cup \{ G _ { x } \} ;$

spective roots. In each step, the algorithm always chooses some (any) child $y$ of the current node $x$ with $F \subseteq A _ { x }$ , and continues the search there. If no such $y$ exists, the current tree is abandoned. Once a leaf is reached, the subnetwork stored there is added to $\mathcal { G } _ { F }$ . Up to $K$ subnetworks relevant for the query set $F$ are collected in total time $O ( f K \alpha h )$ as every node has $\alpha$ children and the trees have height $h$ .

Analysis. Before we optimize the parameters $K , \alpha , h$ , and $p$ , we show the correctness of the query algorithm. It is clear that no network in $\mathcal { G } _ { F }$ contains a failing link from $F$ since it is explicitly verified that $F \subseteq A _ { y }$ before recursing to $y$ . It could be that $\mathcal { G } _ { F }$ remains empty. This happens if, for every single tree, the outer for-loop of Algorithm 1 is continued in line 12 since a node is encountered whose children all have $F \nsubseteq A _ { y }$ . As part of the correctness proof, we bound the probability of this event. In the following, given two nodes $s , t \in V$ and $F \subseteq E$ , we denote by $\pi ( s , t , F )$ a shortest path from $s$ to $t$ in $G - F$ , a.k.a. a replacement path.

Lemma 7. Let $i \in [ K ]$ , $F \subseteq E$ with $| F | \leqslant f$ , and $s , t \in V$ such that $\pi = \pi ( s , t , \boldsymbol { F } )$ contains at most $L$ links.

(i) Algorithm 1 reaches a leaf of the sampling tree $T _ { i }$ with probability at least $( ( 1 - \bar { ( 1 - p ^ { f } ) ^ { \alpha } } ) ^ { \bar { h } }$ .   
(ii) If Algorithm $\jmath$ reaches a leaf $x$ of $T _ { i }$ , then the probability of $\pi$ existing in $G _ { x }$ is at least $( 1 - p ^ { h } ) ^ { L }$ .

Proof. To prove Clause $( i )$ , we first establish the following claim. Let $x$ be an inner node of $T _ { i }$ with $F \subseteq A _ { x }$ and $y _ { 0 } , \ldots , y _ { \alpha - 1 }$ its children. Then, the probability that a child has $F \subseteq A _ { y _ { j } }$ is at least $1 - ( 1 - p ^ { f } ) ^ { \alpha }$ . Any set $A _ { y _ { j } }$ is obtained from $A _ { x }$ by sampling each link independently with probability $p$ . Since $F \subseteq A _ { x }$ , we have $\operatorname { P } [ \overbar { F } \subseteq A _ { y _ { j } } ] \ = p ^ { | F | } \geqslant p ^ { f }$ and $\begin{array} { r } { \mathrm { P } [ \exists j \in [ \alpha ] \colon F \subseteq A _ { y _ { j } } ] = 1 - \prod _ { j = 0 } ^ { \alpha - 1 } \mathrm { P } [ F \not \subseteq A _ { y _ { j } } ] } \end{array}$ . So the latter probability is lower bounded by $1 - \left( 1 - p ^ { f } \right) ^ { \alpha }$ .

The derivation depends only the condition ${ \dot { F } } \subseteq A _ { x } ^ { \prime }$ and not on the path through $T _ { i }$ by which the query algorithm reaches the node $x$ . Since Algorithm 1 maintains this condition, we can iterate that argument for each of the $h$ parentchild transitions, which proves Clause $( i )$ .

For Clause $( i i )$ , consider the algorithm reaching a leaf $x$ of $T _ { i }$ at depth $h$ . Evidently, we have $F \subseteq A _ { x }$ , but for all other links $e ~ \in ~ E \backslash F$ , it holds that $\mathrm { P } [ e \in A _ { x } ] \ = \ p ^ { h }$ by Lemma 6. The replacement path $\pi$ survives in $G _ { x }$ with probability $\mathrm { P } [ E ( \pi ) \cap \mathsf { \bar { A } } _ { x } = \varnothing ] = ( 1 - p ^ { h } ) ^ { | E ( \pi ) | } \geqslant ( 1 - p ^ { h } ) ^ { L }$ .

Optimizing the Parameters. The number of subnetworks is $\operatorname { \bar { O } } ( K \alpha ^ { h } )$ out of which the query algorithm selects at most $K$ in time $O ( f K a h )$ . This incentives us to choose all those parameters as small as possible, especially the height $h$ of the sampling trees. Moreover, the probability to reach a leaf of a tree is exponentially small in $h$ (Lemma 7 (i)). However, once a leaf is actually reached, the probability of the stored network holding a relevant replacement path $\pi ( s , t , F )$ grows exponentially with $h$ . We need to cover all pairs $s , t \ \in \ V$ that have a shortest path in $G \mathrm { - } F$ with at most $L$ links. Our strategy for setting the parameters is to keep the height small and instead boost the success probability by choosing a larger branching factor $\alpha$ and number of independent trees $K$ , and balance the selection with a suitable sampling probability $p$ . Let $c > 0$ be a sufficiently large constant. We set the parameters as $h \ = \ { \sqrt { f \ln L } }$ , $\begin{array} { r } { K = c ( \frac { e } { e - 1 } ) ^ { h } f \ln n } \end{array}$ , $\alpha = L ^ { f / h }$ , and $p = L ^ { - 1 / h }$ .

Lemma 6 states that in any leaf $x$ , at depth $h$ , the probability for any link to be removed (i.e., $e \in A _ { x } ,$ ) is $p ^ { h } \dot { = } 1 / L$ . Not coincidentally, this is the same probability used by Weimann and Yuster (2013). We verify next that the query algorithm indeed finds a suitable collection of networks. The lemma also implies that the networks stored in the leaves of the trees form an $( L , f )$ -replacement path covering w.h.p.

Lemma 8. W.h.p. over all ${ \textbf { \textit { F } } } \subseteq E$ with $\vert F \vert \ \leqslant \ f$ and $s , t \in V$ with $| \bar { E } ( \pi ( s , t , F ) ) | \ \leqslant \ L$ , after the termination of Algorithm $\jmath$ , the path $\pi ( s , t , F )$ exists in a network of $\mho _ { F }$ .

Proof. The proof heavily relies on the estimates derived in Lemma 7. The probability to reach a leaf $x$ in some tree $T _ { i }$ whose corresponding network $G _ { x }$ contains the replacement path $\pi ( s , t , F )$ is at least $( ( 1 - ( \bar { 1 } - p ^ { f } ) ^ { \alpha } ) ^ { h } \cdot ( 1 - \bar { p } ^ { h } ) ^ { L }$ . We estimate the two factors separately starting with the second. Inserting the parameters gives $\begin{array} { r } { ( 1 - \bar { p } ^ { h } ) ^ { L } \geqslant ( 1 - L ^ { - 1 } ) ^ { L } \geqslant \frac { 1 } { 4 } } \end{array}$ Observe that 1− 1 − pf α = 1− 1 − Lf1/h Lf/h ⩾ 1 1 . The total probability is thus at least $\textstyle { \frac { 1 } { 4 } } ( 1 - { \frac { 1 } { e } } ) ^ { h } \ : = \ : { \frac { 1 } { 4 } } ( { \frac { e - 1 } { e } } ) ^ { h }$ . Repeating the query in $\begin{array} { r } { K \ = \ c ( \frac { e } { e - 1 } ) ^ { h } f \ln n } \end{array}$ independent trees reduces the failure probability for any triple $( s , t , F )$ to $\begin{array} { r } { \left( 1 - \frac { 1 } { 4 } \left( \frac { e - 1 } { e } \right) ^ { h } \right) ^ { c ( \frac { e } { e - 1 } ) ^ { h } f \ln n } \ \leqslant e ^ { - \frac { c } { 4 } f \ln n } = n ^ { - \frac { c } { 4 } f } . } \end{array}$ . A union bound over the at most $| V ^ { 2 } \times \binom { E } { \leqslant f } | \ = \ O ( n ^ { 2 + 2 f } )$ triples shows that the failure probability of the whole algorithm is of order $O ( n ^ { 2 + 2 f - \frac { c } { 4 } f } )$ . Choosing a sufficiently large constant $c$ thus ensures a high success probability.

We are left to compute the number of networks and query time. Let $C$ abbreviate $\begin{array} { r } { \frac { e } { e - 1 } \approx 1 . 5 8 2 } \end{array}$ and note that $C ^ { h } = C ^ { \sqrt { f \ln L } } = \left( L ^ { \frac { \ln C } { \ln L } } \right) ^ { \sqrt { f \ln L } } = L ^ { \ln C { \sqrt { \frac { f } { \ln L } } } } = L ^ { o ( 1 ) }$ . The last estimate uses $f ~ = ~ o ( \log L )$ . Similarly, we have $\alpha = L ^ { f / h } = L \sqrt { f / \ln L } = L ^ { o ( 1 ) }$ . Our choice of parameters thus implies that the whole data structure stores ${ \dot { O } } ( K \alpha ^ { h } ) =$

$O ( f C ^ { h } L ^ { f } \log n ) = O ( f L ^ { f + o ( 1 ) } \log n )$ networks and computes a subfamily of $K = { \cal O } ( f L ^ { o ( 1 ) } \log n )$ of them that are relevant for the failure set $F$ in time $O ( f K \alpha h ) \ =$ $\begin{array} { r c l } { { O ( f ( L ^ { o ( 1 ) } ) ^ { 2 } f ( \log n ) \sqrt { f \log L } ) } } & { { = } } & { { O ( f ^ { 5 / 2 } L ^ { o ( 1 ) } \log n ) } } \end{array}$ . This proves Theorem 1 for the case of link failures.

If the sensitivity is up to $f = o ( \log n )$ , then we have $h =$ $\sqrt { f \ln { \cal L } } = o ( \log \bar { n } )$ since $L$ is at most $n$ . This results in a total number of subnetworks of $O ( f C ^ { h } L ^ { f } \log n ) = L ^ { f } n ^ { o ( 1 ) }$ , $| \mathcal { G } _ { F } | = O ( f C ^ { h } \log n ) = n ^ { o ( 1 ) }$ of which are relevant for a given query, and a query time of O(f 2ChLf/hh) = no(1).

Node Failures. The changes needed to accompany node failures are minuscule. Instead of a set of links, we now associate with every tree node $x$ a set $A _ { x } \subseteq V$ of network nodes. We have $A _ { x } = V$ in the roots and in each child $y$ of $x$ , we include any element of $A _ { x }$ independently with probability $p$ . Note that then the network $G _ { x } = G - A _ { x }$ is the subnetwork of $G$ induced by the node set $| V \backslash A _ { x }$ . As the sampling remains the same, we get an analog of Lemma 6.

Lemma 9. Let $i \in [ K ]$ be an index and $x$ a node of the tree $T _ { i }$ at depth $r \geqslant 0$ . For any $v \in v$ , we have $\mathrm { P } [ v \in A _ { x } ] = p ^ { r }$ . For any two different network nodes $v , v ^ { \prime } \in V$ , the events $v \in A _ { x }$ and $v ^ { \prime } \in A _ { x }$ are independent.

The other lemmas follow from this almost verbatim as before. The only differences are that, if Algorithm 1 reaches a leaf, then the probability of the replacement path existing in the subnetwork is $( 1 - p ^ { \check { h } } ) ^ { L + 1 }$ for if the replacement path has cuoprtroe $L$ iloin kfas,ctitorcian  Lheavmemuap8tot $L + 1$ $\begin{array} { r } { ( 1 - L ^ { - 1 } ) ^ { L + 1 } \geqslant \frac { 1 } { 8 } } \end{array}$ ,anwgheischthies counter-acted by choosing the constant $c$ in the definition of the number of trees $K$ marginally larger. In contrast to link failures, there are $| V ^ { 2 } \times \binom { \bar { V _ { } } } { \leqslant f } | = \bar { O } ( n ^ { \bar { 2 } + f } )$ relevant queries.

# Distance Sensitivity Oracles

Recall that, given $s , t \in V$ and a set $F$ of at most $F$ failures, an $L$ -hop $f$ -DSO reports an overestimate of the length of $\pi ( s , t , F )$ that matches the lower bound if $G - F$ contains an $L$ -hop shortest $s$ - $\mathbf { \nabla } \cdot t$ path. It is straightforward to turn our generic tree structure of Theorem 1 into an $L$ -hop $f$ - DSO. After all, that was the original purpose of Weimann and Yuster (2013) when defining $( L , F )$ -RPCs. The only difference we make is to precompute for every leaf $x$ of all sampling trees the pairwise distances of nodes in $G _ { x }$ . The query works exactly as Algorithm 1 only that, upon query $( s , t , F )$ , in line 13 the stored distance from $s$ to $t$ in $G _ { x }$ is recorded. The value returned by our $L$ -hop $f$ -DSO is given by the minimum of the computed distances.

The construction of the oracle is dominated by preparing the distances in the leaves. The preprocessing time is $\widetilde { O } \overline { { ( f L ^ { f + o ( 1 ) } \cdot T _ { \mathrm { A P S P } } ) } }$ , where $T _ { \mathrm { A P S P } }$ is the time needed to ceompute all-pairs shortest paths (APSP) in an arbitrary subnetwork of $G$ . It depends on the properties of $G$ . If there are no negative cycles (e.g., because all link weights are non-negative), one can use Dijkstra’s or Johnson’s algorithm running in time $T _ { \mathrm { A P S P } } \stackrel { \cdot } { = } \stackrel { \cdot } { \cal \tilde { O } } ( m n )$ . If instead one is willing to use fast matrix multip ceation, then APSP can be computed in time ${ \widetilde { O } } ( M n ^ { \omega } )$ for undirected networks with non-negative integer link weights in [M ], or O(M n2.5286) for directed networks with integer weights in $\{ - M , \ldots M \}$ (Alon, Galil, and Margalit 1997; Seidel 1995; Shoshan and Zwick 1999; Zwick 2002). Here, $\omega < 2 . 3 7 1 5 5 2$ is the matrix multiplication exponent (Duan, Wu, and Zhou 2023; Vassilevska Williams, Xu, Xu, and Zhou 2024).

The space of the data structure is $\widetilde { \cal O } ( f L ^ { f + o ( 1 ) } n ^ { 2 } )$ , again dominated by storing the distances i  tehe leaves. In turn, the query time remains at $\widetilde { O } ( f ^ { 5 / 2 } L ^ { o ( 1 ) } )$ as the values $d _ { G _ { x } } ( s , t )$ can be looked up in conestant time. This proves Theorem 2.

# Sensitivity Oracles for $k$ -PATH

We now turn to the fixed-parameter sensitivity oracle for the NP-complete $k$ -PATH problem. We only treat link failures here, (i.e., $F \subseteq E ,$ ) to ease notation. We further assume that access to an algorithm that computes simple paths with $k$ links ( $k$ -paths) in subnetworks of $G$ in a way that respects a certain inheritance property. Suppose $F$ has at most $f$ links, $G \mathrm { - } F$ has a $k$ -path and the algorithm we use produces such a path $P$ . Then for any subnetwork $H \subseteq G - F$ that still contains $P$ , we require that the same path $P$ is also the output on of the algorithm in $H$ . Note that such a tie-breaking scheme is obtained by assign distinct weights to the links in $E$ and always choosing the $k$ -path of minimum weight.

Our data structure is based on the sampling trees above, where we naturally set $L = k$ and thus assume $k = o ( \log k )$ . The construction of the trees with parameters $K , \alpha , h$ , and $p$ is almost as before. The difference is that any node $x$ of a tree $T _ { i }$ is not only associated with one set of links $A _ { x }$ , but also with a second one $S _ { x }$ . In a parent-child traversal from $x$ to $y$ , $A _ { y }$ is still obtained from $A _ { x }$ by sampling each link of $A _ { x }$ with probability $p$ .

The construction of $S _ { y }$ is a bit more involved. Let $r$ be the depth of the parent, and thus $\boldsymbol { r } + \boldsymbol { 1 }$ the depth of the child $y$ . Let $S _ { x }$ be the set associated with its parent. To unify the exposition, if $y$ is the root, we set $S _ { x } ~ = ~ E$ . To construct $S _ { y }$ from $S _ { x }$ , we first build a family $\mathcal { P } _ { y }$ of paths in $4 ^ { f } \alpha ^ { h - ( r + 1 ) } \ln h$ independent rounds. In each round, we sample a subset $I \subseteq A _ { y }$ by selecting each link in $A _ { y }$ independently with probability $p ^ { h - ( r + 1 ) } / 2$ . If there exists a $k$ -path in the network with link set $S _ { x } \backslash I$ , we add the one computed with the inheritance property to $\mathcal { P } _ { y }$ . After the last round, we set $S _ { y }$ to the union of the paths in $\mathcal { P } _ { y }$ . This ensures $S _ { y } \subseteq S _ { x }$ . Intuitively, for an (inherited) $k$ -path from $S _ { x }$ to not survive in $\mathcal { P } _ { y }$ , it must have been destroyed by all the random deletions $I$ . If $x$ is a leaf, we not only store $S _ { x }$ but also the path information in ${ \mathcal P } _ { x }$ .

The query algorithm is very similar to Algorithm 1. The difference is that line 7 now checks for $F \cap S _ { x } \subseteq A _ { y }$ (previously, $F \subseteq A _ { y } { \mathrm { , } }$ ). In line 13, where a leaf $x$ is reached, the query algorithm searches ${ \mathcal P } _ { x }$ for a $k$ -path that is disjoint from $F$ . If one exists, it is output and the whole algorithm terminates; if no such path exists, the search continues with the next tree. If none of the trees $T _ { 0 } , \dots , T _ { K - 1 }$ produce such a path, it is reported that $G \mathrm { - } F$ does not have a $k$ -path.

Analysis. We use different parameters for this oracle: $h = \sqrt { f \ln ( k / f ) }$ , $K \ : = \ : c \ : 8 ^ { h } f \ln n$ , $\alpha = ( k / f ) ^ { f / h }$ , and $p = ( f / k ) ^ { 1 / h }$ . Note that $\alpha = 1 / p ^ { f }$ still holds.

Let $y$ be a node in the tree $T _ { i }$ , $r$ its depth, and $S _ { x }$ the edge set in the parent $\mathbf { \nabla } \cdot S _ { x } = E$ in the root). Assume $G \mathrm { - } F$ has a $k$ -path, let $P$ be the one computed with the inheritance property. $E ( P )$ is its set of links. We say $y$ is well behaved if it satisfies the following properties: (P1) $F \cap S _ { x } \subseteq A _ { y }$ , (P2) $| E ( P ) \cap A _ { y } | \leqslant p ^ { r } k$ , and (P3) $P \in \mathcal { P } _ { y }$ .

The query algorithm enforces (P1) in every step of the way. We are mainly interested in the probability of (P3) holding in the leave that is reached for a query. We bound this using well-behaved children.

Lemma 10. Let $i \in [ K ]$ and x a non-leaf node in $T _ { i }$ .

(i) If x satisfies (P1), then there exists a child y of $x$ also satisfying (P1) with probability is at least $\textstyle { \mathrm { 1 - } } { \frac { 1 } { e } }$ .   
(ii) If x satisfies (P2), then, for any child y of $x$ , the probability that y also satisfies (P2) is at least $\textstyle { \frac { 1 } { 4 } }$ .   
(iii) If $x$ is well behaved and has a child $y$ that satisfies both (P1) and (P2), then the probability that $y$ is even well behaved (satisfies (P3)) is at least $\textstyle 1 - { \frac { 1 } { h } }$ .

Moreover, the events are independent of each other.

Proof. Suppose $x$ satisfies (P1), let $S _ { z }$ be the set of its parent (or $S _ { x } = E _ { \mathrm { { \scriptscriptstyle . } } }$ ) and let $y _ { 0 } , \ldots , y _ { \alpha - 1 }$ be the children of $x$ . We have $F \cap S _ { x } \subseteq F \cap S _ { z } \subseteq A _ { x }$ . The first inclusion is due to $S _ { x } \subseteq S _ { z }$ and the second one due to (P1). Since the elements of $A _ { y _ { j } }$ are sampled from $A _ { x }$ with probability $p$ , there exists an index $j \in [ \alpha ]$ such that $F \cap S _ { x } \subseteq A _ { y _ { j } }$ with probability $\begin{array} { r } { 1 - \prod _ { j = 0 } ^ { \alpha - 1 } \operatorname { P } [ F \cap S _ { x } \not \subseteq A _ { y _ { j } } ] \geqslant 1 - ( 1 - p ^ { f } ) ^ { \alpha } \geqslant 1 - \frac { 1 } { e } } \end{array}$ .

We turn to Clause $( i i )$ . Let $r$ be the depth of $x$ . We now assume that $x$ satisfies (P2) (but not necessarily the other properties). That means, at most a $p ^ { r }$ ratio of the $k$ links of the path $P$ are removed in the network $G _ { x }$ (are in the set $\textstyle A _ { x } .$ ). For any child $y$ of $x$ , the expected size of $E ( P ) \cap A _ { y }$ is $p \ \cdot \ | E ( P ) \cap A _ { x } | \ \leqslant \ p ^ { r + 1 } k$ . In fact, the random variable $| E ( P ) \cap A _ { y } |$ is binomially distributed with parameters $| E ( \Dot { P } ) \cap \Dot { A } _ { x } |$ and $p$ . The Central Limit Theorem states that $\begin{array} { r } { \mathrm { P } [ | E ( P ) \cap A _ { y } | > p ^ { r + 1 } k ] \leqslant \frac { 3 } { 4 } } \end{array}$ . Since the depth of $y$ is $r + 1$ , that implies that $y$ satisfies (P2) with probability $\textstyle { \frac { 1 } { 4 } }$ .

The main part of this proof is Clause $( i i i )$ as it involves the new sets $S _ { y }$ . Let $x$ be well behaved and its child $y$ satisfy (P1) and (P2). Consider any of the round in the creation of $S _ { y }$ and let $I \subseteq A _ { y }$ be the sampled subset. We want to know whether the specific $k$ -path $P$ from $G { - } F$ is included in $\mathcal { P } _ { y }$ in this round. Due to the inheritance property, it is sufficient that $E ( P ) \subseteq ( S _ { x } \backslash I )$ and at the same time $F \cap ( S _ { x } \backslash I ) = \emptyset$ . The latter condition formalizes that the network with edge set $S _ { x } \backslash I$ is a subnetwork of $G - F$ .

We bound the probability of the two events. Parent $x$ is well behaved, a fortiori it satisfies (P3), thus $E ( P ) \subseteq$ $S _ { x }$ . Each link in $I$ is drawn from $A _ { y }$ with probability $p ^ { h - ( r + 1 ) } / 2$ . We have $E ( P ) \subseteq ( S _ { x } \backslash I )$ if none of the links in $E ( P ) \cap A _ { y }$ are drawn. Since $y$ satisfies (P2), this has probability at least $\begin{array} { r } { \big ( 1 - \frac { p ^ { h - ( r + 1 ) } } { 2 } \big ) ^ { | E ( P ) \cap A _ { y } | } \geqslant \big ( 1 - \frac { p ^ { h - ( r + 1 ) } } { 2 } \big ) p ^ { r + 1 } k } \end{array}$ . Inserting the definition $\begin{array} { r } { p \ = \ ( \frac { f } { k } ) ^ { 1 / h } } \end{array}$ , we get $p ^ { h - ( r + 1 ) } \ =$ prf+1k and pr+1k ⩾ phk = f. Above estimate gives (1 − $\begin{array} { r } { \frac { p ^ { h - ( r + 1 ) } } { 2 } ) ^ { p ^ { r + 1 } k } = \big ( 1 - \frac { f } { 2 \cdot p ^ { r + 1 } k } \big ) ^ { p ^ { r + 1 } k } \geqslant \big ( 1 - \frac { f } { 2 \cdot f } \big ) ^ { f } = \frac { 1 } { 2 ^ { f } } . } \end{array}$ .

Next is the probability that the sets $F$ and $S _ { x } \backslash I$ are disjoint. Since the child $y$ also satisfies (P1), we have $F \cap S _ { x } \subseteq$ $A _ { y }$ . The sample $I$ is also a subset of $A _ { y }$ . So for $F \cap S _ { x } \backslash I = \emptyset$ all links in $F \cap S _ { x }$ must be selected for $I$ . This event has probability ( ph−(r+1) ) $\begin{array} { r } { \big ( \frac { p ^ { h - ( r + 1 ) } } { 2 } \big ) ^ { | F \cap S _ { x } | } \geqslant \big ( \frac { p ^ { h - ( r + 1 ) } } { 2 } \big ) ^ { f } = \frac { p ^ { f ( h - ( r + 1 ) ) } } { 2 ^ { f } } } \end{array}$ . Recall that we chose the parameter such that $p ^ { f } = \alpha ^ { - 1 }$ . The last estimate is thus equal to 2−f α−(h−(r+1)).

Since the events $E ( P ) \subseteq ( S _ { x } \backslash I )$ and $F \cap ( S _ { x } \backslash I ) = \emptyset$ are independent, they occur together with probability at least $4 ^ { - f } \alpha ^ { - ( \bar { h } - ( r + 1 ) ) }$ . We give the construction algorithm of our data structure $4 ^ { f } \alpha ^ { h - ( \bar { r } + 1 ) } \ln h$ rounds to try for it. The probability to include the path $P$ in $\mathcal { P } _ { y }$ in any of the rounds is thus at least 1 −  1 − 4f αh−1(r+1)  $\begin{array} { r } { 1 - \left( 1 - \frac { 1 } { 4 ^ { f } \alpha ^ { h - ( r + 1 ) } } \right) ^ { 4 ^ { f } \alpha ^ { h - ( r + 1 ) } \cdot \ln h } \geqslant 1 - \frac { 1 } { h } } \end{array}$

We now prove the correctness of the query algorithm. If $G { - } F$ does not have a $k$ -path, then the procedure indeed reports this fact. If it reaches a leaf $x$ at all, it explicitly scans ${ \mathcal P } _ { x }$ for a path that is disjoint from $F$ . In the case that $G \mathrm { - } F$ has a $k$ -path, we argue over the parentchild traversals. It is convenient to also include the algorithm jumping into the root of a tree as the first step. Recall that for the root $y$ , we set $A _ { y } ~ = ~ E$ and use the convention $S _ { x } = E$ . Therefore, $y$ trivially satisfies the properties (P1) and (P2). Lemma 10 thus shows that the root is well behaved with probability $( 1 - { \textstyle { \frac { 1 } { e } } } ) { \textstyle { \frac { 1 } { 4 } } } ( 1 - { \textstyle { \frac { 1 } { h } } } )$ . Furthermore, since the algorithm actively looks for a child satifying (P1), Lemma 10 can also be iterated over the following $h$ traversals. In summary a well-behaved child is reached with probability $\begin{array} { r } { ( ( 1 - \frac { 1 } { e } ) \frac { 1 } { 4 } ( 1 - \frac { 1 } { h } ) ) ^ { h + 1 } \geqslant \frac { 1 } { 8 ^ { h } } } \end{array}$ . Repeating this in all $K = c \cdot 8 ^ { h } f \ln n$ trees for a sufficiently large constant $c > 0$ gives a high success probability over the $\bar { | } \bar { ( } _ { \leqslant f } ^ { E } ) | = O ( n ^ { 2 f } )$ possible query sets $F$ .

Query Time, Space, and Preprocessing Time. Recall that we chose the parameters as $K \ = \ { { c 8 } ^ { h } } { f \ln { n } }$ , $\alpha \ =$ $( k / f ) ^ { f / h }$ , and $h = \sqrt { f \ln ( k / f ) }$ . As before, this implies $\begin{array} { r } { 8 ^ { h } = 8 \sqrt { f \ln ( k / f ) } = ( k / f ) ^ { \frac { \ln 8 } { \ln ( k / f ) } \sqrt { f \ln ( k / f ) } } = ( k / f ) ^ { o ( 1 ) } } \end{array}$ , where we use $f \ = \ o ( \log k )$ . That means, we have $K =$ $( k / f ) ^ { o ( 1 ) } f \ln n$ . However, the assumption on $f$ also implies that $\log f \ = \ o ( \log k )$ (for any positive base of the logarithm). Via $\log ( k / f ) = \log ( k ) - \log ( f ) = ( 1 - o ( 1 ) ) \log ( k )$ , we get the seemingly stronger statement $f = o ( \log ( k / f ) )$ . We conclude $\scriptstyle \alpha = ( k / f ) ^ { f / h } = ( k / f ) { \sqrt { f / \ln ( k / f ) } } = ( k / f ) ^ { o ( 1 ) }$ .

The total query time is $O ( K \alpha h f + K f 4 ^ { f } \log h )$ . The first term is derived as in the generic construction, assuming that the test $F \cap S _ { x } \subseteq A _ { y }$ can be done in $O ( f )$ time. We explain below how to implement that. The second term describes the time needed to search the collection ${ \mathcal P } _ { x }$ in all the leaves the query algorithm may reach. Using the parameters gives $O ( ( \bar { k } / f ) ^ { o ( 1 ) } f ^ { 2 } \sqrt { f \ln ( \bar { k } / f ) } \ln n + ( k / \bar { f } ) ^ { o ( 1 ) } f ^ { 2 } 4 ^ { f } \log h ) |$ . The second term of order $\widetilde { \cal O } ( 4 ^ { f } f ^ { 2 - o ( 1 ) } k ^ { o ( 1 ) } )$ is dominating.

For the space, conside ea node $y$ in one of the trees that is not a root, let $S _ { x }$ be the second set associated with its parent. We define $B _ { y } \ = \ S _ { x } \cap A _ { y }$ . Observe that we have $F \cap S _ { x } \subseteq A _ { y }$ if and only if $F \cap S _ { x } \subseteq B _ { y }$ . So it is enough to store $B _ { y }$ instead of $A _ { y }$ and we can indeed make that check in time $O ( | F \cap S _ { x } | ) = O ( f )$ . It will be advantageous for the analysis that both $B _ { y }$ and $S _ { y }$ are subsets of $S _ { x }$ .

The final data structure stores the trees $T _ { i }$ for all $i \in [ K ]$ ; in each root $x$ the set $S _ { x }$ ; in each non-root node $y$ the sets $B _ { y }$ and $S _ { y }$ ; and in each leaf $y$ the set $S _ { y }$ and paths in $\mathcal { P } _ { y }$

Let $r$ be the depth of a node $x$ , and let $y$ be a child of $x$ . It is enough to bound the size of the path collection ${ \mathcal P } _ { x }$ since it dominates the size of the union $S _ { x }$ , and in turn the sizes of the subsets $B _ { y }$ and $S _ { y } . \mathcal { P } _ { x }$ contains at most $4 ^ { f } \alpha ^ { h - r } \ln h$ different $k$ -paths and thus takes space $O ( 4 ^ { f } \alpha ^ { h - r } k \log h )$ . Note that this is independent of the input graph $G$ .

There are $\alpha ^ { r }$ many nodes in a tree at depth $r$ , giving space $\widetilde { O } ( 4 ^ { f } \alpha ^ { h } k )$ per level, and $\tilde { O } ( K h 4 ^ { f } \bar { \alpha ^ { h } k } )$ for all levels an etrees together. Due to $\alpha ^ { h } \ \stackrel { } { = } \ ( k / f ) ^ { f }$ , this is $\widetilde { \cal O } ( ( 4 ^ { f } f ^ { 3 / 2 } ( k / f ) ^ { f + o ( 1 ) } k ) = \widetilde { \cal O } ( ( ( k + 4 ) / f ) ^ { f + o ( 1 ) } f ^ { 3 / 2 } k )$ .

For the preprocessing, w e use the $k$ -path algorithm by Williams (2009) running in time $2 ^ { k } { \mathsf { p o l y } } ( { \mathsf { \bar { n } } } )$ . We spend time $4 ^ { f } \alpha ^ { h - r } \cdot 2 ^ { k } \mathsf { p o l y } ( n )$ preprocessing one tree node at depth $r$ $4 ^ { f } \alpha ^ { h } \cdot 2 ^ { k } \mathsf { p o l y } ( n )$ in each level, and $( ( k { + } 4 ) / f ) ^ { f + o ( 1 ) } f ^ { 3 / 2 }$ · $2 ^ { k } { \mathsf { p o l y } } ( n )$ in total.

Cliques, Stars, and Cycles. Throughout the analysis, we never actually used the path structure of the solution, only that it had $k$ edges. We can thus replace $k$ -paths by any other graph motif we desire. However, be aware that $k$ -cliques have ${ \binom { k } { 2 } } \ = \ O ( k ^ { 2 } )$ edges. Also, there are no known algorithms for finding $k$ -cliques in time $g ( k ) \cdot \mathsf { p o l y } ( n )$ .

# Open Questions

We made some progress in the design of fault-tolerant data structures for network problems. There are, however, several interesting open problems left in the area.

• The randomized construction by Weimann and Yuster (2013) has $\widetilde { O } ( f L ^ { f } )$ subnetworks. The deterministic one by Karthik end Parter (2021) needs $\widetilde { O } ( f L ) ^ { f + 1 }$ . Is it possible to design a deterministic $( L , f )$ -replacement path covering with $\widetilde { O } ( L ^ { f } )$ subnetworks? • Karthik and P reter (2021) also gave a lower bound on the size of $( L , f )$ -RPCs. They showed that for any $n , L , f$ such that $( \dot { L } / f ) ^ { f + 1 } \leqslant n$ , there exists a network $G$ with $n$ nodes such that any $( L , f )$ -RPC for $G$ must contain $\Omega ( ( L / f ) ^ { f } )$ networks. Even Weimann and Yuster (2013) are off by a factor $\widetilde { O } ( f ^ { f + 1 } )$ . Can this gap be closed? • Beyond the mere neumber of subnetworks, our sampling trees requires $\Omega ( n ^ { 2 } )$ space when storing the networks associated with the nodes. Is there a more compact data structure for indexed subnetworks? It is known that in subquadratic space one must relax the requirement of retrieving exact shortest paths (Thorup and Zwick 2005). • Is it possible to generalize our framework to extremal distances, such as fault-tolerant diameter (Bilo\`, Choudhary, Cohen, Friedrich, and Schirneck 2022b), or to other network models, like temporal networks (Deligkas, Do¨ring, Eiben, Goldsmith, Skretas, and Tennigkeit 2025)? • Finally, it would be interesting to implement our indexing scheme and compare its empirical performance with the Weimann and Yuster (2013) construction.