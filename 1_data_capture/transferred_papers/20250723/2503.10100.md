# SOLA-GCL: Subgraph-Oriented Learnable Augmentation Method for Graph Contrastive Learning

Tianhao Peng1, Xuhong $\mathbf { L i } ^ { 2 }$ , Haitao Yuan3∗, Yuchen $\mathbf { L i } ^ { 2 , 4 }$ , Haoyi Xiong2

1Beihang University 2Baidu Inc. 3Nanyang Technological University 4Shanghai Jiao Tong University pengtianhao $@$ buaa.edu.cn, lixuhong $@$ baidu.com, yuchenli $@$ sjtu.edu.cn haitao.yuan $@$ ntu.edu.sg, haoyi.xiong.fr@ieee.org

# Abstract

Graph contrastive learning has emerged as a powerful technique for learning graph representations that are robust and discriminative. However, traditional approaches often neglect the critical role of subgraph structures, particularly the intra-subgraph characteristics and inter-subgraph relationships, which are crucial for generating informative and diverse contrastive pairs. These subgraph features are crucial as they vary significantly across different graph types, such as social networks where they represent communities, and biochemical networks where they symbolize molecular interactions. To address this issue, our work proposes a novel subgraph-oriented learnable augmentation method for graph contrastive learning, termed SOLA-GCL, that centers around subgraphs, taking full advantage of the subgraph information for data augmentation. Specifically, SOLA-GCL initially partitions a graph into multiple densely connected subgraphs based on their intrinsic properties. To preserve and enhance the unique characteristics inherent to subgraphs, a graph view generator optimizes augmentation strategies for each subgraph, thereby generating tailored views for graph contrastive learning. This generator uses a combination of intra-subgraph and inter-subgraph augmentation strategies, including node dropping, feature masking, intra-edge perturbation, inter-edge perturbation, and subgraph swapping. Extensive experiments have been conducted on various graph learning applications, ranging from social networks to molecules, under semi-supervised learning, unsupervised learning, and transfer learning settings to demonstrate the superiority of our proposed approach.

# Introduction

Graph structures are used to represent data such as social networks (Zhou et al. 2020), molecules (Li et al. 2023b; Zhang et al. 2023b), and traffic flows (Yuan and Li 2021; Yuan et al. 2023). Graph neural networks (GNNs) (Kipf and Welling 2017; Velickovic et al. 2018; Xu et al. 2019; Yun et al. 2019; Li et al. 2022) have become popular for graph representation learning (Lin et al. 2023; Tang et al. 2023; Li et al. 2023f; Cai et al. 2023; Yuan et al. 2021; Li et al. 2025), but they require labeled data. To learn from unlabeled data, contrastive learning has been adapted to graph data (You et al. 2020, 2021;

Velickovic et al. 2019; Suresh et al. 2021; Yin et al. 2022). This involves generating two views by perturbing the graph and learning representations by maximizing feature consistency (You et al. 2020, 2021; Velickovic et al. 2019; Li et al. 2023c). Graph-structured data are more complex than image or text data due to their properties and distribution shifts (Hassani 2022; Li et al. 2023e; Yuan, Cong, and Li 2024). Methods like DGI (Velickovic et al. 2019), GRACE (Zhu et al. 2020), and GraphCL (You et al. 2020) use random augmentations, but lack automatic selection of augmentation policies, affecting the graphs’ semantic integrity.

Recent advances in Graph Contrastive Learning (GCL) leverage methods like JOAO (You et al. 2021) and LG2AR (Hassani and Ahmadi 2022) adaptively select one augmentation strategy from a predefined pool for specific graph data, followed by random graph view generation process such as node masking and edge dropping. While these methods improve the adaptability of selecting augmentation strategies for individual graphs, their reliance on random view generation may change the original graph semantics. Despite some advancements with end-to-end methods like AD-GCL and AutoGCL, which introduce learnable augmentations, the full potential of subgraph information is still largely unexplored. Methods like MSSGCL (Liu et al. 2023) and SUBG-CON (Jiao et al. 2020) attempt to address this by focusing on the relationships between sampled subgraphs and the entire graph or the central nodes, respectively. However, they still struggle to capture the intra-subgraph characteristics and inter-subgraph relationships (e.g., communities in social networks). Furthermore, while these learnable methods manage to preserve the semantics of original graphs, they lack adaptability across different datasets due to their reliance on uniform augmentation strategies (You et al. 2021, 2020; Li et al. 2024; Lyu et al. 2024), which ultimately limits their flexibility. Here, we conclude the limitations of existing methods as follows.

• Loss of intra-subgraph and inter-subgraph information: Graphs contain important details within subgraphs (intrasubgraph characteristics) and between different subgraphs (inter-subgraph relationships). For instance, in social networks, distinct communities exhibit unique characteristics, while in chemistry, combinations of functional groups determine molecular functionalities. Previous studies have not effectively captured the critical information both within and between subgraphs. How to effectively capture both intra-subgraph characteristics and intersubgraph relationships remains an ongoing challenge.

• Poor adaptability and losing semantic information: Different graph structures necessitate distinct augmentation strategies. For example, molecular graphs may require edge perturbation, whereas social community graphs might benefit more from node dropping (You et al. 2021, 2020). Methods like JOAO, which lack a learnable view generation process, can offer improved adaptability but at the cost of losing semantic information. Conversely, methods with uniform augmentation strategies that include a learnable view generation process, such as AD-GCL, preserve semantic information but often fail to adapt effectively across diverse datasets. Improving the adaptability of GCL methods while preserving semantic integrity remains a significant challenge.

To address above challenges, We propose a novel Subgraph-Oriented Learnable Augmentation method for Graph Contrastive Learning (SOLA-GCL) to tackle existing challenges by leveraging subgraph information for data augmentation. The process begins by dividing the original graph into connected subgraphs using partitioning algorithms, such as the Louvain method (Blondel et al. 2008) for community graphs or RDKit (Landrum 2013) for molecular structures, to identify functional groups. A graph view generator then applies multiple augmentation strategies (node dropping, edge perturbation, subgraph swapping) to these subgraphs, assembling them into a new graph view. This involves a subgraph augmentation selector, which learns the optimal augmentation strategy distribution; a subgraph view generator for implementing these strategies; and a subgraph view assembler. Our method demonstrated superior performance in extensive graph classification experiments across various learning tasks, outperforming state-of-the-art graph contrastive learning approaches.

The main contributions of this study are as follows:

• A novel graph contrastive learning framework, termed SOLA-GCL, is proposed. To the best of our knowledge, this is the first work to build learnable generative augmentation policies that specifically focus on the intrasubgraph characteristics and inter-subgraph relationships within graphs.   
• The proposed SOLA-GCL introduces an end-to-end differentiable training algorithm, enabling automatic augmentation strategy selection and graph view generation.   
• Extensive experiments are conducted on a variety of graph classification datasets with semi-supervised, unsupervised, and transfer learning settings, showcasing the robustness and effectiveness of our SOLA-GCL framework on graph classification tasks.

# Related Work

In this section, we first introduce the studies relevant to our work from the perspectives of graph neural networks, graph partition algorithms, and graph contrastive learning (GCL) algorithms upon views generated by various graph data augmentation strategies. Later, we discuss the unique contributions made by this work compared to previous studies.

# Graph Neural Networks

Graph neural networks (GNNs) are the extension of the neural network models onto graph data (Wu et al. 2021; Li et al. 2023d; Zhang et al. 2023a; Yuan, Li, and Bao 2022; Xiong et al. 2024). Most existing GNNs adopt the messagepassing framework and use permutation-invariant local aggregation schemes to update node representations. For instance, GCN (Kipf and Welling 2017) averages features of all neighboring nodes. GAT (Velickovic et al. 2018) uses an attention mechanism to assign different weights to neighboring nodes. GraphSAGE (Hamilton, Ying, and Leskovec 2017) samples fixed-size neighbors of a node and aggregates their features for realizing fast and scalable GNN training. GIN (Xu et al. 2019) adjusts the weight of the central node by a learnable parameter to distinguish different graph structures based on the graph embedding. ResGCN (Pei et al. 2022) combine the residual connection with GCN to build deeper GNNs.

In this study, we employ two state-of-the-art GNNs, GIN (Xu et al. 2019) and ResGCN (Pei et al. 2022), as our backbone GNNs, following the existing graph contrastive learning literature (You et al. 2020, 2021; Yin et al. 2022). We believe our work could complement with the line of research on GNN while incorporating advanced GNN models for potential improvement in future studies.

# Graph Partition Algorithm

Graph partitioning divides a graph into communities based on node and edge connectivity. Densely connected nodes form communities, while sparsely connected nodes do not. Spectral clustering approximates graph partition solutions using eigenvalue decomposition on the normalized graph Laplacian, but it is computationally expensive. The Louvain method (Blondel et al. 2008) quickly optimizes modularity, a measure of intra-community edge density relative to inter-community edges. The Girvan–Newman (GN) algorithm (Girvan and Newman 2002) identifies communities by removing edges iteratively. However, these methods often ignore node features, despite their richness in recent applications. SGCN (Wang et al. 2021) addresses this by detecting community centers without prior labels. RDKit is a software suite for cheminformatics, computational chemistry, and predictive modeling, which offers graph partition algorithms for molecular graphs (Landrum 2013). In our work, we use the Louvain method (Blondel et al. 2008) and RDKit (Landrum 2013) for graph partitioning before GCL training, but our framework is adaptable to other partition algorithms, including deep learning-based approaches.

# GCL with Data Augmentation

In recent years, GCL with data augmentation has attracted significant attention for self-supervised graph learning. The main idea is to maximize the agreement between representations of a graph in augmented views (Li et al. 2023a).

![](images/309f531441a102385ac673ef26d00d3910b40efc201659b30ea65b36d6d205d2.jpg)  
Figure 1: An illustration of the proposed SOLA-GCL framework. The graph view generator is composed of three critical components: the subgraph augmentation selector, the subgraph view generator, and the subgraph view assembler. The subgraph augmentation selector learns to choose the optimal augmentation strategy for each subgraph, and the subgraph view generator outputs augmented subgraph views according to the selected strategies. The subgraph view assembler constructs an augmented graph view based on these augmented subgraph views.

Recently, GRACE (Zhu et al. 2020) introduces two general types of augmentations (edge perturbation and attribute masking), while GraphCL (You et al. 2020) proposes four (node dropping, edge perturbation, attribute masking, and subgraph sampling), applying these strategies randomly, which limits task adaptability. To address this, JOAO (You et al. 2021) and GPA (Zhang et al. 2022) adaptively select suitable augmentation strategies by learning the distribution of graph datasets. However, these methods often apply random augmentations to specific graphs, resulting in sub-optimal performance. To enhance adaptability in GCL models, AD-GCL (Suresh et al. 2021) uses adversarial training to perturb edges and generate graph views, while AutoGCL (Yin et al. 2022) focuses on perturbing nodes for augmented views. Despite their success, these approaches often overlook the importance of subgraphs. Methods like SUBG-CON (Jiao et al. 2020) and MSSGCL (Liu et al. 2023) have explored subgraph sampling for contrastive learning by generating global and local views at different scales. However, they typically fail to leverage the intra-subgraph characteristics and inter-subgraph relationships fully. To address these limitations, we propose a subgraph-centered method that generates augmented subgraph views and assembles them into an augmented graph, utilizing subgraph information in a learnable manner.

# Discussion on Most Relevant Works

Our GCL framework introduces a learnable graph view generator that focuses on subgraphs to enhance graph understanding (Adhikari et al. 2018; Zhu et al. 2021a). The most relevant works to our study are JOAO and MSSGCL, from the perspectives of model adaptability and subgraph information modeling, respectively.

From the perspective of model adaptability, both JOAO (You et al. 2021) and our SOLA-GCL learn the probability distribution of data augmentation strategies. While

JOAO applies the random graph view generation process that risks altering the original graph’s semantics, our SOLAGCL generates new graph views in a learnable manner, thus preserving the semantic integrity. From the perspective of subgraph information modeling, our proposed SOLA-GCL method differs significantly from MSSGCL (Liu et al. 2023), which focuses on the relationship between the original graph and its sampled subgraph. In contrast, SOLA-GCL method delves deeper, fully exploiting both the crucial intra-subgraph characteristics and inter-subgraph relationships by applying learnable targeted augmentation strategies within and between subgraphs.

# Methodology

This section elaborates on the proposed SOLA-GCL framework for graph classification in detail. With an overview shown in Fig. 1, SOLA-GCL first partitions the graph into several densely connected subgraphs, and then trains the subgraph augmentation selector and subgraph view generator jointly in an end-to-end manner to generate graph views for graph contrastive learning.

# The Basic GNN Module

SOLA-GCL employs a vanilla GNN with $L$ local aggregation layers, enabling nodes to access information from $\breve { L }$ -hop neighbors, as the basic module. Thus, for a given node $v \in$ $\nu$ , the $l$ -th layer’s calculation formula in an $L$ -layer GNN $( l { = } 1 , 2 , . . . , L )$ is as follows:

$$
h _ { v } ^ { ( l ) } = \mathrm { U P D A T E } ^ { ( l ) } \left( h _ { v } ^ { ( l - 1 ) } , \mathrm { A G G R E G A T E } ^ { ( l ) } \left( \left\{ h _ { u } ^ { ( l - 1 ) } \right\} \right) \right)
$$

where $h _ { v } ^ { ( l ) }$ is the feature of a node $v$ in the $l$ th layer, and h(v =xv, xv is the original feature vector of node v;

$\mathrm { A G G R E G A T E } ^ { ( l ) } ( \cdot )$ and $\mathrm { U P D A T E } ^ { ( l ) } ( \cdot )$ represent the feature aggregation function (e.g., mean, LSTM, and max pooling) and feature update function (e.g., linear-layer combination and MLP) (Ding et al. 2022), respectively; $\mathcal { \bar { N } } ( v )$ represents the one-hop neighboring node set of a node $v$ .

# Learnable Graph View Generator

Given a graph $G { = } ( \nu , \mathcal { E } , X )$ , where $\mathcal { V } { = } \{ v _ { 1 } , v _ { 2 } , { \ldots } , v _ { N } \}$ denotes a node set, E ⊆ V × V is an edge set, X ∈ RN×d represents node features, the graph view generator aims to create an augmented view without semantic labels during training. With an overview shown in Fig. 1, the graph view generator is composed of three critical components: the subgraph augmentation selector, the subgraph view generator, and the subgraph view assembler. The subgraph augmentation selector aims to select the optimal augmentation strategy for each subgraph, then the subgraph view generator generates augmented views for subgraphs, and the subgraph view assembler generates an augmented graph view by combining the augmented subgraph views.

Subgraph Augmentation Selector In studying different types of networks such as social and module graphs, it becomes crucial to extract and differentiate key information specific to each network type. To effectively implement GCL on various dataset-specific subgraphs, we utilize graph partition algorithms like the Louvain algorithm (Blondel et al. 2008), which partitions a graph into densely connected subgraphs. For a graph $G \mathrm { = } ( \nu , \mathbf { \bar { \mathcal { E } } } , \mathbf { \bar { \cal { X } } } )$ , the partition process can be formally expressed as follows: $\{ \mathbf { S _ { 1 } } , \mathbf { S _ { 2 } } , . . . , \mathbf { S _ { k } } \} { = } \mathrm { A L G O } ( G )$ , where $\bf { S _ { i } }$ represents the $i$ -th subgraph partitioned by algorithm ALGO( ). Later, an $L$ -layer GNN processes node attributes to extract embeddings, which are then aggregated to form subgraph embeddings used for selecting appropriate augmentation strategies from a pool (node drop, feature mask, edge perturbation, subgraph swap) as detailed in . The Gumbel-Softmax technique (Jang, Gu, and Poole 2017) is employed to probabilistically assign augmentation operations to these partitions, enhancing the distinctiveness of the subgraph analysis.

For each subgraph S, the selection of the augmentation strategy can be formulated as follows:

$$
\begin{array} { r l } & { p _ { \mathbf { S } } = \mathrm { F U N C } \big ( \mathrm { R E A D O U T } \left( \left\{ h _ { v } ^ { ( L ) } : v \in \mathbf { S } \right\} \right) \big ) } \\ & { f _ { \mathbf { S } } = \mathrm { G u m b e l S o f t m a x } \left( p _ { \mathbf { S } } \right) } \end{array}
$$

where $h _ { v } ^ { ( L ) }$ denotes the embedding of node $v$ . READOUT denotes a function that summarizes over all node embeddings in subgraph $S$ . FUNC is a function (e.g. MLP or a linear layer) that transforms the embedding of the subgraph to the probability distribution $p _ { \mathbf { S } }$ . This distribution represents the probabilities across all potential augmentations for each subgraph. $f _ { \mathbf { S } }$ represents the augmentation choice for subgraph S. $f _ { \mathbf { S } }$ is a differentiable one-hot vector sampled via GumbelSoftmax using the reparameterization trick.

Subgraph View Generator For each subgraph, the subgraph view generator would select an augmentation strategy based on $f _ { \mathbf { S } }$ , and generate a subgraph view for the subgraph.

In this study, we use five augmentation strategies, including three intra-subgraph strategies (node dropping, feature masking, and intra-edge perturbation) and two inter-subgraph strategies (inter-edge perturbation and subgraph swapping). The details are as follows.

(1) Node dropping is conditioned on the node representations to decide which nodes within a subgraph to drop. Given the subgraph S, the process of node dropping can be formulated as:

$$
\begin{array} { r } { p _ { v } = \mathrm { F U N C } ( h _ { v } ^ { ( L ) } ) \qquad } \\ { f _ { v } = \mathrm { G u m b e l S o f t m a x } \left( p _ { v } \right) } \\ { \tilde { X } _ { d r o p } , \tilde { \mathcal { E } } _ { d r o p } = \mathrm { A U G } _ { d r o p } ( X , \mathcal { E } , f _ { v } , f _ { \mathbf { S } } ) } \end{array}
$$

where FUNC is a function (e.g. MLP or a linear layer) that transforms the embeddings of nodes to the probability distribution $p _ { v }$ . This distribution indicates the likelihood of each node being dropped or retained. $f _ { v }$ is a one-hot vector sampled from this distribution via Gumbel-Softmax, $\operatorname { A U G } _ { d r o p } ( X , \mathcal { E } , f _ { v } , f _ { \mathbf { S } } )$ is the augmentation function that outputs the augmented node features $\tilde { X } _ { d r o p }$ and edges $\tilde { \mathcal { E } } _ { d r o p }$ . The underlying assumption is that missing part of nodes does not damage the semantic information of the graph.

(2) Feature masking is to mask the feature of nodes within a subgraph. The process is similar to node dropping augmentation. Feature masking implies that the absence of some node features does not affect the semantics.

(3) Intra-edge perturbation is conditioned on head and tail nodes to decide which edges that are within a subgraph to add or remove. It would be a heavy burden for backpropagation to predict the full adjacency matrix when dealing with large-scale graphs. To achieve efficient computation, we randomly sample negative edges within subgraphs. The underlying prior is that the semantic meaning of the graph is robust to the variance of edges.

(4) Inter-edge perturbation focuses on perturbing the edges between two subgraphs $\mathbf { S } _ { i }$ and $\mathbf { S } _ { j }$ . Similarly, we first randomly sample $| \mathcal { E } |$ negative edges between subgraphs, and the process of inter-edge perturbation can be formulated as:

$$
\begin{array} { r l r } {  { p _ { e } = \mathrm { F U N C } ( h _ { v } ^ { ( L ) } \parallel h _ { u } ^ { ( L ) } \parallel h _ { \mathbf { S } _ { i } } ^ { ( L ) } \parallel h _ { \mathbf { S } _ { j } } ^ { ( L ) } : v \in \mathbf { S } _ { i } , u \in \mathbf { S } _ { j } ) } } \\ & { } & { \quad \quad ( \mathrm { ~  ~ \lambda ~ } _ { \mathrm { ~ f ~ e ~ } } ) } \\ & { } & { \quad \quad \tilde { \mathcal { E } } _ { i n t e r } = \mathrm { G u m b e l S o f t m a x } ( p _ { e } ) } \\ & { } & { \quad \quad \tilde { \mathcal { E } } _ { i n t e r } = \mathrm { A U G } _ { i n t e r } ( \mathcal { E } \cup \tilde { \mathcal { E } } , f _ { e } , f _ { \mathbf { S } } ) } \end{array}
$$

where $h _ { { \bf S } _ { i } } ^ { ( L ) }$ is the embedding of subgraph $\mathbf { S } _ { i }$ . FUNC is a function (e.g. MLP or a linear layer) that transform the embeddings of edges to the probability distribution $p _ { e }$ . This distribution indicates the likelihood of each edge that are between the subgraph $\mathbf { S } _ { i }$ and $\mathbf { S } _ { j }$ being dropped or retained. $\parallel$ denotes the concatenation operation, $f _ { e }$ is a one-hot vector sampled from this distribution via Gumbel-Softmax, and $\operatorname { A U G } _ { i n t e r } ( \mathcal { E } \cup \tilde { \mathcal { E } } , f _ { e } , f _ { \mathbf { S } } )$ is the augmentation function that outputs the augmented edge table $\tilde { \mathcal { E } } _ { i n t e r }$ . The inter-edge perturbation differs from the intra-edge perturbation in that it takes into account the subgraph embedding when calculating the edge probability distribution, as shown in Eq. (7).

(5) Subgraph swapping is to swap the position of the subgraphs by changing the edges between subgraphs. The process of subgraph swapping can be formulated as:

$$
\tilde { \mathcal { E } } _ { s u b } = \mathrm { A U G } _ { s u b } ( \mathcal { E } , f _ { \mathbf { S } } )
$$

where $\mathrm { A U G } _ { s u b } ( \mathcal { E } , f _ { \bf S } )$ is the augmentation function that outputs the augmented edge table $\tilde { \mathcal { E } } _ { s u b }$ . It believes that most of the semantic meaning of the graph can be preserved in its local structure. The augmentation function $\mathrm { { A \bar { U } G ( \cdot ) } }$ integrates the node attribute (and adjacency matrix) with the $f _ { v }$ (and $f _ { e }$ , the one-hot vector for edges sampled via Gumbel-Softmax) using differentiable operations such as multiplication. Consequently, the gradients of the weights of the subgraph view generator are retained in the augmented node features (edges) and can be computed using back-propagation.

Subgraph View Assembler For a partitioned graph $\{ \mathbf { S } _ { 1 } , \mathbf { S } _ { 2 } , . . . , \mathbf { S } _ { k } \}$ , we denote the augmented subgraph view of $\mathbf { S } _ { i }$ as $\tilde { \bf S } _ { i } { = } ( \tilde { X } _ { { \bf S } _ { i } } , \tilde { \mathcal { E } } _ { { \bf S } _ { i } } )$ . The augmented graph view $\tilde { G } = ( \tilde { X } , \tilde { \mathcal { E } } )$ can be obtained via $\scriptstyle \tilde { X } = \operatorname { A S S E M B L E } _ { x } ( \tilde { X } _ { \mathbf { S } _ { i } } )$ and $\begin{array} { r } { \tilde { \mathcal { E } } { = } \sum _ { i = 1 } ^ { k } ( \tilde { \mathcal { E } } _ { \mathbf { S } _ { i } } ) } \end{array}$ , where $\mathrm { A S S E M B L E } _ { x }$ is a matrix computation operation. For the augmented graph, the edge table and node features both participate in the gradient computation, and the parameters of the graph view generator can be updated in a differentiable manner. Therefore, our graph view generator is end-to-end differentiable.

# Complexity Analysis

In SOLA-GCL, we use GIN as the graph embedding model, with a complexity of $O ( L { \cdot } ( E _ { \mathrm { a v g } } { \cdot } C _ { \mathrm { a g g } } { + } N _ { \mathrm { a v g } } { \cdot } C _ { \mathrm { u p d a t e } } ) )$ , where $L$ is the number of layers, $E _ { \mathrm { a v g } }$ is the average number of edges, $N _ { \mathrm { a v g } }$ is the average number of nodes, $C _ { \mathrm { a g g } }$ is the cost of aggregation, and $C _ { \mathrm { u p d a t e } }$ is the cost of updating node features. For the subgraph augmentation selector, the complexity is approximated as $O ( ( N _ { \mathrm { a v g } } + k _ { \mathrm { a v g } } ) \cdot H )$ , where $H$ is the feature dimension, and $k _ { \mathrm { a v g } }$ is the average number of subgraphs. This includes an average pooling layer, a linear layer, and a Gumbel-Softmax operation. The subgraph view generator has a complexity of $O ( H \cdot ( N _ { \mathrm { a v g } } + E _ { \mathrm { a v g } } ) )$ , involving a linear layer and a Gumbel-Softmax to generate augmented node features and edge tables. For the subgraph view assembler, the complexity is $O ( k _ { \mathrm { a v g } } \cdot N _ { \mathrm { a v g } } \cdot H + E _ { \mathrm { a v g } } )$ , where assembling node features has a complexity of $O ( \bar { k } _ { \mathrm { a v g } } \cdot N _ { \mathrm { a v g } } \cdot H )$ and assembling the edge table is $O ( E _ { \mathrm { a v g } } )$ , summing up the edges across all subgraphs.

In summary, the overall complexity of the framework is $O ( L \cdot ( E _ { \mathrm { a v g } } \cdot C _ { \mathrm { a g g } } + N _ { \mathrm { a v g } } \cdot C _ { \mathrm { u p d a t e } } ) + \dot { k } _ { \mathrm { a v g } } \cdot N _ { \mathrm { a v g } } \cdot H + E _ { \mathrm { a v g } } )$

# Graph Contrastive Learning in SOLA-GCL

In this work, we define contrastive loss $\mathcal { L } _ { \mathrm { c l } }$ , similarity loss $\mathcal { L } _ { \mathrm { s i m } }$ , and classification loss $\mathcal { L } _ { \mathrm { c l s } }$ . The contrastive loss enforces maximizing the consistency between positive pairs $z _ { i } , z _ { j }$ compared with negative pairs. The similarity loss minimizes the mutual information between the views generated by the two view generators. The classification loss is used in the semi-supervised learning task to encourage the graph view generator to generate label-preserving augmentations.

For the contrastive loss, we follow the previous works (Chen et al. 2020; You et al. 2020; Yin et al. 2022) and use the normalized temperature-scaled cross entropy loss (NT-XEnt) (Sohn 2016). The cosine similarity function is defined as sim(zi, zj)= zi i· jzj . During the training process, a data batch of $M$ graphs is randomly sampled and we pass the batch to the two graph view generators to obtain $2 M$ graph views. The two augmented views from the same input graph are regarded as the positive view pair. We denote $\ell _ { ( i , j ) }$ as the instance-level contrastive loss between a positive pair of samples $( i , j )$ , and the contrastive loss of this data batch $\mathcal { L } _ { \mathrm { c l } }$ can be formulated as:

$$
\begin{array} { l } { \ell _ { ( i , j ) } = - \log \frac { \exp ( \sin ( z _ { i } , z _ { j } ) / \tau ) } { \sum _ { k = 1 , k \neq i } ^ { 2 M } \exp ( \sin ( z _ { i } , z _ { k } ) / \tau ) } } \\ { \ell _ { \mathrm { c l } } = \frac { 1 } { 2 M } \displaystyle \sum _ { k = 1 } ^ { N } [ \ell ( 2 k - 1 , 2 k ) + \ell ( 2 k , 2 k - 1 ) ] } \end{array}
$$

where $\tau$ is the temperature parameter. The final loss is computed across all positive pairs per batch.

For the similarity loss, we simultaneously minimize the mutual information between the augmentation selections generated by the two subgraph augmentation selectors and between the views generated by the two subgraph view generators. During the view generation process, the subgraph augmentation selector outputs a sampled state matrix $S$ indicating the corresponding augmentation operation of each subgraph, and the subgraph view assembler outputs the edge table $\vec { \mathcal { E } }$ . As the augmentation process involves edge negative sampling, the length of edge table $\overline { { \mathcal { E } } }$ is not equal between the two view generators. We transform the edge table $\overline { { \mathcal { E } } }$ to adjacency matrix $A$ to compute the similarity loss between views. For a graph $G$ , we denote the sampled state matrix of each view generator as $S _ { 1 } , S _ { 2 }$ , and the adjacency matrix as $A _ { 1 } , A _ { 2 }$ . The similarity loss can be formulated as:

$$
\mathcal { L } _ { \mathrm { s i m } } = \mathrm { s i m } ( S _ { 1 } , S _ { 2 } ) + \mathrm { s i m } ( A _ { 1 } , A _ { 2 } )
$$

For the classification loss, we employ the cross entropy loss $\ell _ { c l s }$ . Give a graph sample $G$ with its corresponding class label $y$ , and its augmented views denoted as $\tilde { G } _ { 1 }$ and $\tilde { G _ { 2 } }$ , with CLS representing the classifier, the classification loss $\ell _ { c l s }$ is expressed as follows:

$$
\begin{array} { r } { \mathcal { L } _ { \mathrm { c l s } } = \ell _ { c l s } ( \mathbf { C L S } ( G ) , y ) + \ell _ { c l s } ( \mathbf { C L S } ( \tilde { G } _ { 1 } ) , y ) + \ell _ { c l s } ( \mathbf { C L S } ( \tilde { G } _ { 2 } ) , y ) } \end{array}
$$

$\mathcal { L } _ { \mathrm { c l s } }$ is utilized in the pre-training phase of the semisupervised learning task to encourage the view generator to generate label-preserving augmentations.

# Experiments

In this section, we assess the performance of SOLA-GCL on graph classification across various applications by comparing it against state-of-the-art (SOTA) methods in semi-supervised, unsupervised, and transfer learning tasks. We also explore the effectiveness of SOLA-GCL through visualizations of subgraph importance. Additionally, we conduct an ablation study to determine the impact of different components and provide analyses on running time to demonstrate its efficiency.

Table 1: Comparison with the existing methods for unsupervised learning. Bold numbers indicate the best performance, while blue numbers highlight the second best.   

<html><body><table><tr><td>Model</td><td>MUTAG</td><td>NCI1</td><td>COLLAB</td><td>IMDB-B</td><td>IMDB-M</td><td>Infections</td><td>Facebook</td><td>DBLP</td></tr><tr><td>GL</td><td>81.66±2.11</td><td></td><td></td><td>65.87±0.98</td><td></td><td></td><td></td><td></td></tr><tr><td>WL</td><td>80.72±3.00</td><td>80.01±0.50</td><td>-</td><td>72.30±3.44</td><td></td><td></td><td></td><td></td></tr><tr><td>DGK</td><td>87.44±2.72</td><td>80.31±0.46</td><td></td><td>66.96±0.56</td><td>=</td><td>=</td><td></td><td></td></tr><tr><td>node2vec</td><td>72.63±10.20</td><td>54.89±1.61</td><td>54.57±0.37</td><td>38.60±2.30</td><td></td><td></td><td>=</td><td></td></tr><tr><td>sub2vec</td><td>61.05±15.80</td><td>52.84±1.47</td><td>55.26±1.54</td><td>55.26±1.54</td><td></td><td></td><td></td><td></td></tr><tr><td>graph2vec</td><td>83.15±9.25</td><td>73.22±1.81</td><td>71.10±0.54</td><td>71.10±0.54</td><td></td><td>=</td><td>■</td><td></td></tr><tr><td>InfoGraph</td><td>89.01±1.13</td><td>76.20±1.06</td><td>70.65±1.13</td><td>73.03±0.87</td><td>49.80±1.50</td><td>53.50±1.38</td><td>52.35±1.12</td><td>50.72±1.51</td></tr><tr><td>GraphCL</td><td>86.80±1.34</td><td>77.87±0.41</td><td>71.36±1.15</td><td>71.14±0.44</td><td>49.20±1.62</td><td>50.50±1.04</td><td>49.05±0.69</td><td>48.81±1.10</td></tr><tr><td>JOAO</td><td>87.35±1.02</td><td>78.07±0.47</td><td>69.50±0.36</td><td>70.21±3.08</td><td></td><td></td><td></td><td></td></tr><tr><td>JOAOv2</td><td>87.67±0.79</td><td>72.99±0.75</td><td>70.40±2.21</td><td>71.60±0.86</td><td>48.73±1.54</td><td>47.00±2.09</td><td>48.54±1.01</td><td>50.35±1.77</td></tr><tr><td>AD-GCL</td><td></td><td>69.67±0.51</td><td>73.32±0.61</td><td>71.57±1.01</td><td>49.87±1.44</td><td>52.50±1.08</td><td>52.66±1.67</td><td>48.21±1.93</td></tr><tr><td>AutoGCL</td><td>88.64±1.08</td><td>82.00±0.29</td><td>70.12±0.68</td><td>73.30±0.40</td><td>48.47±1.88</td><td>49.00±1.43</td><td>49.83±1.50</td><td>49.40±1.74</td></tr><tr><td>SimGRACE</td><td>89.01±1.31</td><td>79.12±0.44</td><td>71.72±0.82</td><td>71.30±0.77</td><td></td><td></td><td></td><td></td></tr><tr><td>MSSGCL</td><td>89.68±0.57</td><td>81.45±0.48</td><td>73.48±0.83</td><td>73.14±0.38</td><td></td><td></td><td></td><td></td></tr><tr><td>Ours</td><td>90.49±2.22</td><td>82.07±1.32</td><td>73.80±1.32</td><td>74.20±1.89</td><td>51.27±1.05</td><td>53.50±1.92</td><td>52.97±1.42</td><td>53.25±1.90</td></tr></table></body></html>

<html><body><table><tr><td>Model</td><td>BBBP</td><td>ToxCast</td><td>SIDER</td><td>ClinTox</td><td>HIV</td><td>BACE</td></tr><tr><td>NoPretrain</td><td>65.8±4.5</td><td>63.4±0.6</td><td>57.3±1.6</td><td>58.0±4.4</td><td>75.3±1.9</td><td>70.1±5.4</td></tr><tr><td>Infomax</td><td>68.8±0.8</td><td>62.7±0.4</td><td>58.4±0.8</td><td>69.9±3.0</td><td>76.0±0.7</td><td>75.9±1.6</td></tr><tr><td>EdgePred</td><td>67.3±2.4</td><td>64.1±0.6</td><td>60.4±0.7</td><td>64.1±3.7</td><td>76.3±1.0</td><td>79.9±0.9</td></tr><tr><td>AttrMasking</td><td>64.3±2.8</td><td>64.2±0.5</td><td>61.0±0.7</td><td>71.8±4.1</td><td>77.2±1.1</td><td>79.3±1.6</td></tr><tr><td>ContextPred</td><td>68.0±2.0</td><td>63.9±0.6</td><td>60.9±0.6</td><td>65.9±3.8</td><td>77.3±1.0</td><td>79.6±1.2</td></tr><tr><td>GraphCL</td><td>69.68±0.67</td><td>62.40±0.57</td><td>60.53±0.88</td><td>75.99±2.65</td><td>78.47±1.22</td><td>75.38±1.44</td></tr><tr><td>JOAOv2</td><td>71.39±0.92</td><td>63.16±0.45</td><td>60.49±0.74</td><td>80.97±1.64</td><td>77.51±1.17</td><td>75.49±1.27</td></tr><tr><td>AD-GCL</td><td>70.01±1.07</td><td>63.07±0.72</td><td>63.28±0.79</td><td>79.78±3.52</td><td>78.28±0.97</td><td>78.51±0.80</td></tr><tr><td>AutoGCL</td><td>73.36±0.77</td><td>63.47±0.38</td><td>62.51±0.63</td><td>80.99±3.38</td><td>78.35±0.64</td><td>83.26±1.13</td></tr><tr><td>Ours</td><td>74.08±0.82</td><td>64.50±0.41</td><td>62.79±0.91</td><td>81.49±1.31</td><td>78.68±1.01</td><td>82.64±1.01</td></tr></table></body></html>

Table 2: Comparison with the existing methods for transfer learning.

# Experimental Settings

We compare SOLA-GCL with the SOTA methods on 16 datasets under unsupervised, semi-supervised and transfer learning settings. The baseline models are as follows: (1) three SOTA kernel-based methods: graphlet kernel (GL) (Shervashidze et al. 2009), Weisfeiler-Lehman subtree kernel (WL) (Shervashidze et al. 2011), and deep graph kernel (DGK) (Yanardag and Vishwanathan 2015); (2) six unsupervised graph-level representation learning methods: node2vec (Grover and Leskovec 2016), sub2vec (Adhikari et al. 2018), graph2vec (Narayanan et al. 2017), EdgePred (Hu et al. 2020), AttrMasking (Hu et al. 2020), and ContextPred (Hu et al. 2020); (3) six classic GCL methods that randomly generate graph views: InfoGraph (Sun et al. 2020), Infomax (Velickovic et al. 2019), GCA (Zhu et al. 2021b), GraphCL (You et al. 2020), JOAO (You et al. 2021), and JOAOv2 (You et al. 2021); (4) four learning-based GCL method: AD-GCL (Suresh et al. 2021), AutoGCL (Yin et al. 2022), SimGRACE (Xia et al. 2022), and MSSGCL (Liu et al. 2023).

# Performance Comparison

Unsupervised Representation Learning. As shown in Table 1, several observations can be made: (1) The consistent top performance across diverse datasets suggests that our method is not only versatile but also highly effective in extracting meaningful patterns from complex graph structures, surpassing both traditional graph learning methods and SOTA deep learning approaches. (2) Traditional methods like WL and DGK focus on graph kernels and rely on explicit feature engineering. They lack the adaptability of deep learning models, which can automatically extract features through training. (3) Deep learning methods like AD-GCL and AutoGCL show varying performance across datasets, illustrating the nuanced capabilities and limitations of these approaches. (4) MSSGCL can potentially capture nuanced relationships within the graph data by focusing on subgraph and graph features. In contrast, our approach leverages a wider spectrum of subgraph interactions, not merely focusing on local versus global relationships but also extensively exploring the intricate relationships within and between subgraphs. The superior performance across various datasets demonstrate the effectiveness of our SOLA-GCL.

Transfer Learning. According to results shown in Table 2, three observations can be made: (1) Our model consistently achieves SOTA or second-best performance across all evaluated datasets, demonstrating its robustness and effectiveness under the transfer learning setting. (2) In the SIDER and BACE datasets, our model trails behind AD-GCL and AutoGCL, likely due to their more effective handling of sparse and imbalanced data typical in side effect prediction and biochemical field. (3) AD-GCL and AutoGCL often outperform other models like GraphCL and JOAO due to their advanced strategies in a learnable manner. In contrast, GraphCL and JOAO typically employ more generalized augmentation and optimization strategies, which may not effectively capture the nuanced details of the data during large-scale pre-training.

Semi-Supervised Learning. For semi-supervised learning, we perform the semi-supervised graph classification exper

Table 3: Comparison with existing methods and different strategies for semi-supervised learning.   

<html><body><table><tr><td>Model</td><td>PROTEINS</td><td>DD</td><td>NCI1</td><td>COLLAB</td></tr><tr><td>FullData</td><td>78.25±1.61</td><td>80.73±3.78</td><td>83.65±1.16</td><td>83.44±0.77</td></tr><tr><td>10%Data</td><td>69.72±6.71</td><td>74.36±5.86</td><td>75.16±2.07</td><td>74.34±2.00</td></tr><tr><td>10% GAE</td><td>70.51±0.17</td><td>74.54±0.68</td><td>74.36±0.24</td><td>75.09±0.19</td></tr><tr><td>10% Infomax</td><td>72.27±0.40</td><td>75.78±0.34</td><td>74.86±0.26</td><td>73.76±0.29</td></tr><tr><td>10% ContextPred</td><td>70.23±0.63</td><td>74.66±0.51</td><td>73.00±0.30</td><td>73.69±0.37</td></tr><tr><td>10% GCA</td><td>73.85±5.56</td><td>76.74±4.09</td><td>68.73±2.36</td><td>74.32±2.30</td></tr><tr><td>10% GraphCL</td><td>74.21±4.50</td><td>76.65±5.12</td><td>73.16±2.90</td><td>75.50±2.15</td></tr><tr><td>10% JOAO</td><td>72.13±0.92</td><td>75.69±0.67</td><td>74.48±0.27</td><td>75.30±0.32</td></tr><tr><td>10% JOAOv2</td><td>73.31±0.48</td><td>75.81±0.73</td><td>74.86±0.39</td><td>75.53±0.18</td></tr><tr><td>10% AD-GCL</td><td>73.96±0.47</td><td>77.91±0.73</td><td>75.18±0.31</td><td>75.82±0.26</td></tr><tr><td>10% AutoGCL</td><td>75.65±2.40</td><td>77.50±4.41</td><td>73.75±2.25</td><td>77.16±1.48</td></tr><tr><td>10% SimGRACE</td><td>74.03±0.51</td><td>76.48±0.52</td><td>74.60±0.41</td><td>74.74±0.28</td></tr><tr><td>10% MSSGCL</td><td>75.76±0.52</td><td>78.89±0.18</td><td>74.77±0.31</td><td>76.02±0.13</td></tr><tr><td>10% Ours</td><td>77.63±3.10</td><td>79.43±4.31</td><td>74.94±1.96</td><td>76.97±1.31</td></tr></table></body></html>

<html><body><table><tr><td></td><td>MUTAG</td><td>NCI1</td><td>COLLAB</td><td>IMDB-B</td></tr><tr><td>Louvain</td><td>90.49±2.22</td><td>82.07±1.32</td><td>73.80±1.32</td><td>74.20±1.89</td></tr><tr><td>GN</td><td>89.88±2.98</td><td>81.56±2.11</td><td>72.32±1.88</td><td>74.10±2.84</td></tr><tr><td>SOLA-GCL-P</td><td>88.33±2.04</td><td>79.93±1.74</td><td>70.92±1.91</td><td>71.70±2.80</td></tr><tr><td>SOLA-GCL-S</td><td>88.80±3.46</td><td>81.58±1.57</td><td>71.86±1.63</td><td>74.00±2.63</td></tr><tr><td>SOLA-GCL-R</td><td>88.80±3.24</td><td>80.95±1.75</td><td>69.38±1.96</td><td>73.70±2.84</td></tr></table></body></html>

Table 4: Ablation study on the critical modules.

iments on TUDataset (Morris et al. 2020). As shown in Table 3, two observations can be made: (1) Our SOLA-GCL consistently achieves SOTA or comparative performance compared to other models due to its effective use of subgraphspecific information, enhancing learning from limited labeled data across various datasets. (2) MSSGCL ranks second on PROTEINS and DD because of its effective multi-scale subgraph sampling strategy. However, it falls short of SOLAGCL which better captures and utilizes subgraph interactions.

# Visualization

To validate the effectiveness of our SOLA-GCL framework (Fig.2), we trained a view generator on the MUTAG dataset(Debnath et al. 1991; Kriege and Mutzel 2012), a realworld chemical dataset. We evaluate SOLA-GCL’s ability to identify important subgraphs, such as carbon rings and $\mathrm { N O } _ { 2 }$ groups, known to be mutagenic (Debnath et al. 1991). The visualization results explain the capability of SOLA-GCL as it has successfully identified the carbon rings and $\mathrm { N O } _ { 2 }$ groups as critical subgraphs. The results emphasize the importance of capturing subgraph features and relationships among subgraphs, and prove the effectiveness of our SOLA-GCL.

# Ablation Study

The proposed method first partitions the graph into a set of subgraphs, and then jointly trains the subgraph augmentation selector and the subgraph view generator to generate graph views. In this subsection, we present an ablation study on the unsupervised learning task to evaluate the contribution of the three components as shown in Table 4. We use "P" as a suffix of the model name (SOLA-GCL-P) to denote the model without a subgraph partition module, a suffix "S" (SOLA-GCL-S) to denote the model with a random selector for subgraph augmentation strategy rather than a learnable one, and a suffix "R" (SOLA-GCL-R) to denote the model with a random

Ring structure NO2 group   
Ground Truth High Low   
Original Importance Original Importance Subgraph Visualization Visualization importance

![](images/e30572d192d9aa489e7f0cdb0cf7c7142bf061feda896b375e62be321ed82492.jpg)  
Figure 2: We visualize the graphs in the MUTAG dataset, the deeper color indicates the more important subgraphs and the ground truth is ring structure and $\mathrm { N O } _ { 2 }$ group.   
Figure 3: Comparisons in terms of real running time. Each model is trained for 100 epochs on each dataset and the average training time of one epoch is reported.

subgraph view generator (e.g., random node dropping in one subgraph) rather than a learnable one. For variations of the subgraph partitioning algorithm, we evaluate SOLA-GCL using the Louvain algorithm and Girvan-Newman (GN) algorithm respectively, and provide the average subgraph number of a partitioned graph in each dataset. The results indicate that the SOLA-GCL framework performs well across different subgraph partitioning algorithms, highlighting its effectiveness and robustness. Furthermore, the extensive experiments across several datasets demonstrate the robustness and adaptability of SOLA-GCL, indicating its performance is resilient to variations in the partitioned subgraph sizes.

# Efficiency Analysis

As shown in Fig. 3, we present the comparisons on training time consumption for each epoch in the training process. While GraphCL and AutoGCL show the lowest training time consumption, SOLA-GCL strikes an optimal balance between efficiency and effectiveness. It achieves better performance than JOAO and JOAOv2 and consumes less training time, demonstrating a significant advantage in both performance and efficiency.

# Conclusion

We present SOLA-GCL, a novel data augmentation method for graph contrastive learning. In contrast to existing methods that overlook the importance of the critical role of subgraph structures, SOLA-GCL takes a comprehensive approach by considering the information of intra-subgraph characteristics and inter-subgraph relationships. This is achieved through the joint training of a subgraph augmentation selector and a subgraph view generator, enabling the generation of learnable graph views. It consistently outperforms existing methods across various datasets, highlighting its effectiveness.