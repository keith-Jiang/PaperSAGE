# An LLM-Empowered Adaptive Evolutionary Algorithm For Multi-Component Deep Learning Systems

Haoxiang Tian1,2\*, Xingshuo Han†3, Guoquan $\mathbf { W } \mathbf { u } ^ { \dag 1 , 4 }$ , An Guo5, Yuan Zhou6, Jie Zhang7, Shuo $\mathbf { L i } ^ { 1 }$ Jun Wei1,4, Tianwei Zhang2

1Key Lab of System Software at $\mathrm { C A S ^ { \ddagger } }$ , State Key Lab of Computer Science at ISCAS§, University of CAS, Beijing 2 Nanyang Technological University, Singapore 3 Continental-NTU Corporate Lab, Singapore 4Nanjing Institute of Software Technology, University of CAS, Nanjing 5Nanjing University, Nanjing 6Zhejiang Sci-Tech University, Hangzhou 7CFAR and IHPC, $\mathbf { A } ^ { * } \mathbf { S } \mathbf { T } \mathbf { A } \mathbf { R }$ , Singapore   
{tianhaoxiang20, gqwu, lishuo19, wj} $@$ otcaix.iscas.ac.cn, xingshuo001@e.ntu.edu.sg, guoan218@smail.nju.edu.cn, yuanzhou $@$ zstu.edu.cn, zhang jie@cfar.a-star.edu.sg, tianwei.zhang $@$ ntu.edu.sg

# Abstract

Multi-objective evolutionary algorithms (MOEAs) are widely used for searching optimal solutions in complex multicomponent applications. Traditional MOEAs for multicomponent deep learning (MCDL) systems face challenges in enhancing the search efficiency while maintaining the diversity. To combat these, this paper proposes the first LLMempowered adaptive evolutionary search algorithm to detect safety violations in MCDL systems. Inspired by the contextunderstanding ability of Large Language Models (LLMs), our approach promotes the LLM to comprehend the optimization problem and generate an initial population tailed to evolutionary objectives. Subsequently, it employs adaptive selection and variation to iteratively produce offspring, balancing the evolutionary efficiency and diversity. During the evolutionary process, to navigate away from the local optima, our approach integrates the evolutionary experience back into the LLM. This utilization harnesses the LLM’s quantitative reasoning prowess to generate differential seeds, breaking away from current optimal solutions. We evaluate our approach in finding safety violations of MCDL systems, and compare its performance with state-of-the-art MOEA methods. Experimental results show that our approach can significantly improve the efficiency and diversity of the evolutionary search.

# Introduction

Multi-component deep learning systems (MCDL systems) are intricate and characterized by significant uncertainty due to their complexity. These systems often involve multiple interacting modules, each with its own set of parameters and behaviors, leading to unpredictable emergent properties. In real-world scenarios, MCDL systems are increasingly being deployed in domains with substantial societal impact, such as autonomous vehicles, healthcare, and financial services. For instance, autonomous driving systems integrate various components (e.g., object detection, path planning, and decision-making), where even minor faults in one component can lead to catastrophic outcomes (Bojarski et al. 2016). Therefore, it is crucial to detect as many safety violations as possible in these systems to mitigate risks and ensure reliability (Goodfellow et al. 2017).

Multi-objective evolutionary algorithms (MOEAs) are widely applied to search for elite solutions to find safety violations in MCDL systems (Tian et al. 2022a; Abdukhamidov et al. 2023b,a). They can be formulated as multi-objective optimization problems (Zhou et al. 2011). In practical evolutionary search solutions based on genetic algorithms, these multiple objectives correspond to various perspectives (e.g., maximize the quality of the solution, improve the diversity of solutions, balance the cost of solutions against benefits) (Ehrgott, Ide, and Scho¨bel 2014; Long 2014). However, there are trade-offs between these objectives as they conflicts with each other in many real-world scenarios.

The evolutionary search process generally consists of three steps: 1) initializing the initial population, 2) evaluating each generated individual with a defined fitness function, and 3) selecting high-fitness individuals to conduct variation operators to generate offspring iteratively. However, existing MOEAs for detecting safety violations in MCDL systems (Tian et al. 2022a) face two challenges that have not been well addressed.

• Challenge-1: The initialization of the population highly affects the search efficiency for elitist solutions. However, in many MOEAs, the initial population is created by random initialization of parameters in the entire search space, which is highly contingent and uncertain. • Challenge-2: The evolutionary search process is prone to get stuck at local optima. In existing MOEAs, the individuals of each generation are generated by the highfitness individuals retained from previous generations, which tend to cause convergence prematurely and result in a large number of iterations that only find few similar safety violations of the MCDL systems.

The goal of this paper is to overcome the above challenges and improve the evolutionary search efficiency and diversity. Large Language Models (LLMs), such as GPT-4 from OpenAI (Roumeliotis and Tselikas 2023)), have demonstrated remarkable abilities in language understanding and quantitative reasoning (Romera-Paredes et al. 2024; Zhang et al. 2022). So we propose to leverage these capabilities to generate the initial population and navigate the evolutionary search process away from the local optima. However, despite the LLMs’ expertise in interacting with humans, it is infeasible to directly apply them to search for optimal and diverse solutions for detecting safety violations of MCDL systems. This is because MCDL systems normally have high dimensionality and complexity, making it difficult for LLMs to fully and accurately understand the search space. Additionally, since LLMs may not have enough specific domain knowledge about the MCDL systems, they will arbitrarily modify existing solutions and make up unreasonable solutions, rendering them less effective.

We design $\mu \mathrm { M O E A }$ , the first LLM-empowered adaptive evolutionary methodology. $\mu \mathrm { M O E A }$ uses LLM’s ability in language understanding to better comprehend the search task, which creates the individuals of the initial population considering the objectives instead of random initialization, thus addressing C1. Based on the initial population, to balance the search efficiency and diversity, $\mu \mathrm { M O E A }$ introduces adaptive selection and a suite of adaptive variations, which can dynamically adjust the mutation and crossover probabilities based on the feedback from the search process and the scores of chromosomes of individuals on different objectives. During the search process, when it gets stuck, $\mu \mathrm { M O E A }$ feeds back the evolutionary experience into the LLM, harnessing its quantitative reasoning ability to generate differential seeds to break out of local optimal solutions, thus addressing C2. We evaluate the effectiveness of $\mu \mathrm { M O E A }$ in the task of searching for solutions to detect safety violations in MCDL systems (represented by the industrial autonomous driving system), and compare it with the state-ofthe-art (SOTA) method based on multi-objective genetic algorithm (NSGA-II). Experimental results show that $\mu \mathrm { M O E A }$ can find more diverse elitist solutions more efficiently.

# Background Multi-Component Deep Learning Systems

MCDL systems are characterized by their intricate internal logic, extensive interactions, and high coupling among various components (Amodei et al. 2016; Varshney 2016). Their complexity and opaqueness are further exacerbated by the substantial uncertainty, high degree of interdependence, and unpredictable nature of interactions across different deep learning models within the systems. Thus an MCDL system is often referred to as a “black box” (Hassija et al. 2024), making it challenging to thoroughly detect potential safety issues under varying conditions. It is necessary and urgent to have effective methods for the examination and detection of the internal problems in MCDL systems, without requiring a detailed understanding of the intricate workings.

A proven strategy to detect safety violations in MCDL systems is to generate solutions that simulate the diverse operational conditions and assess the system’s behaviors (including responses, decisions, operations/actions) (Tian et al. 2022b) to validate whether it adheres to the safety specifications (Borg et al. 2018; Guo et al. 2024). Ensuring the safety and reliability of MCDL systems requires diverse solutions to detect various potential vulnerabilities and failures of MCDL systems in a wide range of conditions (Asharf et al. 2020; Tian et al. 2022a). However, given the large state space of MCDL systems, traditional methods struggle to cover more possible cases efficiently. Thus, there is a growing need for more adaptive and comprehensive approaches to safety assessment of MCDL systems.

# MOEAs For MCDL Systems

MOEAs, represented by NSGA-II (Deb et al. 2002), are widely used in detecting safety violations in MCDL systems. They are capable of exploring the vast and complex space of system behaviors and identify any misbehaviors (Mishra et al. 2019). This is achieved with evolving and optimizing solutions to cover possible situations (Wirsansky 2020) where the system behaviors violate the safety specifications.

The overall process of an MOEA (e.g., NSGA-II) is given as follows.

• Initial population: NSGA-II commences by initializing a population of $N$ solutions, which is randomly generated within the solution space.   
• Fitness function: given a solution space $S$ and objective functions $f _ { 1 } , f _ { 2 } , . . . , f _ { m }$ , the multiobjective optimization can be formulated as: $\bar { m a } x _ { x \in S } \{ f _ { 1 } ( \bar { x } ) , f _ { 2 } ( x ) , . . . , f _ { m } ( x ) \}$ . To detect the safety violations in MCDL systems, the multiple objectives commonly include maximizing the fault detection and solution diversity.   
• Ranking-based selection: in the $i$ -th generation, the solutions are evaluated by the fitness function and sorted by the crowding distance. $P _ { i }$ consists of the non-dominated solutions obtained by each Pareto frontier. NSGA-II selects $k$ solutions from $P _ { i }$ .   
• Variation: NSGA-II calculates the crossover probability and mutation probability for each selected solution, and compares the probability with the threshold of variation to determine whether to conduct multi-point crossover or value mutation on it. The probability of variation is calculated by a random value in $( 0 , 1 )$ and the threshold is pre-defined by a fixed value in $( 0 , 1 )$ .   
• Iterative generations: after generating $N$ offspring solutions, the next generation’s population is determined by selecting the best $N$ solutions from the current population $P _ { i }$ and the offspring population $P _ { i + 1 }$ . NSGA-II iter

atively searches and refines candidate solutions based on their performance against these defined objectives.

# Methodology

Algorithm 1: LLM-empowered adaptive evolutionary search   

<html><body><table><tr><td></td><td>Ensure:The solution set SCR</td></tr><tr><td></td><td>Require:The form of solution AE,starting prompt pt</td></tr><tr><td></td><td>1: P ←0,P ←PULLM-generate(AE,pt)</td></tr><tr><td></td><td>2:while not TerminationCondition( do</td></tr><tr><td>3:</td><td>TS,SC,MS←0</td></tr><tr><td>4:</td><td>for pi ∈P[-1] do</td></tr><tr><td>5:</td><td>execute pi</td></tr><tr><td>6:</td><td>if  ego safety violation in pi then</td></tr><tr><td>7:</td><td>SCR ← SCRUpi</td></tr><tr><td>8:</td><td>calculate fitness S</td></tr><tr><td>9:</td><td>TS ←TSUS</td></tr><tr><td>10:</td><td>SC,MS ← ADAPTIVE SELECTION(P, S)</td></tr><tr><td>11:</td><td>P ←PUADAPTIVE VARIATION(SC,MS)</td></tr><tr><td>12:</td><td>prompt= pt + generate_feedback(P, S)</td></tr><tr><td>13:</td><td>P ←PULLM_generate(prompt)</td></tr><tr><td>14:return SCR</td><td></td></tr><tr><td></td><td>15:procedure ADAPTIVE SELECTION(P, S)</td></tr><tr><td>16:</td><td>SC,MS←の</td></tr><tr><td>17:</td><td>CRr,MRr = calculate_variation_rate(S)</td></tr><tr><td>18:</td><td>for Pi,Pj ∈P do</td></tr><tr><td>19:</td><td>select fitness Si,Sj ∈S</td></tr><tr><td>20:</td><td>Ci,j= generate_crossover_probability(si,sj,S)</td></tr><tr><td>21:</td><td>if ci,j>CRr then</td></tr><tr><td>22:</td><td>SC ← SCU(pi,Pj)</td></tr><tr><td>23:</td><td>for pi ∈Pdo</td></tr><tr><td>24:</td><td>mi= generate_mutation_probability(si,S)</td></tr><tr><td>25:</td><td>if mi>MRr then</td></tr><tr><td>26:</td><td>MS ←MSUpi</td></tr><tr><td>27:</td><td>return SC,MR</td></tr><tr><td></td><td>28:proCedure ADAPTIVE VARIATION(SC,MS)</td></tr><tr><td>29:</td><td>for xi ∈ SC do</td></tr><tr><td>30:</td><td>p',p'←adaptive_crossover(xi)</td></tr><tr><td>31:</td><td>PN←PNU{pu,pj}</td></tr><tr><td>32:</td><td>for pi∈MSdo</td></tr><tr><td>33:</td><td>p'←adaptive_mutation(pi)</td></tr><tr><td>34:</td><td>PN←PNUp'</td></tr><tr><td>35:</td><td>return PN</td></tr></table></body></html>

We introduce $\mu \mathrm { M O E A }$ , a novel LLM-empowered adaptive evolutionary search algorithm for MCDL systems. The detailed process of $\mu \mathrm { M O E A }$ is illustrated in Algorithm 1 and Figure 1. It consists of three steps: instructing the LLM to create the initial population (line 2), evolving the population adaptively to search for optimal solutions (line 3-12), guiding the LLM to generate differential seeds based on the feedback of the evolutionary process (line 13-14). Below we give detailed explanation of each step.

# Instructing LLM to Create Initial Population

When starting an evolutionary search, instead of randomly initializing $N$ solutions as the initial population, $\mu \mathrm { M O E A }$ makes the LLM understand the evolutionary task and create the initial population by considering the objectives of the search. This is achieved with the linguistic prompt. An example of the prompt patterns are shown in Table 1, which are designed from the following aspects:

![](images/da4fd179ecf8e4a6174e8d84c1d53f858aa37e9363cc5fecf04ac78a26c73616.jpg)  
Figure 1: Overall workflow of $\mu \mathrm { M O E A }$

• The structure of the solution, including essential blocks of the test case, the participant or element that each block represents. This promotes the LLM to understand the correct representation of solutions.   
• The keyword/statement, essential attributes and their value ranges of each block. This promotes the LLM to reason within the feasible ranges.   
• The examples of feasible solutions and their explanations of the requirements. This promotes the LLM to learn the test requirements.

These components of the prompt pattern enable $\mu \mathrm { M O E A }$ to facilitate the LLM to understand the requirement and learn how to generate individuals for the initial population. This also addresses the limitation of the LLM that struggles with high-dimensional search spaces.

Table 1: Prompt patterns for LLM-based initial population   

<html><body><table><tr><td>Prompt</td><td>Sample of linguistic patterns</td></tr><tr><td>Starting Prompt</td><td>You are ayou pertof /< MCN> solutim>s for the system</td></tr><tr><td>TaskUnder- -standing Prompt</td><td><The formof the solution> <Introduction of parameters of solution> <Introduction of the elitism of solution></td></tr></table></body></html>

$\mu \mathrm { M O E A }$ sends the starting prompt along with the task understanding prompt into the LLM, to obtain the initial population. Taking the autonomous driving system as an example, a template of “introduction of the elitism of solution” is given as follows: the trajectories of NPC vehicles and pedestrians are required to disturb the ego vehicle’s driving path. They need to be different from each other, and the waypoints of them need to involve different lanes.

# Evolving Population Adaptively for Optimal Solutions

Based on the initial population, $\mu \mathrm { M O E A }$ adaptively evolves them to search for diverse optimal solutions to detect safety violations in the MCDL system. Each solution is encoded as an individual $P _ { i } = \{ C _ { 1 } , \stackrel { \cdot } { C } _ { 2 } , . . . C _ { n } \}$ , where $C _ { n }$ represents the $n$ -th chromosome consisting of a series of genes (a chromosome commonly corresponds to an element or object in the solution, and a gene corresponds to an action or operation). Different from existing MOEAs where the parent individuals and their chromosomes undergo the same level of mutation and crossover, $\mu \mathrm { M O E A }$ adopts adaptive selection and adaptive variations, to improve the heritability of the elite features and search efficiency.

(1) For each generation, $\mu \mathrm { M O E A }$ builds improved Paretooptimal solutions considering multiple objectives to measure the potential of solutions to expose safety violations of the MCDL system. The criticality metric is used to evaluate how close the tested MCDL system’s behavior is to safety violations. The multi-objectives of $\mu \mathrm { M O E A }$ include criticality and diversity. Practically, criticality is formulated as:

$$
f _ { c } ^ { s _ { i } } = \operatorname* { m i n } _ { t \in s _ { i } } \{ S V _ { M C D L } ^ { t } \}
$$

where $S V$ is the distance to safety violations. The diversity metric is used to evaluate the coverage of the test cases generated by previous generations. Practically, diversity is formulated as:

$$
E D _ { s _ { i } , s _ { j } } = \frac { \sum _ { n = 1 } ^ { | s _ { i } | } \sum _ { m = 1 } ^ { | s _ { j } | } T D _ { s _ { i } ^ { n } , s _ { j } ^ { m } } } { | s _ { i } | * | s _ { j } | }
$$

$$
T D _ { s _ { i } ^ { n } , s _ { j } ^ { m } } = \sum _ { k = 0 } ^ { \alpha } \sqrt { ( x _ { s _ { i } ^ { n } . k } - x _ { s _ { j } ^ { m } . k } ) ^ { 2 } + ( y _ { s _ { i } ^ { n } . k } - y _ { s _ { j } ^ { m } . k } ) ^ { 2 } }
$$

The fitness function is represented as:

$$
S \gets a r g _ { i \in G } \left\{ m i n f _ { c } ( i ) , m a x f _ { d } ( i ) \right\}
$$

where $\mathbf { G }$ represents the current generation; $f _ { c }$ is the metric that evaluates how close the tested MCDL system’s behavior is to safety violations; $f _ { d }$ is the metric that evaluates the coverage of test cases generated by previous generations.

(2) Based on (1), $\mu \mathrm { M O E A }$ performs adaptive selection, which selects high-fitness solutions based on the fitness evaluated by the multiple objectives as parents for variation to generate offspring, iteratively producing Pareto-optimal solutions. To determine the solutions for crossover and mutation, $\mu \mathrm { M O E A }$ varies the probabilities of crossover and mutation adaptively in response to the fitness values of the current population, which promotes high-fitness solutions having larger crossover probabilities and low-fitness solutions having larger mutation probabilities.

(3) For the selected individuals, $\mu \mathrm { M O E A }$ performs adaptive variation: which includes adaptive crossover and adaptive mutation. It dynamically selects different types of variation operations based on the ranking of chromosomes’ scores in the population on each objective, which makes elite chromosomes better spread their features into the offspring with more different chromosomes, and makes inferior chromosomes more disrupted. Below we give detailed description of these two steps.

Adaptive Selection. For the current population and its parents, $\mu \mathrm { M O E A }$ adaptively determines the candidate solutions to conduct crossover and mutation according to their fitness values and fitness level of the population. For the solution $s _ { i }$ with fitness $f _ { i }$ in the population $p _ { n }$ , $f _ { m a x }$ and $f _ { m i n }$ represent the maximal and minimal fitness values in $p _ { n }$ respectively. For each population $p _ { n }$ , $\mu \mathrm { M O E A }$ calculates the average values of fitness, represented as $\overline { { f } }$ . The mutation probability of $s _ { i }$ is $P M _ { i }$ . For the two solutions $s _ { i }$ and $s _ { j }$ , their crossover probability is represented as $P C _ { i , j }$ , and $f _ { i , j } ^ { ' }$ is the larger of the fitness values.

For the selection of solutions for crossover, the higher the fitness value of one solution, the larger the probability of crossover between it and the other candidate solution. For $s _ { i }$ and $s _ { j }$ , The closer $f _ { i , j . } ^ { ' }$ is to $f _ { m a x }$ , the larger the $P C _ { i , j }$ is. The crossover probability of $s _ { i }$ and $s _ { j }$ is computed as follows, where $0 < k _ { 2 } , k _ { 4 } \le 1$ . If $P M _ { i } \geq t h r e s h o l d _ { m } ^ { n }$ , $\mu \mathrm { M O E A }$ will conduct adaptive mutation on it.

$$
P M _ { i } = \operatorname* { m i n } \{ k _ { 2 } ( f _ { m a x } - f _ { i } ) / ( f _ { m a x } - \overline { { f } } ) , k _ { 4 } \}
$$

For the selection of solutions for mutation, the smaller the fitness value of the solution, the higher the probability of mutating its parameters. For $s _ { i }$ , the closer $f _ { i }$ is to $f _ { m i n }$ , the larger $P M _ { i }$ is. The mutation probability of $s _ { i }$ is computed as follows, where $0 < k _ { 2 } , k _ { 4 } \leq 1 .$ . If $P M _ { i } \geq t h r e s h o l d _ { m } ^ { n }$ , $\mu \mathrm { M O E A }$ conduct adaptive mutation on it.

$$
P M _ { i } = \operatorname* { m i n } \{ k _ { 2 } ( f _ { m a x } - f _ { i } ) / ( f _ { m a x } - \overline { { f } } ) , k _ { 4 } \} ,
$$

To disrupt the solutions with above-average fitness values to search the spaces for the region with global optimum, and ensure that all solutions with subaverage fitness values compulsorily undergo mutation, we use a value of 0.6 for $k _ { 1 }$ and $k _ { 2 }$ , and 1.0 for $k _ { 3 }$ and $k _ { 4 }$ . These values can be changed according to the actual needs.

Since the threshold of variation $( t h r e s h o l d _ { n } )$ has great effects on the overall variation of the population $p _ { n }$ , different from the MOEAs that pre-define a fixed value for the threshold, $\mu \mathrm { M O E A }$ computes threshol $d _ { n }$ for each population $p _ { n }$ adaptively based on the population’s overall level of fitness values. When the fitness values of the solutions in $p _ { n }$ converge, $\mu \mathrm { M O E A }$ decreases the threshol $d _ { n }$ to facilitate the crossover and mutation to create more different offspring. Similarly, if the fitness values of the population scatter, $\mu \mathrm { M O E A }$ increases the threshol $d _ { n }$ to accelerate the convergency to find an optimal solution. The calculation of threshol $d _ { n }$ is given as follows, where $0 < c _ { 1 } , m _ { 1 } \leq 1$ .

$$
t h r e s h o l d _ { n } = c _ { 1 } ( f _ { m a x } - \overline { { { f } } } ) + m _ { 1 } ( \overline { { { f } } } - f _ { m i n } )
$$

Adaptive Variation. This includes adaptive crossover and adaptive mutation. The variation strategy has a higher probability that the generated offspring can integrate the advantages of parents in convergence and diversity.

For adaptive crossover, given two candidate solutions of crossover, based on the objective that the solution ranks highest in the population, the chromosome with the highest value on the objective is selected for crossover using the single-point crossover with a random chromosome in the other candidate solution.

For adaptive mutation, given the candidate solution of mutation, different types of mutation operations are dynamically determined based on the fitness values of chromosomes in the solution. If the chromosome has a high score on any objective in the population, $\mu \mathrm { M O E A }$ adjusts its parameters slightly (e.g., modifying the parameters of some genes on it) to better explore the surrounding space. Otherwise, $\mu \mathrm { M O E A }$ makes major changes to it, e.g., changing the combinations or sequences of genes on it, adding new actions/operations into it, replacing some genes with new actions/operations.

Table 2: Rules for feedback prompt generation   

<html><body><table><tr><td>Rule</td><td>Sample of feedback prompt</td></tr><tr><td>1</td><td>Each solution in <SE>exposed a safety violation of <MCDL system>.So they are what we want. No safety violation occurred in <SN>,which are not required by us.We want you to generate <N>solutions that can expose safety violations and differentiate from <SE></td></tr><tr><td>2</td><td>The solutions in <R>are not different enough from <SE>.Please re-generate to create new solutions that have high potential to expose safety violations of <MCDL system>.</td></tr></table></body></html>

# Guiding LLM to Generate Differential Seeds

For the generated solutions, $\mu \mathrm { M O E A }$ runs them to detect the safety violations in the MCDL system. During the adaptive evolutionary search, we find that as the iterations increase, the evolutionary search is prone to falling into local optimality, causing the newly generated solutions similar to those optimal solutions generated by previous generations. To solve the issue, when the evolutionary search gets stuck, $\mu \mathrm { M O E A }$ generates differential seed solutions for the next generation, which encourages the exploration of more diverse solutions.

Specifically, when the high-fitness solutions in $t$ consecutive generations remain the same, $\mu \mathrm { M O E A }$ selects the optimal solutions generated by the previous iterations (collecting their chromosomes in $S E$ ), and generates the feedback prompt using Rule 1 in Table 2 (where $S N$ represents the chromosomes of non-optimal solutions). The prompt pattern of Rule 1 is to promote the LLM to learn the characteristics of previous evolutionary iterations, and then create differential seed solutions leveraging its reasoning capability.

Considering that the LLM is typically accustomed to generating outputs that resemble the examples provided in the input, $\mu \mathrm { M O E A }$ examines the differences between the LLM’s generated solutions to the input solutions. For the solution $s _ { i }$ , its difference from the input solutions is calculated as: $\begin{array} { r } { d _ { i } \ = \ ( \sum _ { x _ { o } \in ( S N \cup S E ) } E { \overbar { D _ { s _ { i } , x _ { o } } } } ) / r } \end{array}$ , where $E D$ represents the Euclidean Distances between two solutions. For the LLM’s generated solutions that do not meet the difference requirements with the previous solutions, $\mu \mathrm { M O E A }$ generates the prompt based on Rule 2 in Table 2 to make the LLM re-generate qualified differential seed solutions.

# Evaluation

To evaluate the effectiveness and advancement of $\mu \mathrm { M O E A }$ , we apply it to search for solutions that detect safety violations of the representative MCDL system, and compare $\mu \mathrm { M O E A }$ ’s performance to the SOTA method.

# Experiment Setup

MCDL System. Autonomous driving systems (ADSs) exemplify a prototypical case of multi-component deep learning (MCDL) systems, comprising various components built upon multiple deep learning models. These components and models engage in high-frequency communication and inputoutput interactions. Given the considerable social implications of autonomous driving technology, detecting safety violations of ADSs is of substantial importance.

We select the industrial full-stack ADS, Baidu Apollo (Baidu Apollo 2013) to evaluate the ability of $\mu \mathrm { M O E A }$ in finding safety violations of MCDL systems, due to the representativeness, practicality and advancedness. (1) Representativeness. Apollo ranks among the top 4 leading industrial ADS developers (Funicello-Paul April 1, 2024) (the other three ADSs, Waymo, Ford, and Cruise, are not released publicly). (2) Practicality. Apollo can be readily installed on vehicles for driving on public roads (Hersey April 1, 2024) (it has provided self-driving services for real vehicles (Autoware Foundation 2015; Baidu April 1, 2024)). (3) Advancedness. Apollo is actively and rapidly updated (the releases of Apollo update on a weekly basis).

Test Platform. We conducted the experiments on Ubuntu 20.04 with $5 0 0 \mathrm { G B }$ memory, an Intel Core i7 CPU, and an NVIDIA GTX2080 TI. SORA-SVL (Huai 2023) (an end-toend AV simulation platform which supports connection with Apollo) and San Francisco map are selected to execute the generated solutions. During the experiments, all modules of Apollo are turned on, including perception module, localization module, prediction module, routing module, planning module, and control module.

Evaluation Metrics. To evaluate the effectiveness of the method in detecting diverse safety violations of the ADS, the metrics include the following aspects:

• How many types of safety violations are detected? • How many solutions are generated on average to detect one safety violation? • How long does it take on average to detect the first safety violation and all found types of safety violations?

# Effectivenss of $\mu \mathbf { M O E A }$

We run $\mu \mathrm { M O E A }$ for 24 hours to detect safety violations of Apollo. For the found safety violations, we analyze their root causes by locating the incorrect operations of modules in Apollo. Furthermore, based on the analysis, we classify the found safety violations into distinct types. To account for the randomness, the experiments are repeated five times and the average results are provided as follows.

Table 3: Results of $\mu \mathrm { M O E A }$ and ablation baselines   

<html><body><table><tr><td></td><td>μMOEA</td><td>μMOEAr</td><td>μMOEAn</td></tr><tr><td>types of detected SV</td><td>10</td><td>10</td><td>6</td></tr><tr><td>number of solution</td><td>12</td><td>12.7</td><td>24.3</td></tr><tr><td>time to detect the first SV</td><td>11min</td><td>39min</td><td>17min</td></tr><tr><td>time to detect all types of SVs</td><td>14h</td><td>15h</td><td>22h</td></tr></table></body></html>

![](images/4fe4838471380b414da40070b644ab2d378b69e09812776de758b3ddf4c549e6.jpg)  
Figure 2: The number of found safety violations over time

For each run, on average, 3756 solutions $\operatorname* { m i n } { 3 3 4 6 }$ and max 4015) are generated by $\mu \mathrm { M O E A }$ and 313 $\operatorname* { m i n } 2 9 2$ and max 355) out of them have safety violations of Apollo. $\mu \mathrm { M O E A }$ can detect 10 distinct types of safety violations of Apollo, which are all revealed in the first 14 hours.

To evaluate the benefit of the LLM-based initial population creation and differential seed generation, we conduct the ablation experiments of $\mu \mathrm { M O E A }$ . Two variant versions $\mu M O E A _ { r }$ and $\mu M O E A _ { n }$ are implemented. $\mu M O E A _ { r }$ creates the initial population by random initialization of solutions, and $\mu M O E A _ { n }$ evolves the solutions without differential seeds. We run $\mu \mathrm { M O E A }$ , $\mu M O E A _ { r }$ and $\mu M O E A _ { n }$ for the same amount of time, and compare their effectiveness and efficiency. The results are shown as Table 3 (where SV is the abbreviation for safety violation) and Figure 2.

$\mu M O E A _ { r }$ can detect 10 types of safety violations of Apollo, and $\mu M O E A _ { n }$ can detect 6 types of safety violations of Apollo. On average, in the 24-hour run, $\mu M O E A _ { r }$ generates 3922 solutions $( \operatorname* { m i n } { 3 8 5 3 }$ and max 4014), and 308 of them $\mathrm { \tt m i n } 2 8 9$ and max 315) detect safety violations of Apollo. For $\mu M O E A _ { n }$ , it generates 3352 solutions (min 3099 and max 3480), and 138 of them $( \operatorname* { m i n } \ 1 2 1$ and max 150) detect safety violations of Apollo.

Table 3 shows that $\mu M O E A _ { r }$ takes the most time to detect the first safety violation of Apollo. It can be seen from Figure 2(a) that in early-generation solutions, the number of safety violations detected by $\mu M O E A _ { r }$ is the least. We can conclude that $\mu \mathrm { M O E A }$ ’s creation of initial population creation helps generate better initial population than random initialization.

For $\mu M O E A _ { n }$ , Table 3 shows that the number of safety violation types detected by it is fewer than $\mu \mathrm { M O E A }$ and $\mu M O E A _ { r }$ , and it takes more time to detect all found types of safety violations. The average Euclidean Distance across the detected different safety violation types of $\mu \mathrm { M O E A }$ is 81.10 meters, and that of $\mu M O E A _ { r }$ is 69.72 meters. From Figure 2(b), we can see that as the iterations of evolutionary search increase, the growth of safety violations detected by $\mu M O E A _ { n }$ is slowest. We can conclude that the differential seeds of $\mu \mathrm { M O E A }$ can help solve the local optimal and detect more diverse types of safety violations.

It’s worth noting that, during the iterations of $\mu \mathrm { M O E A }$ and $\mu M O E A _ { r }$ , after a few types of safety violations have been found, the detection of safety violations grows faster. We analyze that it benefits from the feedback-based differential seed generation. As the evolutionary iterations increase, the solutions of feedback increase. $\mu \mathrm { M O E A }$ can better learn more experience about the characteristics of optimal solutions, which can improve the quality of the generated differential seed solutions.

# Advancement of $\mu \mathbf { M O E A }$

We evaluate $\mu \mathrm { M O E A }$ in comparison to the SOTA method that uses the multi-objective genetic algorithm (NSGA-II) to detect safety violations of Apollo: MOSAT (Tian et al. 2022a). MOSAT generates the first population by randomly initialized individuals. Based on them, MOSAT uses multiobjective genetic algorithm to csearch for optimal and diverse solutions. The individuals are evaluated by multiobjective fitness function, which contains the elitism and diversity. MOSAT determines crossover probability and mutation probability of parent individuals by random rates and the fixed variation threshold. The variation operators that are defined to manipulate individuals include uniform crossover and mutation.

We run MOSAT on the same road in San Francisco as $\mu \mathrm { M O E A }$ . For the sake of fairness, in each 24-hour running, the number of individuals in each generation of MOSAT and $\mu \mathrm { M O E A }$ are the same. The comparison results of $\mu \mathrm { M O E A }$ and MOSAT are shown as Table 4.

Table 4: Comparison results of $\mu \mathrm { M O E A }$ and MOSAT   

<html><body><table><tr><td colspan="3">Approach</td><td>μMOEA</td><td>MOSAT</td></tr><tr><td colspan="2">typesofdetectedSV</td><td>10</td><td>6</td></tr><tr><td rowspan="3">number of solutions to detect one SV</td><td>min</td><td>10.1</td><td>61.0</td></tr><tr><td>max</td><td>13.7</td><td>65.9</td></tr><tr><td>avg</td><td>12</td><td>62.1</td></tr><tr><td rowspan="3">time to detect the first SV (min)</td><td>min</td><td>1</td><td>2</td></tr><tr><td>max</td><td>12</td><td>28</td></tr><tr><td>avg</td><td>7</td><td>16</td></tr><tr><td rowspan="3">time to detect all found types of SVs (hour)</td><td>min</td><td>11.3</td><td>16.0</td></tr><tr><td>max</td><td>13.6</td><td>18.9</td></tr><tr><td>avg</td><td>12.9</td><td>18.1</td></tr></table></body></html>

In each 24-hour running, MOSAT can find 6 types of safety violations of Apollo. On average, MOSAT generates 3541 solutions $\operatorname* { m i n } { 3 2 0 8 }$ and max 3719), and 57 (min 49 and max 61) out of them detect safety violations of Apollo.

$\mu \mathrm { M O E A }$ detects 10 distinct types of safety violations of Apollo and all of them are detected in the first 14 hours. MOSAT detects 6 types of safety violations of Apollo and all of them are detected in the first 19 hours. The average Euclidean Distance across the detected different safety violation types of $\mu \mathrm { M O E A }$ is 81.10 meters, and that of $\mu M O E A _ { r }$ is 64.70 meters. Moreover, the 6 types of safety violations are all revealed in the 10 types of safety violation detected by $\mu \mathrm { M O E A }$ . It takes $\mu \mathrm { M O E A }$ less time to detect the first safety violation of Apollo than MOSAT. Therefore, compared with MOSAT, $\mu \mathrm { M O E A }$ can detect more types of safety violations of Apollo in a shorter time. On average, one safety violation of Apollo occurs in 12 solutions generated by $\mu \mathrm { M O E A }$ . MOSAT generates 62 solutions to find one safety violation of Apollo. The safety-violation exposure frequency in $\mu \mathrm { M O E A }$ is higher, which shows that $\mu \mathrm { M O E A }$ can efficiently detect more safety violations of Apollo. The comparison results show that $\mu \mathrm { M O E A }$ can more effectively detect more types of safety violations in the MCDL system.

# Related Work

# Large Language Models for Reasoning

Recent advancements in large language models (LLMs) have demonstrated their potential in a variety of tasks (Ji et al. 2024), including quantitative reasoning. LLMs have tremendous capabilities in solving complex tasks, from quantitative reasoning to understanding natural language (Romera-Paredes et al. 2024). Early models such as GPT3 have been shown to generate coherent text and perform well in tasks that require contextual understanding, but they often struggle with more complex reasoning tasks, particularly those that involve multi-step logic or abstract thinking.

To address these limitations, researchers have proposed various approaches to enhance the quantitative reasoning capabilities of LLMs. One notable method is the integration of external knowledge bases and joint multi-cues (Mann et al. 2020; Ji et al. 2024), which has been shown to improve the accuracy and depth of reasoning by providing models with additional contextual information. Another approach is the use of prompt engineering (Reynolds and McDonell 2021), where carefully designed prompts guide the model towards better reasoning outcomes. Furthermore, there has been growing interest in the application of LLMs to quantitative reasoning tasks in specific domains, such as mathematical problem-solving, where domain-specific training data can significantly enhance the model performance.

# Multi-Objective Evolutionary Algorithms

Multi-objective evolutionary algorithms (MOEAs) have become a prominent tool for solving multi-objective optimization problems due to their ability to find a set of Paretooptimal solutions in a single run (Fonseca, Fleming et al. 1993; Ishibuchi, Tsukamoto, and Nojima 2008; Zitzler, Laumanns, and Thiele 2001). Populations in MOEAs generally evolve through high-performing candidate solutions being mutated or recombined to form the next generation.

One of the most typical MOEAs is the Non-dominated Sorting Genetic Algorithm II (NSGA-II) (Zitzler and Thiele 1999; Deb et al. 2002), which introduced key innovations such as fast non-dominated sorting and crowding distance mechanisms to find the optimal solutions and maintain solution diversity. NSGA-II has since become a benchmark for comparing other MOEAs due to its balance between computational efficiency and solution quality, which has led to a better understanding of the trade-offs involved in using MOEAs for different types of multi-objective problems

# Conclusion and Discussion

In this paper, we propose $\mu \mathrm { M O E A }$ , an LLM-empowered adaptive evolutionary search method for MCDL systems. Different from existing MOEAs that detect safety violations of MCDL systems starting by randomly initialized population, $\mu \mathrm { M O E A }$ leverages LLM’s ability in language understanding and quantitative reasoning to better comprehend the evolutionary task and create high-quality solutions for the initial population. Based on these, $\mu \mathrm { M O E A }$ adopts an adaptive multi-objective evolutionary algorithm to efficiently search for optimal and diverse solutions. To navigate the search away from the local optima, when the evolutionary process gets stuck, $\mu \mathrm { M O E A }$ feedbacks the characteristics of iterations into the LLM to facilitate the learning of evolutionary experience and population characteristics. Then it promotes the LLM to generating differential seed solutions for the next generation. We uses $\mu \mathrm { M O E A }$ to detect safety violations of a representative MCDL system, industrial autonomous driving system. Furthermore, we evaluate the performance of $\mu \mathrm { M O E A }$ by ablation experiments and compare it with the SOTA method that uses multi-objective genetic algorithm to search solutions for diverse safety violations of the system. The experimental results show that $\mu \mathrm { M O E A }$ can effectively and efficiently detect safety violations of MCDL systems and surpass the SOTA method.

To leverage the LLM’s capability, $\mu \mathrm { M O E A }$ inputs the prompt into GPT-4 by sending the API request, which brings extra time cost for waiting the model output. Moreover, the LLM has a limit on the number of input characters, which limits the potential capability of $\mu \mathrm { M O E A }$ due to the limited number of samples for context learning and thought chain. Currently, $\mu \mathrm { M O E A }$ generates the feedback prompt incrementally and updates the early iterations with latest iterations when the characters of the prompt exceeds the limit.

As future work, we aim to employ a local LLM to reduce the time cost for request, and intelligently select the input examples for the feedback, with the potential to further improve the performance and ability of $\mu \mathrm { M O E A }$ . However, there are two main economic implications for deploying $\mu \mathrm { M O E A }$ in the real world: (1) operational costs of remote LLM access; and (2) infrastructure costs of local LLM deployment. For MCDL systems with infrequent updates or without complicated test requirements, remote access to GPT may be cost-effective. For defect detection tasks, local training and deployment of an LLM on the target system is generally more economical.