{
    "source": "ArXiv (Semantic Scholaræœªæ”¶å½•)",
    "arxiv_id": "2507.14049",
    "link": "https://arxiv.org/abs/2507.14049",
    "pdf_link": "https://arxiv.org/pdf/2507.14049.pdf",
    "title": "EdgeVLA: Efficient Vision-Language-Action Models",
    "authors": [
        "PaweÅ‚ Budzianowski",
        "Wesley Maa",
        "Matthew Freed",
        "Jingxiang Mo",
        "Winston Hsiao",
        "Aaron Xie",
        "Tomasz MÅ‚oduchowski",
        "Viraj Tipnis",
        "Benjamin Bolte"
    ],
    "categories": [
        "cs.RO",
        "cs.CL"
    ],
    "publication_date": "æœªæ‰¾åˆ°æäº¤æ—¥æœŸ",
    "venue": "æš‚æœªå½•å…¥Semantic Scholar",
    "fields_of_study": "æš‚æœªå½•å…¥Semantic Scholar",
    "citation_count": "æš‚æœªå½•å…¥Semantic Scholar",
    "influential_citation_count": "æš‚æœªå½•å…¥Semantic Scholar",
    "institutions": [
        "æœªæ‰¾åˆ°æœºæ„ä¿¡æ¯"
    ],
    "paper_content": "# EdgeVLA: Efficient Vision-Language-Action Models\n\nPaweÅ‚ Budzianowski, Wesley Maa, Matthew Freed, Jingxiang Mo, Winston Hsiao Aaron Xie, Tomasz MÅ‚oduchowski, Viraj Tipnis, Benjamin Bolte\n\nAbstractâ€” Vision-Language Models (VLMs) have emerged as a promising approach to address the data scarcity challenge in robotics, enabling the development of generalizable visuomotor control policies. While models like OpenVLA showcase the potential of this paradigm, deploying large-scale VLMs on resource-constrained mobile manipulation systems remains a significant hurdle. This paper introduces Edge VLA (EVLA), a novel approach designed to significantly enhance the inference speed of Vision-Language-Action (VLA) models. EVLA maintains the representational power of these models while enabling real-time performance on edge devices. We achieve this through two key innovations: 1) Eliminating the autoregressive requirement for end-effector position prediction, leading to a $\\mathbf { 7 x }$ speedup in inference, and 2) Leveraging the efficiency of Small Language Models (SLMs), demonstrating comparable training performance to larger models with significantly reduced computational demands. Our early results demonstrate that EVLA achieves comparable training characteristics to OpenVLA while offering substantial gains in inference speed and memory efficiency. We release our model checkpoints and training codebase to foster further research.\n\n# I. INTRODUCTION\n\nThe development of robust and generalizable manipulation policies has long been hampered by the limited availability of large-scale, diverse embodied datasets. Recent advancements in Vision-Language Models (VLMs) [11], [8] offer a compelling solution to this challenge. By leveraging the vast amount of readily available image-text data, VLMs can learn rich representations of the world and be adapted for visuomotor control tasks. Open-source models like OpenVLA [9] have demonstrated the effectiveness of this approach, showcasing impressive performance in various robotic manipulation tasks. However, deploying these largescale VLMs, often exceeding billions of parameters, on resource-constrained mobile platforms with edge devices like the Jetson Nano presents significant challenges. Their high computational and memory requirements hinder realtime performance and limit accessibility for researchers and practitioners.\n\nThe progress in the mobile manipulation can be effective only if the systems we design are inexpensive and easily deployable without putting too much strain on compute requirements. That is why, this paper introduces Edge VLA (EVLA), a novel VLA architecture designed to address above-mentioned challenges. EVLA offers significant improvements in inference speed and efficiency without compromising foundation modelsâ€™ representational power. Our approach centers around two key innovations: First, our work focuses on architectural modifications to achieve significant speedups while maintaining model performance. Specifically by eliminating the autoregressive requirement for endeffector prediction and leveraging the efficiency of SLMs. We challenge the autoregressive approach for predicting endeffector positions, demonstrating that joint control, where the entire position is predicted simultaneously, does not diminish the modelâ€™s encoding capabilities. This modification yields a 7-times increase in inference speed, crucial for real-time robotic control on edge devices.\n\nSecondly, we explore the potential of recently developed Small Large Language Models (SMLs), such as Qwen2 [17], Phi [1] or Gemma [13], which achieve comparable performance to their larger counterparts thanks to scaling laws with significantly reduced computational footprints. Our proposed architecture EVLA comprises of a pretrained language model Qwen2-0.5B fused with two visual encoders SigLIP [19] and DINOv2 [12] adding to 1B parameters. EVLA maintains training performance comparable to that of models 7 times larger while significantly reducing hardware requirements.\n\n# II. RELATED WORK\n\nLearning-based approaches to mobile manipulation are beginning to reach or exceed the performance of classical model-based control systems [6]. We can broadly divide these approaches into systems trained from scratch and those fine-tuned on top of the foundation models.\n\nThe former approach has relied on behavioral cloning where visual observations are typically mapped to either end effector position with orientation or joint positions [3], [10]. These models can be enhanced through regularization, planning or multi-task learning pushing the limits of the performance. This approach enables easy deployment with relatively cheap hardware but does not leverage the power of foundation models [18], [6]. These systems typically train models from scratch with model sizes from 10 to 100M parameters which limits their ability to generalize to novel environments [20], [3].\n\nThe line of work that relies on foundation models incorporates all the aforementioned techniques while aiming for more powerful generalization capabilities. The most extensively explored approach relies on vision-language models [11], [8]. The vision component is typically adapted to operate in the same token space as the LLM, allowing for the reuse of different pretrained blocks. Combined with large manipulation datasets such as OpenX [4], these models have demonstrated the promise of this paradigm by generalizing to new environments [2], [9]. Although these works have highlighted the potential of leveraging large language models (LLMs), they come with substantial computational demands. Efforts to improve efficiency include quantization techniques [16] and hardware-specific kernels [14]. Nevertheless, these system achieve speed of only 5 to $1 0 ~ \\mathrm { H z }$ with stationary compute systems preventing their deployment on edge devices even in laboratory settings.\n\n![](images/78e3d196eeebbff8cd084c47fabe87e1a5b993cba132a49b1db9b3390198dd94.jpg)  \nFig. 1: The comparison of generation logic between OpenVLA and EVLA. The pretraining phase is identical for both models. In phase two, the EVLA LLM is being retrained to generate end-effector position in an autoregressive fashion.\n\n# III. METHOD\n\n# A. Phase 1: VLM Pretraining\n\nEVLA is based on a VLM trained using a combination of image-text pairs sourced from diverse captioning datasets and synthetically generated multimodal instruction-tuning examples [11]. The pre-training dataset comprises 1.2M textimage pairs, facilitating the learning of robust visual and language representations following the recipe of the PrismaticVLM family of models [8]. For language processing, we utilize Qwen2 [17] with 0.5B parameters as it demonstrates the effectiveness of SLMs in achieving comparable performance to that of larger models. We adopt a twopart visual encoder, employing pretrained SigLIP [19] and DinoV2 [12] models, following the architecture of OpenVLA [9]. A projection layer that maps the visual representation to the language modelâ€™s token space is learned jointly with the finetuned visual and language components.\n\n# B. Phase 2: Joint Control for End-Effector Prediction\n\nThe second phase of training utilizes around 1M of manipulation examples from the OpenX dataset [4]. Traditional VLAs employ an autoregressive approach to predicting endeffector positions, mimicking the causal nature of language generation. However, we hypothesize that for robotic control, this restriction is not inherently necessary. We propose that predicting the entire end-effector position jointly, rather than sequentially, does not compromise the modelâ€™s encoding capabilities while significantly improving inference speed.\n\nBy removing the causal mask in the LLM and training the model to output the entire end-effector position at once, we eliminate autoregressive requirements, achieving a six-times speedup in inference - a critical improvement for real-time applications on edge devices.\n\nSee Figure 1 for the overall layout of the model and the comparison to its autoregressive counterpart.\n\n# IV. EARLY RESULTS\n\nIn order to evaluate EVLAâ€™s capabilities of adapting to non-autoregressive loss while utilizing SMLs, we used BridgeData V2 [15] and OpenX datasets [4] as a testbed. We hypothesize that the early training results will shed some light on model characteristics.\n\n# A. BridgeData V2 training characteristics\n\nInitial experiments on the BridgeData V2 dataset conducted on a single node with 8 A100-80GB GPUs, validate that EVLA can achieve similar training performance to its 7.5B parameters counterpart. Figure 2 illustrates the training progress, showcasing the comparable performance of the two models. It is worth pointing out that the training efficiency is distinguishably slower for EVLA due to smaller parametrization capabilities.\n\n# B. OpenX training characteristics\n\nWe further evaluate EVLA on the full OpenX dataset, utilizing 80 A100-40GB GPUs for approximately 5 days. While the training efficiency of EVLA is slower than OpenVLA due to the smaller representational power, the training iteration is around 7 times faster. It also allows for larger batch sizes, effectively mitigating the difference in training efficiency. Figure 3 shows the training progress on the OpenX dataset.\n\nDue to computational constraints, we were not able to reproduce the full training of OpenVLA as in the original implementation [9]. However, the training curves show the signs of stagnation and the behavior is similar to the BridgeV2 case.\n\n![](images/2f08ad3e93e3cd457ab66b31da3c1bd82bc13628b3ac98835aadf1271c0420e2.jpg)  \nFig. 2: The loss (left) and action token accuracy (right) training curves for both OpenVLA and EVLA models during trainin on the BridgeData V2 dataset.\n\n![](images/18d1676d169d0497ccf2f741a4c4e6b46ae9f0741ca0c4fcead0b17b7c096a0f.jpg)\n\n![](images/04da96f8923c2b4882dd8dc55f9ed4def55ad544f76fd2b1590a88fec1eb2e8e.jpg)  \nFig. 3: The loss (left) and the action token accuracy (right) training curves for both OpenVLA and EVLA models during training on the OpenX dataset.\n\n# C. Efficiency Gains\n\n# V. CONCLUSIONS\n\nEVLAâ€™s architectural modifications result in substantial improvements in the inference speed and memory consumption, enabling deployment on resource-constrained edge devices. Table I compares the inference time and memory requirements of EVLA and OpenVLA on an A100-40GB GPU.\n\nTABLE I: Efficiency Comparison of EVLA and OpenVLA.   \n\n<html><body><table><tr><td>Model</td><td>Inference Time (ms)</td><td>MemoryUsage (GB)</td></tr><tr><td>OpenVLA</td><td>20</td><td>16</td></tr><tr><td>EVLA</td><td>5</td><td>4</td></tr></table></body></html>\n\nBy using a smaller VLM and optimizing our architecture, we can achieve significant inference speed and memory improvements. These speedups will only increase with the addition of more degrees of freedom. It is worth noting that OpenVLA uses flash_attention2 [5] kernels, while EVLA is evaluated in the eager mode. Advances in flexible and efficient attention mechanisms, such as FlexAttention [7], are expected to push these numbers even further. These results show the path for the deployment of mobile manipulation systems on CPU architectures.\n\nThis paper presents Edge VLA (EVLA), a novel VLA architecture designed for efficient deployment on mobile manipulators and humanoids. By eliminating the autoregressive requirement for end-effector prediction and leveraging the efficiency of SLMs, EVLA achieves significant improvements in inference time and a reduced memory footprint. While the early results suggest EVLA has the potential to be a good candidate for real-time VLA applications on resourceconstrained platforms, the crucial next step is to evaluate EVLA on a variety of different embodiments. We plan to employ at least two different humanoid platforms to assess its few-shot capabilities.\n\nWe release our model checkpoints and training codebase to facilitate further research. We believe that EVLAâ€™s efficiency and accessibility will empower researchers and practitioners to explore the full potential of VLAs for mobile manipulation. Future work will focus on further optimizing EVLAâ€™s architecture and exploring its deployment on a wider range of edge devices, including CPU-based platforms.",
    "summary": "```json\n{\n  \"core_summary\": \"### ğŸ¯ æ ¸å¿ƒæ¦‚è¦\\n\\n> **é—®é¢˜å®šä¹‰ (Problem Definition)**\\n> *   è®ºæ–‡è§£å†³çš„æ ¸å¿ƒé—®é¢˜æ˜¯å¤§å‹è§†è§‰-è¯­è¨€-åŠ¨ä½œæ¨¡å‹ï¼ˆVLAï¼‰åœ¨èµ„æºå—é™çš„è¾¹ç¼˜è®¾å¤‡ä¸Šéƒ¨ç½²æ—¶çš„é«˜è®¡ç®—å’Œå†…å­˜éœ€æ±‚é—®é¢˜ï¼Œè¿™ä¸€é—®é¢˜é™åˆ¶äº†å®æ—¶æ€§èƒ½å’Œåœ¨ç§»åŠ¨æœºå™¨äººå¹³å°ä¸Šçš„åº”ç”¨ã€‚\\n> *   è¯¥é—®é¢˜çš„é‡è¦æ€§åœ¨äºï¼Œé«˜æ•ˆçš„VLAæ¨¡å‹å¯ä»¥æ¨åŠ¨ç§»åŠ¨æœºå™¨äººå’Œäººå½¢æœºå™¨äººçš„å¹¿æ³›åº”ç”¨ï¼Œå°¤å…¶æ˜¯åœ¨éœ€è¦å®æ—¶å“åº”çš„åœºæ™¯ä¸­ã€‚\\n\\n> **æ–¹æ³•æ¦‚è¿° (Method Overview)**\\n> *   è®ºæ–‡æå‡ºEdge VLAï¼ˆEVLAï¼‰ï¼Œä¸€ç§æ–°å‹VLAæ¶æ„ï¼Œé€šè¿‡æ¶ˆé™¤è‡ªå›å½’éœ€æ±‚å’Œä½¿ç”¨å°å‹è¯­è¨€æ¨¡å‹ï¼ˆSLMsï¼‰æ¥æ˜¾è‘—æå‡æ¨ç†é€Ÿåº¦å’Œå†…å­˜æ•ˆç‡ã€‚\\n\\n> **ä¸»è¦è´¡çŒ®ä¸æ•ˆæœ (Contributions & Results)**\\n> *   **åˆ›æ–°è´¡çŒ®ç‚¹1ï¼š** æ¶ˆé™¤è‡ªå›å½’éœ€æ±‚ï¼Œé€šè¿‡è”åˆæ§åˆ¶é¢„æµ‹æ•´ä¸ªæœ«ç«¯æ‰§è¡Œå™¨ä½ç½®ï¼Œå®ç°7å€æ¨ç†é€Ÿåº¦æå‡ï¼ˆåŸæ–‡ä¸º6å€ï¼Œä¿®æ­£ä¸º7å€ï¼‰ã€‚\\n> *   **åˆ›æ–°è´¡çŒ®ç‚¹2ï¼š** ä½¿ç”¨SLMsï¼ˆå¦‚Qwen2-0.5Bï¼‰ï¼Œåœ¨ä¿æŒæ€§èƒ½çš„åŒæ—¶æ˜¾è‘—é™ä½è®¡ç®—éœ€æ±‚ã€‚\\n> *   **å…³é”®æ•°æ®ï¼š** EVLAåœ¨A100-40GB GPUä¸Šçš„æ¨ç†æ—¶é—´ä¸º5msï¼Œå†…å­˜ä½¿ç”¨ä¸º4GBï¼Œè€ŒOpenVLAçš„æ¨ç†æ—¶é—´ä¸º20msï¼Œå†…å­˜ä½¿ç”¨ä¸º16GBã€‚\",\n  \"algorithm_details\": \"### âš™ï¸ ç®—æ³•/æ–¹æ¡ˆè¯¦è§£\\n\\n> **æ ¸å¿ƒæ€æƒ³ (Core Idea)**\\n> *   EVLAçš„æ ¸å¿ƒæ€æƒ³æ˜¯é€šè¿‡è”åˆé¢„æµ‹æœ«ç«¯æ‰§è¡Œå™¨ä½ç½®ï¼ˆè€Œéè‡ªå›å½’é¢„æµ‹ï¼‰å’Œä½¿ç”¨é«˜æ•ˆçš„SLMsï¼Œæ¥å‡å°‘è®¡ç®—å’Œå†…å­˜å¼€é”€ï¼ŒåŒæ—¶ä¿æŒæ¨¡å‹çš„è¡¨ç¤ºèƒ½åŠ›ã€‚\\n> *   è¿™ç§æ–¹æ³•æœ‰æ•ˆçš„åŸå› æ˜¯ï¼Œæœºå™¨äººæ§åˆ¶ä»»åŠ¡ä¸­çš„ä½ç½®é¢„æµ‹ä¸éœ€è¦åƒè¯­è¨€ç”Ÿæˆé‚£æ ·çš„å› æœæ€§ï¼Œå› æ­¤å¯ä»¥å¹¶è¡ŒåŒ–å¤„ç†ã€‚\\n\\n> **åˆ›æ–°ç‚¹ (Innovations)**\\n> *   **ä¸å…ˆå‰å·¥ä½œçš„å¯¹æ¯”ï¼š** ä¼ ç»ŸVLAæ¨¡å‹ï¼ˆå¦‚OpenVLAï¼‰é‡‡ç”¨è‡ªå›å½’æ–¹å¼é¢„æµ‹æœ«ç«¯æ‰§è¡Œå™¨ä½ç½®ï¼Œå¯¼è‡´é«˜å»¶è¿Ÿå’Œè®¡ç®—æˆæœ¬ã€‚\\n> *   **æœ¬æ–‡çš„æ”¹è¿›ï¼š** EVLAé€šè¿‡ç§»é™¤LLMä¸­çš„å› æœæ©ç ï¼Œè®­ç»ƒæ¨¡å‹ä¸€æ¬¡æ€§è¾“å‡ºæ•´ä¸ªæœ«ç«¯æ‰§è¡Œå™¨ä½ç½®ï¼Œä»è€Œæ˜¾è‘—æå‡æ¨ç†é€Ÿåº¦ã€‚\\n\\n> **å…·ä½“å®ç°æ­¥éª¤ (Implementation Steps)**\\n> *   1. **é¢„è®­ç»ƒé˜¶æ®µï¼š** ä½¿ç”¨1.2Mæ–‡æœ¬-å›¾åƒå¯¹è®­ç»ƒVLMï¼Œé‡‡ç”¨Qwen2-0.5Bä½œä¸ºè¯­è¨€æ¨¡å‹ï¼ŒSigLIPå’ŒDinoV2ä½œä¸ºè§†è§‰ç¼–ç å™¨ã€‚\\n> *   2. **è”åˆæ§åˆ¶é˜¶æ®µï¼š** ä½¿ç”¨OpenXæ•°æ®é›†çš„1Mæ“ä½œç¤ºä¾‹ï¼Œè®­ç»ƒæ¨¡å‹ä¸€æ¬¡æ€§é¢„æµ‹æœ«ç«¯æ‰§è¡Œå™¨ä½ç½®ï¼Œæ¶ˆé™¤è‡ªå›å½’éœ€æ±‚ã€‚\\n\\n> **æ¡ˆä¾‹è§£æ (Case Study)**\\n> *   è®ºæ–‡æœªæ˜ç¡®æä¾›æ­¤éƒ¨åˆ†ä¿¡æ¯ã€‚\",\n  \"comparative_analysis\": \"### ğŸ“Š å¯¹æ¯”å®éªŒåˆ†æ\\n\\n> **åŸºçº¿æ¨¡å‹ (Baselines)**\\n> *   OpenVLA\\n\\n> **æ€§èƒ½å¯¹æ¯” (Performance Comparison)**\\n> *   **åœ¨æ¨ç†æ—¶é—´ä¸Šï¼š** EVLAåœ¨A100-40GB GPUä¸Šçš„æ¨ç†æ—¶é—´ä¸º5msï¼Œæ˜¾è‘—ä¼˜äºOpenVLAï¼ˆ20msï¼‰ï¼Œé€Ÿåº¦æå‡äº†4å€ã€‚\\n> *   **åœ¨å†…å­˜ä½¿ç”¨ä¸Šï¼š** EVLAçš„å†…å­˜ä½¿ç”¨ä¸º4GBï¼Œè¿œä½äºOpenVLAï¼ˆ16GBï¼‰ï¼Œå†…å­˜æ•ˆç‡æå‡äº†4å€ã€‚\\n> *   **åœ¨è®­ç»ƒæ€§èƒ½ä¸Šï¼š** EVLAåœ¨BridgeData V2å’ŒOpenXæ•°æ®é›†ä¸Šå±•ç¤ºäº†ä¸OpenVLAç›¸å½“çš„è®­ç»ƒæ€§èƒ½ï¼Œå°½ç®¡å…¶å‚æ•°è§„æ¨¡æ›´å°ã€‚\\n> *   **åœ¨è®­ç»ƒæ•ˆç‡ä¸Šï¼š** EVLAçš„è®­ç»ƒè¿­ä»£é€Ÿåº¦æ¯”OpenVLAå¿«7å€ï¼Œä½†ç”±äºè¾ƒå°çš„è¡¨ç¤ºèƒ½åŠ›ï¼Œè®­ç»ƒæ•ˆç‡è¾ƒæ…¢ã€‚\",\n  \"keywords\": \"### ğŸ”‘ å…³é”®è¯\\n\\n*   è§†è§‰-è¯­è¨€-åŠ¨ä½œæ¨¡å‹ (Vision-Language-Action Model, VLA)\\n*   è¾¹ç¼˜è®¡ç®— (Edge Computing, N/A)\\n*   å°å‹è¯­è¨€æ¨¡å‹ (Small Language Model, SLM)\\n*   æœºå™¨äººæ§åˆ¶ (Robotic Control, N/A)\\n*   éè‡ªå›å½’é¢„æµ‹ (Non-autoregressive Prediction, N/A)\\n*   è”åˆæ§åˆ¶ (Joint Control, N/A)\\n*   æ¨ç†æ•ˆç‡ (Inference Efficiency, N/A)\\n*   ç§»åŠ¨æœºå™¨äºº (Mobile Manipulation, N/A)\"\n}\n```"
}