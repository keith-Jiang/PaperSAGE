# Shipwright: Proving liveness of distributed systems with Byzantine participants

Derek Leung MIT CSAIL

Nickolai Zeldovich MIT CSAIL

Frans Kaashoek MIT CSAIL

# Abstract

Ensuring liveness in a decentralized system, such as PBFT, is critical, because there may not be any single administrator that can restart the system if it encounters a liveness bug. At the same time, liveness is challenging to achieve because any single participant could be malicious, and yet the overall system must make forward progress. While verification is a promising approach for ensuring the absence of bugs, no prior work has been able to verify liveness for an executable implementation of PBFT.

Shipwright is a verification framework for proving correctness and liveness of distributed systems where some participants might be malicious. Shipwright introduces three techniques that enable formal reasoning about decentralized settings with malicious participants, allow developers to decompose their system and proof in a modular fashion into sub-protocols and sub-proofs, and support sound reasoning about cryptographic signatures that may be embedded in messages. We used Shipwright to implement and verify an initial prototype of agreement on a single log entry in PBFT (with a few limitations) and translate it to an executable implementation in Go. We experimentally demonstrate its operation and liveness both in the common case and in several failure scenarios.

# 1 Introduction

Decentralized distributed systems operate in a challenging environment where not all participants might behave correctly. For example, Byzantine fault tolerant protocols are designed to tolerate arbitrary misbehavior from some fraction of participating nodes, such as in blockchains and keytransparency systems. In this setting, developers must ensure their system achieves not just safety but also liveness‚Äî that is, that the overall system keeps making progress. Ensuring liveness in the presence of Byzantine participants is hard, because malicious participants can endlessly delay messages, retransmit the same messages over and over, cause restarts, etc. Moreover, many systems that worry about Byzantine participants are open systems, meaning there is no single administrator in charge. As a result, if a liveness bug were to happen in a blockchain system or a key transparency system, there would be no administrator that could restart all of the servers and get the system running again. Thus, for open distributed systems, liveness becomes a critical concern at the same level as functional correctness (safety).

This paper introduces Shipwright, a new framework for machine-checked verification of distributed systems, which enables developers to prove both safety and liveness properties of their implementation. Using Shipwright, we verify an implementation of the core PBFT [4] protocol. The formal proof ensures that, regardless of what the adversarial Byzantine participants do, the PBFT system with nodes running our verified implementation will be correct (safety) and will make progress (liveness) in all possible cases.

Consider an example mistake that we inadvertently made in our PBFT implementation and caught with Shipwright. When one view of PBFT fails to reach consensus, a node can send a view-change message to other participants in an attempt to make progress in the next view of the protocol. View-change messages in PBFT must prove that the sender has seen enough messages from other participants to merit switching to a new view. This is done by including signed messages from other participants as part of a view-change message. Our implementation had a bug where, in some situations, a node would include signatures from the wrong previous view as part of a view-change message. Other participants would check the signatures in this view-change message, discover that the signed message is not what they were expecting, and then reject it. This would not lead to a safety violation‚Äîno invalid signatures would have been accepted, and no incorrect outcome would be produced‚Äî but it would lead to a liveness violation because the system might never move on to the next view.

More precisely, the bug is triggered following a series of events. First, the network drops all commit messages for some number of views $k$ but permits prepare and viewchange messages to propa gùëòate. This prevents termination but causes some value $\boldsymbol { v }$ to become prepared, which means it must show up in all subsequent view changes. Next, the network drops all prepare messages from view $k + 1$ . Then, the network fully recovers for all messages in ùëòsu+bs1equent views $k ^ { \prime } > k + 1$ . All nodes sign off on the view-change for valùëòue $\boldsymbol { v }$ ùëòha+v 1ng prepared at view $k$ , which an honest primary atùë£taches to the new-view messùëòage kicking off view $k + 2$ ‚Äîonly for the nodes to reject the signatures of the viewcùëòh+a n2ge messages (that they just created), due to a bug in the byte-level re-encoding of the view-change message plaintext within the new-view message. In fact, this holds for all future $k ^ { \prime } > k + 1$ , so the protocol never terminates.

As described in $\ S 2$ , Shipwright is the first framework that can verify liveness of distributed system implementations and ensure the absence of bugs such as the one described above. Shipwright‚Äôs design addresses two key challenges. First, Shipwright must enable modular verification of liveness. This means that developers can use Shipwright to decompose overall protocols into smaller sub-protocols that logically execute in parallel, such as the proposal, voting, and view-change sub-protocols in PBFT [4]. This reduces the amount of state that the developer has to reason about at one time, enables proof automation, and allows reuse of components (such as reusing the same broadcast primitive for both the prepare and commit steps in PBFT). Achieving this sort of modularity is a challenging problem because liveness is a global property. For example, classical horizontal composition (combining two independent sub-protocols) does not work well in the presence of a global clock that all sub-protocols use for their timeouts, which in turn impacts liveness. Similarly, vertical layering of refinement proofs requires care in ensuring that liveness properties are preserved, and, in particular, that there are no infinite stuttering steps in a refinement proof.

Second, Shipwright must formally reason about Byzantine nodes. To be sound, Shipwright‚Äôs model must allow Byzantine participants to send arbitrary messages over the network. However, simply assuming that network messages are untrustworthy is too strong because real systems rely on some fraction of honest nodes to achieve safety and liveness. Similarly, Byzantine nodes cannot send an infinite number of messages that effectively stop the system‚Äôs progress by flooding the network. Moreover, Byzantine nodes cannot produce fake cryptographic signatures, which are often necessary in these protocols for both safety and liveness; at the same time, we do not want to explicitly model the details and probabilistic definitions of signature scheme security, as this would substantially complicate verification.

To address these challenges, Shipwright introduces several key techniques. The first is an encoding of liveness conditions in terms of tasks that correspond to local completion measures, which enables Shipwright to translate liveness statements about infinite executions into proof obligations about pairs of states. These statements are more amenable to automated verification. The second is a liveness-preserving composition operator, which enables developers to decompose complex protocols into simpler components, such as composing the prepare and commit sub-protocols of a single PBFT view, or composing an unbounded number of views to agree on a single value in PBFT. Finally, to soundly reason about Byzantine nodes, Shipwright introduces a message stapling model that captures how Byzantine distributed systems use signatures in their messages without exposing the low-level details of cryptographic constructions.

We implemented a prototype of Shipwright in Dafny. To demonstrate the benefits of Shipwright‚Äôs techniques, including composition and stapling, our paper makes progress towards developing and proving a simplified implementation of PBFT with Shipwright. The implementation agrees on a single log entry, supporting an infinite number of views, and its liveness guarantee ensures termination, but it does not yet support agreement on multiple entries. Shipwright proves a top-level theorem that establishes a liveness-preserving refinement between the executable implementation, operating on Shipwright‚Äôs network model, and our abstract specification of PBFT. Although PBFT is our main case study, we believe Shipwright‚Äôs techniques are generally applicable for reasoning about liveness of distributed systems that use signatures.

We use Dafny‚Äôs Go code extraction to generate an executable implementation. Performance experiments shown in $\ S 6$ demonstrate that the implementation works but its performance is limited by inefficiencies in Dafny‚Äôs extracted Go code. Shipwright consists of 13,357 lines of code, of which 1351 lines are trusted code. The PBFT implementation consists of 31,138 lines of code, which is largely proofs and internal specifications; just 266 lines of code are trusted (e.g., the top-level spec).

# 2 Related work

The closest related work is the LiDO framework [14], which takes a different approach to prove an end-to-end monolithic refinement establishing the safety and liveness of the partially synchronous Jolteon protocol [5]. LiDO is based on the ADO [7] model and focuses on consensus protocols, while Shipwright is a general-purpose framework for systems‚Äî not necessarily consensus protocols‚Äîwith Byzantine faults. LiDO proves liveness of Jolteon by decomposing its liveness properties into the conjunction of safety properties and refinements of timed and segmented traces. In contrast, Shipwright directly proves arbitrary weak fairness properties by using completion measures. The LiDO proof examines the implementation as a single piece of code [15]; Shipwright introduces a decomposition operator that allows the implementation to be organized into subprotocols and reused. Finally, the LiDO proof models signatures at a high level but does not implement them, as cryptography is absent from its implementation [15], so it cannot reason about bugs like the one described in $\ S 1$ . Shipwright enables a protocol developer to control and prove correct how an implementation verifies signatures on messages‚Äô binary encodings.

IronFleet [6] supports verification of some liveness properties. However, the systems verified in IronFleet do not handle Byzantine faults and are relatively simpler in terms of their liveness guarantees. As a result, IronFleet was able to verify liveness with relatively simple and manual proofs built around IronFleet‚Äôs TLA encoding in Dafny. Furthermore, IronFleet‚Äôs liveness proof is separate from the correctness proof, and is not compositional (i.e., the safety proof is a refinement, but the liveness proof is not), which makes it difficult to prove liveness for applications built on top of IronFleet‚Äôs library. In contrast, Shipwright handles PBFT, which is a more complex protocol and implementation, requiring more sophisticated verification techniques to reason about liveness in a Byzantine setting.

Bythos [16] is a Coq framework that takes a compositional approach to liveness reasoning using local message passing and can handle weak fairness properties. Instead of verifying a partially synchronous protocol (like PBFT), it verifies asynchronous protocols which do not involve reasoning about time or timeouts in the code. Bythos is able to leverage composition to prove end-to-end properties about composite protocols, but the top-level theorems do not involve refinement. Bythos can generate executable implementations by extracting Coq definitions of a protocol.

Protocol reasoning. There is a substantial amount of prior work on verifying liveness properties of protocols as opposed to implementations.

Lamport presented machine-checked TLA proofs of safety refinement for Byzantine Paxos, but did not construct machine-checked liveness proofs [10]. Bertrand et al. [2] verified safety and liveness of the Redbelly protocol using ByMC [8], but did not verify the implementation, and did not prove a succinct liveness specification; instead, the top-level specification is a complex temporal-logic statement, with a non-machine-checked argument of how this temporal-logic statement relates to a simpler top-level specification. Furthermore, Bertrand et al. [2] have a formal gap between their partial-synchrony network assumptions and their fairness assumptions, with a non-machine-checked argument for why they are comparable.

Losa and Dodds [11] prove safety and liveness of the Stellar protocol, a Byzantine-fault tolerant consensus protocol. A key challenge they address is to account for the capabilities of Byzantine nodes as axioms in the decidable fragment of logic supported by the Ivy [12, 13] verification tool in order to achieve full automation. This work models Byzantine capabilities in terms of assumptions about how they may affect non-malicious nodes‚Äô views of quorums. Berkovits et al. [1] implement a tool that builds on Ivy to automatically verify liveness properties for several Byzantine consensus protocols, where the model of Byzantine behavior is captured through similarly abstract axioms about quorums. Verification in Shipwright is less automated than the above. However, Shipwright targets implementations instead of protocols, and Shipwright uses a lower-level model of Byzantine faults in which Byzantine agents can craft arbitrary messages (but not forge signatures).

# 3 Design

This section presents the design of Shipwright by describing how it handles three different levels: executable code, specifications, and proofs. At each level, we highlight how Shipwright supports three key aspects: liveness, composition, and signatures.

Shipwright‚Äôs overall goal is to allow a programmer to prove that a complex system implementation can be thought of in terms of a simpler abstract specification using refinement (¬ß3.2). Figure 1 illustrates the intended use of Shipwright. The developer writes a modular implementation of PBFT, consisting of four sub-protocols that comprise a single view (pre-prepare, prepare, commit, and view-change), and an unbounded sequence of views that eventually agrees on a single value. The developer then writes specifications for each of these sub-protocols, and proves that the implementations refine these specifications. Finally, the developer writes a top-level specification for the overall PBFT protocol, and proves that the composition of the sub-protocol specifications refines the top-level spec. This proves that the low-level implementation is a refinement of the top-level spec in terms of both safety and liveness.

Graded consensus   
Proposer Voter Vote helper Ephemeral Ephemeral Delayed broadcast broadcast :broadcast Proposal Ephemeral Ephemeral Delayed internal spec ‚Üë   
PRE-PREPARE COMMIT PREPARE VIEW-CHANGE   
VIEW = PRE-PREPARE @ (COMMIT  (PREPARE @ VIEW-CHANGE))

# 3.1 Executable code

To implement a system, Shipwright programmers write three (pure) executable Dafny functions, expressing their implementation in an event-handling callback style, as shown in Figure 2: a node initialization function, of type Zero, which takes some initialization parameters (such as node information and global configuration); a node update callback, of type Run; and a message authentication decoder, of type StapledExtractor. Dafny tools allow us to extract the Zero, Run, and StapledExtractor functions into a target language (Go in our prototype) and link them with a Shipwright runtime that implements networking, signatures, timeouts, etc.

The runtime calls the node update callback sequentially to handle three kinds of events: (1) timeouts, (2) remote messages (received over the network), and (3) local messages (received from a local program). The update callback re

module API { datatype Event<Message, Argument, Signature> $\mathbf { \tau } = \mathbf { \tau }$ | Timeout (time: nat) | Call (arg: Argument) | Receive (src: NodeID, msg: Message, sig: Signature) datatype EventResponse<Message> = | Transmit(dest: NodeID, msg: Message) type Zero<!InitParams, !Node> $\mathbf { \tau } = \mathbf { \tau }$ InitParams $\mathrel { - } >$ Node type Run<!Node, !Message, !Argument, !Signature> $\mathbf { \tau } = \mathbf { \tau }$ (Node, Event<Message, Argument, Signature>) $$ (Node, seq<EventResponse<Message>>) type StapledExtractor<!Message, !Signature> $\mathbf { \tau } = \mathbf { \tau }$ Message $\mathrel { - } >$ seq<(NodeID, Message, Signature)>   
}

turns the new node state and a list of messages, which are byte blobs, to send to peers. The runtime signs messages before transmission and verifies signatures before passing a message to the update callback on the receiving node.

The runtime is written in Go and is not verified; it is assumed to be correct. It implements cryptographic primitives‚Äîboth signing messages and verifying signatures‚Äî and keeps track of the node‚Äôs cryptographic private key. The runtime is also configured with the identities of all peers‚Äî that is, a map from a NodeID to an $\mathrm { I P }$ address and a cryptographic public key. We assume that this configuration is common knowledge; it could be distributed via a trusted networking and public key infrastructure. Shipwright‚Äôs model assumes that all honest nodes run Shipwright‚Äôs runtime with a verified implementation on top of it. Byzantine nodes can execute arbitrary code but are assumed to lack access to the private keys of honest nodes.

Liveness. To ensure liveness of executable code, Shipwright requires developers to implement their code as total Dafny functions. This requires the function to provably terminate on all inputs, ensuring that each individual step (such as initialization or handling of some event) will complete.

Composition. For the developers to reason about the correctness of implementations of individual sub-protocols, Shipwright requires that the implementation be clearly composed out of its constituent sub-protocols. To do this, Shipwright enables the developers to combine several implementations of sub-protocols, each satisfying the executable API shown in Figure 2, into a single implementation that again satisfies the same executable API from Figure 2.

Composing protocol implementations poses two particular challenges. First, the sub-protocols might not be entirely independent: for example, when PBFT receives a quorum of votes in the prepare sub-protocol, the execution model must allow the commit sub-protocol to learn about this fact. Second, there may be an unbounded number of sub-protocols being composed, such as an infinite number of possible views in PBFT. The execution model must allow representing this without materializing an unbounded amount of state.

Shipwright addresses these challenges in its executable composition operator with two ideas: synchronous dispatch and a default map model. The composition operator requires the developer to supply a Tag that names the sub-protocols being composed. For instance, composing two sub-protocols requires supplying a Tag with two possible values (e.g., left and right), whereas composing an infinite number of view sub-protocols in PBFT would require supplying a Tag type of nat, representing the view number. The developer also supplies the protocol implementation for each Tag.

To efficiently handle composition of an unbounded number of sub-protocols, Shipwright‚Äôs composition operator requires the developer to explicitly specify the starting state of each sub-protocol in terms of a Zero function. This allows Shipwright to represent the overall state using a default map, where some number of tags correspond to specific sub-protocol states (e.g., views that have already started executing), but all other tags (e.g., views that have not been reached yet) correspond to their default zero values.

Logically, Shipwright delivers timeout events to all tags (sub-protocols) in a default map, regardless of whether their state is zero. However, for efficiency, it is important to avoid materializing state for a tag in a map unless strictly necessary. Thus, the developer must prove that, in their implementation, a sub-protocol in a zero state takes no action in response to timeout events (i.e., it transmits no messages and its state remains zero). This allows Shipwright‚Äôs runtime to deliver timeout events only to tags explicitly present in the map.

To allow sub-protocols to interact with one another, Shipwright‚Äôs execution model for a composed implementation‚Äî synchronous dispatch‚Äî allows the developer to inject additional calls to sub-protocols when handling inputs. Specifically, Shipwright passes Timeout inputs to every sub-protocol and passes Message inputs to the specific sub-protocol targeted by the message (the composed implementation handles messages of type (Tag, Message) to disambiguate messages between sub-protocols). The developer can specify a function that, for any given input, injects additional Call inputs to any subset of Tags, and those Call inputs will be synchronously executed along with the triggering input. For example, the developer might specify that a Call to the commit sub-protocol be injected when the prepare sub-protocol receives a vote that completes a quorum.

Shipwright‚Äôs composition operator attaches tags to messages, as described above. It also adds tags when signing messages, which ensures that transmitted and signed messages cannot be confused between sub-protocols. For example, even though the prepare and commit sub-protocols have the same executable implementation (they simply count votes until a quorum is reached), their network messages and signatures are distinguished by their Tag value.

Signatures. Shipwright‚Äôs model for reasoning about signatures must address several constraints that arise in the context of proving liveness of protocols like PBFT. First, Shipwright must allow a node to explicitly relay signatures from other nodes in messages that it sends. This allows the application to implement cryptographic certificates: for example, PBFT‚Äôs view-change message includes signed prepare messages from a quorum of nodes to justify advancing the view. We say these signatures of prepare messages are stapled to the view-change message. Second, Shipwright must allow the implementation to explicitly handle signatures: storing them in node-local state, choosing which signatures to send in a network message, etc. Third, Shipwright should allow applications to manipulate signatures separately from the messages that are being signed. For instance, a certificate may consist of many signatures all signing the same underlying message. An application should not have to include many copies of that message, or even any copy of that message at all, if the recipient can infer the message from other context. Moreover, we do not wish to exactly model the correctness and security properties of signing primitives themselves as they involve modeling complex assumptions about probability and computational tractability [3]. Finally, signature verification is computationally expensive and on the critical path of the system, so we would like to enable its parallelism.

Shipwright addresses this challenge using message authentication decoders, which allow us to soundly reason about and efficiently implement stapling. A message authentication decoder is an executable function with the type signature StapledExtractor<Message, Signature> as shown in Figure 2. This decoder computes the set of messages that are stapled to a particular message, with their respective signatures and signers. The sequence returned by the decoder is the set of stapled signatures that go along with this message. In each sequence element, the NodeID value describes the node ID of the message signer, the Message is the message whose signature is being stapled, and the Signature is that signature. Message is a type parameter instantiated with the concrete message type of the implementation to be verified, while Signature is left opaque to the implementation.

The opacity of Signature allows the implementation to store and produce Messages in an arbitrary way. In particular, Figure 2 shows the update callback type signature, Run<Node, Message, Argument, Signature>, where Node contains the node‚Äôs state, Message is the type of network messages, Argument describes local Call events, and Signature describes the signature scheme. The Receive and Transmit types, also shown in Figure 2, describe inputs to the callback and output messages to transmit to peers, respectively. When the callback is instantiated with a particular implementation, Node, Message, and Argument can all depend on the opaque Signature type parameter. For instance, PBFT‚Äôs view-change messages can include stapled signatures (for a quorum of prepare messages). To represent this, the Message type of the view-change sub-protocol includes the sequence of stapled Signature values.

After verifying a root message‚Äôs signature on receipt, the Shipwright runtime calls the authentication decoder on the root message to obtain the set of stapled messages and verifies their signatures before passing the authenticated message to the update callback.

# 3.2 Specifications

Specifications in Shipwright describe the allowed executions of an abstract state machine, as shown in Figure 3. The specification is parametrized by three types. State defines the state of a node. Transition (sometimes abbreviated Trans) describes non-deterministic events that cause the state machine to handle an incoming network message or a timeout, process a call from another sub-protocol, or observe logical actions (such as the clock advancing or the network synchronizing). Task defines events that have liveness (fairness) properties associated with them.

The Init, Next, and Invar functions express safety properties, defining the valid state-machine transitions for a specification. Fair defines the liveness specification, which says that each task defined by the Task type will eventually happen.

atatype Spec<!State, !Transition, !Task> $\mathbf { \tau } = \mathbf { \tau }$ | Spec(init: State $\mathrel { - } >$ bool, next: (State, Transition) $\mathrel { - } >$ State, invar: (State, Transition) $\Rightarrow$ bool, fair: (Task, State, Transition) $\mathrel { - } >$ bool)

To reason about the behavior of executable code, Shipwright provides a specification for its low-level runtime, whose job is to invoke the event handler functions of an executable implementation. This boils down to specifying the network, which involves the following: digital signatures are unforgeable, real time eventually advances, all nodes eventually receive timeouts, and all messages are delivered by a deadline after stabilization.

Figure 4 shows a fragment of our network specification. The Init and Next functions say that the network runtime invoked the implementation‚Äôs Zero and Run functions, respectively, or that an adversary injected a network message with Fault. Transition includes Receive and Transmit events from the executable implementation, as well as logical transitions such as network stabilization (described below) and clock ticks.

Fair captures Shipwright‚Äôs core liveness assumptions. In particular, Shipwright assumes a partial synchrony model where the network will eventually stabilize, at which point all messages and timeouts will be delivered by at most the network delay. With that model in mind, Fair in the network specification says that the network will eventually stabilize, that all messages and every timeout will be eventually delivered, and that all clock ticks will eventually happen. For instance, the MessageF(m) task represents message m being delivered; the FairMessage(st, tr, mevt) predicate states that the message event mevt (which includes some message m as well as its metadata) must be in the set of sent messages in state st, but not yet in the set of delivered messages, and that the transition tr must be the delivery of mevt.

The network specification‚Äôs Next function also captures Shipwright‚Äôs assumptions about signatures (not shown in Figure 4). Namely, Shipwright states that all messages sent over the network have been signed with the sender‚Äôs key. This captures the fact that the runtime will sign messages on transmission, and check signatures on receive. This also allows the developer to reason about signatures by reasoning about the set of messages sent by honest nodes.

Shipwright‚Äôs network specification allows developers to reason about the network in terms of arbitrary Message types, but the lowest-level network implemented by the Shipwright runtime requires that messages be sequences of bytes‚Äîthat is, Message $\mathbf { \sigma } = \mathbf { \sigma }$ seq<bv8> in Dafny. Developers can use a verified encoding/decoding library to show a refinement between the network operating on byte-sequence messages and an abstracted network operating on higher-level message types defined in Dafny.

Semantics of a specification. Shipwright defines an execution to be an infinite sequence of a system‚Äôs states $s$ and transitions $T$ , denoted $( ( s _ { n } , t _ { n } ) ) _ { n \in \mathbb { N } } = ( ( s _ { 0 } , t _ { 0 } ) , ( s _ { 1 } , t _ { 1 } ) , \ldots )$ where all $s _ { i } \in S$ aùëánd $t _ { i } \in T$ . A((ùë†sùëõy,sùë°tùëõe))mùëõ‚ààs‚Ñïpe=ci(fi(cùë†a0,t iùë°0o)n, (Sùë†p1,eùë°c1)c,a‚Ä¶p)tures a set ùë†oùëñf‚ààexùëÜecutioùë°ùëñns‚ààoùëáf interest. The syntax consists of a task set $F$ along with four functions Init $\dot { \cdot } s  \mathsf { b o o l } , \mathsf { N e x t } : s \times T  S$ , Inv $S \times T  { \mathsf { b o o l } }$ , and Fair $F \times S \times T  { \mathsf { b o o l } }$ .

A‚à∂n ùëÜex√óecùëáut‚Üíion conforms to ‚à∂a sùêπp√óecùëÜif√óicaùëátio‚Üín when (1) $\mathrm { I n i t } ( s _ { 0 } )$ holds; (2) for all , $\mathsf { N e x t } ( s _ { i } , t _ { i } ) = s _ { i + 1 }$ and (3) ${ \mathrm { I n v } } ( s _ { i } , t _ { i } )$ h(oùë†l0d); and (4) for all $f , i ,$ ùëñ there (eùë†ùëñx,iùë°sùëñt) a= $j \geq i$ where $\mathsf { F a i r } ( f , s _ { j } , t _ { j } )$ .

A refinemenùëìt ùëñfunction $r _ { C , A }$ maùëóp‚â•s ùëñsome set of(ùëìst,aùë†tùëó ,eùë°s )and transitions to another set oùëüfùê∂ ,sùê¥tates and transitions $r _ { C , A } : S _ { C } \times$ $T _ { C }  S _ { A } \times T _ { A }$ . We say that some concrete specificatùëüion r‚à∂efùëÜine√ós sùëáùê∂om‚Üíe ùëÜaùê¥bs√ótrùëáaùê¥ct specification if for all concrete executions which conform to the concrete specification, applying the refinement function elementwise on the execution produces an execution which satisfies the abstract specification.

A system‚Äôs trace is the sequence of transitions $\left( t _ { n } \right)$ and ignores the states. A modular refinement $\overline { { r _ { C , A } } }$ is a t(rùë°ùëõa)ce refinement exported by modules that hides the result of the refinement for $S _ { A }$ , leaving only the result for $T _ { A }$ .

Terminal specifications. It is important for the developer to audit the top-level specification used in Shipwright‚Äôs refinement proof to ensure that the machine-checked proof is meaningful because the specification captures how the developer expects the system to behave. However, the general class of specifications presented above can be challenging to audit for two reasons. First, the invariant in a specification

odule Network {   
ghost function Next(...): (State, Trans) $\mathrel { - } >$ State   
ghost function Init(...): State $\mathrel { - } >$ bool   
ghost function Invar(...): (State, Trans) $\mathrel { - } >$ bool   
datatype MessageEvent<Message> $\mathbf { \tau } = \mathbf { \tau }$ | MessageEvent(created: nat, dest: NodeID, src: NodeID, msg: Message)   
datatype Task $\mathbf { \tau } = \mathbf { \tau }$ | TickF | StabilizeF MessageF(mevt: MessageEvent<Message>) | TimeoutF(tevt: TimeoutEvent)   
datatype GlobalTrans $\mathbf { \Sigma } = \mathbf { \Sigma }$ | Stabilize | Tick   
datatype LocalTrans<Message, Argument> = | Noop Fault(tx: API.EventResponse<Message>) Call(arg: Argument) | Timeout(time: nat) | Receive(created: nat, src: NodeID, msg: Message)   
datatype Trans<Message $\scriptstyle ( = = )$ , Argument> $\mathbf { \Sigma } = \mathbf { \Sigma }$ | Global(g: GlobalTrans) | Local(dest: NodeID, l: LocalTrans<Message, Argument>)   
ghost predicate Fair(task: Task, st: State, tr: Trans) { if task.MessageF? then FairMessage(st, tr, task.mevt) else if task.TimeoutF? then FairTimeout(st, tr, task.tevt) else if task.TickF? then tr $\scriptstyle = =$ Global(Tick) && TickOk(st.sched, |st.nodes|) else if task.StabilizeF? then tr $\scriptstyle = =$ Global(Stabilize) && !st.sched.stable else false   
}

constrains reachable states and transitions, which can be problematic if, for example, an invariant says that certain messages cannot be delivered in a particular state. Second, the general fairness condition allowed by our specification can, in principle, imply safety constraints, so that the safety of a system depends on its liveness, which again makes it difficult to audit the specification.

Shipwright addresses this challenge by introducing the notion of a terminal specification, taking inspiration from Lamport‚Äôs machine-closed specifications of weak fairness [9]. Terminal specifications must have a trivially true invariant and must only specify weak fairness properties. The developer supplies Init and Next as before, as well as a WeakFair in place of Fair. Shipwright then translates this to an ordinary specification as follows: Init Init , $\mathsf { N e x t } ( s , t ) = \mathsf { N e x t } ( s , t )$ , ${ \mathrm { I n v } } ( s , t ) =$ true, and

$$
\mathsf { F a i r } ( f , s , t ) = ( \mathsf { W e a k F a i r } ( f , s , t ) \vee ( \forall t , \neg ( \mathsf { W e a k F a i r } ( f , s , t ) ) ) .
$$

Lamport shows that such weakly-fair specifications cannot imply additional safety constraints [9].

Note that Shipwright only requires terminal specifications only at the top and bottom layers of refinement; internal refinement layers can use the full generality of specifications, including invariants and arbitrary fairness conditions. This allows us to avoid quantifiers in intermediate layers of the refinement proof, improving Dafny‚Äôs verification efficiency.

At the bottom level, Shipwright interprets executable code as a terminal specification. Executable code has no invariant, and the network runtime associated with executable code only states weakly fair liveness constraints, making the specification of executable code also terminal.

Composition. To enable the developer to reason about the composition of sub-protocols, such as the four sub-protocols comprising a view of PBFT, or the composition of PBFT‚Äôs views, Shipwright provides a parallel composition operator, $\otimes$ . Parallel composition intuitively represents executing two s‚äóystems in parallel without any communication between them, and the semantics are simply the concatenation of the semantics of the components (so the new semantics are on $S _ { 1 } \times S _ { 2 }$ , $T _ { 1 } \times T _ { 2 }$ , and $F _ { 1 } \cup F _ { 2 }$ ).

function Split<Value, $\mathsf { S i g } \mathrm { > }$ ( ev: API.Event<Message, Argument, $\mathsf { S i g } \mathrm { > }$ , priv: Option.T<Metadata>) : map<nat, View.Argument<Value, Sig>>   
{ if ev.Timeout? then map[] else if ev.Call? then map[0 : $\mathbf { \tau } = \mathbf { \tau }$ Proposer.Argument(pay := Proposer.ClientPayload(val : $\mathbf { \tau } = \mathbf { \tau }$ ev.arg.val))] else if ev.Receive? && ev.msg.1.I1? && ev.msg.1.1.I0? && ev.msg.1.1.0.I1? && priv.Some? && priv.v.InView? && priv.v.meta.Receive? && priv.v.meta.cert.Some? then var nextview : $\mathbf { \tau } = \mathbf { \tau }$ ev.msg. ${ \mathrm { ~  ~ \theta ~ } } + { \mathrm { ~  ~ 1 ~ } }$ ; var cert : $\mathbf { \tau } = \mathbf { \tau }$ priv.v.meta.cert.v; map[nextview : $\mathbf { \tau } = \mathbf { \tau }$ Proposer.Argument(pay : $\mathbf { \tau } = \mathbf { \tau }$ Proposer.NewViewPayload(prev : $\mathbf { \tau } = \mathbf { \tau }$ cert))] else map[]   
}

To allow the sub-protocols to interact, developers can interpose on events to trigger additional calls on sub-protocols. For example, consider the composition of an infinite sequence of views in PBFT. The developer needs to specify that, when one view completes, the next view starts. To do this, the developer supplies a Split function (Figure 5) that determines what additional Call events must be delivered. This Split function captures two important cases. First, if the overall PBFT state machine receives a Call, it forwards it to view 0 to kick off the overall protocol execution. Second, if some view receives a message, and that message happens to conclude that view, then Split kicks off the next view.

Shipwright also allows the developer to strengthen a specification by imposing an additional protocol invariant on their transitions $P : T _ { 1 } \times T _ { 2 }  { \mathsf { b o o l } }$ (i.e., the invariant of the new system requùëÉir‚à∂esùëá1all√ó oùëáf2 $\mathrm { I n v } _ { 1 } ( s _ { 1 _ { i } } , t _ { 1 _ { i } } )$ , $\bar { \mathrm { I n v } } _ { 2 } ( s _ { 2 _ { i } } , t _ { 2 _ { i } } )$ , and $P ( t _ { 1 _ { i } } , t _ { 2 _ { i } } )$ to hold for all ). As before1,(ùë†w1ùëñe, ùë°c1ùëña)n con2s(iùë†2dùëñe, rùë°2ùëña)n abstrùëÉa(cùë°1t ,pùë°r2ùëño)- tocol, betweenùëñtwo abstract systems, and the corresponding concrete protocol, between two concrete systems. Because Shipwright‚Äôs liveness conditions Fair are unconditional, parallel composition is purely syntactic: we do not need to prove any additional verification conditions to establish liveness when composing, even when adding a protocol invariant.

Recall that modules in Shipwright export not $r _ { C , A }$ directly but rather a trace refinement $\overline { { r _ { C , A } } }$ . An advantage oùëüfùê∂ ,eùê¥xporting only a trace refinement is it may be simpler than the state refinement: the refinement only needs to be exposed to module clients only when the abstract state changes, which may be much rarer than changes in the concrete states. Protocol invariants are also function of transitions rather than states, which allows reasoning about them without considering the details of the sub-protocol states.

For example, in order to reason about timely delivery of quorums, the abstract object of the prepare module must maintain the latest time any honest sender transmitted a prepare message. This invariant is internally maintained by the module by computing the maximum over all the transmission times of the prepare messages on the network. However, this abstract variable is set by only one transition‚Äîthe transition where the last honest node sends the message‚Äîwhich only needs to inspect the current real time.

Signatures. Shipwright‚Äôs support for invariants in a specification, through the Invar predicate, allows the developer to abstractly reason about signed messages and stapled signatures. For example, in PBFT, a view-change message requires the sender to include signed prepare messages from a quorum of nodes to justify advancing the view. Shipwright‚Äôs network model allows the developer to capture this fact, by reasoning about signatures and stapled messages. However, reasoning at this low level of abstraction‚Äîdirectly in terms of signed messages‚Äîcan be cumbersome. Instead, a developer can use an invariant to state that, if a view-change message is received, then a quorum of other nodes must be in a state that agrees with this view change. This frees the developer from explicitly reasoning about signatures and allows reasoning directly about the state of other nodes and the overall system. To enable this reasoning, the developer will have to prove that this invariant is implied by the low-level signatures, as part of a refinement proof.

# 3.3 Proofs

The top-level theorem we wish to prove is a refinement from the entire implementation to a specification of a simple abstract object. Figure 1 illustrates the general proof strategy. We start by refining the implementation into the parallel composition of many modules, each implementing a subprotocol.

Next, for each module, we prove that the implementation refines a corresponding abstract object. Finally, we refine the parallel composition of the modules‚Äô now abstract objects into our top-level simple abstract object.

Liveness. One particular challenge lies in proving facts about liveness in a way that avoids reasoning about infinite executions. Composition through protocol invariants allow us to combine smaller theorems and thus arguments about liveness. For individual specifications themselves, however, we still need an effective means to reason about liveness. In particular, our refinement theorems are about infinite executions, which are hard for Dafny to reason about. To optimize reasoning, we introduce reasoning principles which only need to consider two states and transitions at once.

For safety properties, these verification conditions require showing the compatibility of $r _ { A , C }$ with the Init, Next, and Inv functions, along with a refinùëüeùê¥,mùê∂ent-local invariant $\bar { \mathbf { I n v } _ { \mathsf { f } } }$ . In particular, it must be shown that Init implies $\bar { \mathbf { I } } \mathsf { n } \mathsf { v } _ { \mathsf { f } }$ , and that Next preserves Invf. (This is similar to how many systems already prove safety refinements, such as IronFleet.)

ghost predicate MeasuresFor<State, Transition, Task, Meas>( fair: (Task, State, Transition) $\Rightarrow$ bool, less: Order.T<Meas>, task: Task, st: State, trans: Transition, mu: Meas, mu‚Äô: Meas)   
{ fair(task, st, trans) || less(mu‚Äô, mu)   
}

A key novelty in Shipwright is that it supports a similar style of verification conditions for liveness in addition to safety. Specifically, proving liveness in our new verification conditions involves introduction of completion measures, as shown in Figure 6. Every task in the task set is associated with a completion measure $m$ , where $m$ is a member of a set $O _ { < }$ equipped with a well-foùëöunded paùëörtial order $\angle .$ At each sùëÇt<ate of the execution, the set of tasks is mappe<d to a set of measures by the completion variant Var $F \times S \times T $ $O _ { < }$ . The programmer must then define a com‚à∂pleùêπti√óonùëÜ v√óarùëáian‚Üít ùëÇm<apping the concrete measure to an abstract measure with the following property.

Consider any state $s _ { i ; \ l }$ , transition $t _ { i }$ , and measures $\mu _ { i } , \mu _ { i + 1 }$ . Suppose that, for all ùëñconcrete tasùë°ùëñks $f _ { C }$ , it is eithùúáeùëñr, ùúátùëñh+1e case that $\mu _ { i + 1 } ( f _ { C } , s _ { i } , t _ { i } ) < \mu _ { i } ( f _ { C } , s _ { i + 1 } , t _ { i + 1 } )$ or $F _ { C } ( f _ { C } , s _ { i } , t _ { i } )$ holds. Theùúánùëñ+i1t ùëìùê∂m,uùë†ùëñs,t )be t<he ùúácùëña(sùëìeùê∂  tùë†ùëñh+a1t,, f+o1)r ev ùêπyùê∂(aùëìbùê∂s,tùë†rùëñ,aùë°cùëñ)t task $f _ { A }$ , either $\mathsf { V a r } ( r _ { C , A } ( s _ { i } , t _ { i } ) , f _ { A } ) < \mathsf { V a r } ( r _ { C , A } ( s _ { i + 1 } , t _ { i + 1 } ) , f _ { A } )$ or $F _ { A } ( f _ { A } , r _ { C , A } ( s _ { i } , t _ { i } ) )$ ho(ùëülùê∂d,.ùê¥

(Bùëìeùê¥c,aùëüuùê∂,sùê¥e(ùë†Vùëñ,aùë°rùëñ )m) ust be non-negative, this condition is strong enough to imply liveness. Moreover, as with safety properties, it mentions not an infinite execution but rather two adjacent pairs of states and transitions $s _ { i } , s _ { i + 1 } , t _ { i } , t _ { i + 1 }$ .

As an example, consider the voting suùë†ùëñb, -ùë†ùëñp+r1o, tùë°ùëño,cùë°ùëño+l1of PBFT, which is used for both prepare and commit messages. Figure 7 shows a fragment of the specification for this subprotocol, defining three kinds of liveness tasks: stabilization of the network (StabilizeF), clock ticks (TickF), and completion of voting as seen by node id (DoneF(id)).

module EphemeralQuorum { datatype Task $\mathbf { \Sigma } = \mathbf { \Sigma }$ | StabilizeF | TickF | DoneF (id: NodeID) ghost predicate Fair(task: Task, st: State, tr: Trans) { if task.StabilizeF? then !st.stable $\scriptstyle \Rightarrow$ tr.Stabilize? else if task.TickF? then tr.Tick? else assert task.DoneF?; && Honest(st, task.id) && st.decision.Unanimous? && !st.nodes[task.id].v.done $\Rightarrow$ && tr.Done? && tr.id $\scriptstyle = =$ task.id }   
}

To prove that this voting sub-protocol implementation always reaches DoneF, the developer can define a measure counting down towards DoneF being reached. In this example, the measure can be a tuple $( | H ( s ) | , \mu ( { \mathrm { v o t e } } ( i ) ) )$ , where $H ( s )$ is the set of honest participan(t|sùêªw(ùë†h)i|,cùúáh(tvhoitsen(ùëño))d)e has notùêªh(eùë†a)rd from yet, $i$ is picked arbitrarily but deterministically from $H ( s )$ , and ùëñ $( i )$ is the task that completes when the node rùêªe(cùë†e)ives a votet(eùëñ)message from node . Figure 8 shows the Dafny code defining this measure. Tùëñ he measures for the StabilizeF and TickF tasks are inherited from the network, but the measure for the DoneF task is a tuple consisting of the count of not-yet-voted nodes pending and the measure until we receive a vote from one of the pending nodes.

After defining this measure, the developer simply proves that, for every task task, every transition t from some state st that satisfies the invariant Invar(st, t) will either decrease the measure for task or achieve the liveness condition required by Fair(task, st, t). The key benefit of the taskbased completion measure approach is that the Shipwright framework proves that this condition is sufficient to establish liveness of all tasks in all possible execution traces, without forcing the developer to reason about infinite traces.

Composition. A key benefit of Shipwright‚Äôs composition operators for code and specifications is that Shipwright pro

ghost function Measure<Value, Carrier>( less: Order.T<Carrier>, task: Abstract.Task, st: Concrete.State<Value>, trans: Concrete.Transition<Value>, mu: Concrete.Task $$ Carrier) : (nat, Carrier)   
{ if task.StabilizeF? then (0, mu(Concrete.StabilizeF)) else if task.TickF? then (0, mu(Concrete.TickF)) else assert task.DoneF?; var pending : $\mathbf { \tau } = \mathbf { \tau }$ MapNodesPending(st.nodes, task.id); ( Partition.Count(pending), mu(Concrete.MessageF(task.id, Seq.Find(pending))) )   
}

vides generic refinement composition theorems. In particular, if the developer has executable implementations of sub-protocols $C _ { 1 }$ and $C _ { 2 }$ , and proves refinement of those implementationùê∂s1to abstùê∂r2act specifications $A _ { 1 }$ and $A _ { 2 }$ respectively, then Shipwright‚Äôs composition theoùê¥rem p rùê¥oves that the executable (synchronous-dispatch) composition $C _ { 1 } \otimes C _ { 2 }$ refines the parallel composition of the specifications $A _ { 1 } \otimes A _ { 2 }$ . Similarly, Shipwright provides a composition theorùê¥em‚äófùê¥or specifications, such that if $A _ { 1 }$ refines $B _ { 1 }$ and $A _ { 2 }$ refines $B _ { 2 }$ , then $A _ { 1 } \otimes B _ { 1 }$ refines $B _ { 1 } \otimes B _ { 2 }$ .

Signatures. One key benefit of Shipwright‚Äôs signature model is that it allows Shipwright to preserve simple reasoning principles for network messages‚Äînamely, if a message is sent, the developer can soundly assume that the message will be eventually processed by the recipient. Ensuring this can be tricky in the presence of stapled signatures in a message, because the receiving node will check the stapled signatures and reject the message if any of the signatures do not verify. For instance, this was the issue behind the bug described in $\ S 1$ , where a node inadvertently included signatures from the wrong view, causing the recipient to reject the signatures as invalid. To preserve the simple reasoning principles about network message liveness, Shipwright requires that every transmitted network message must have valid signatures for all stapled messages. This helped us catch the aforementioned stapled signature liveness bug: in the absence of this check at transmit time, the sender would have been allowed to send messages with invalid stapled signatures, causing the receiver to drop such messages and thus violate liveness.

null represents the absence of a valid command, and the logical command sequence ignores null values as gaps.

We implement and verify a single iteration of this subprotocol, which we call broadcast. In broadcast, a client sends a request to all servers. The servers then execute a series of views until broadcast returns a (possibly-null) value.

Each view is an attempt to terminate the protocol and is parameterized by a leader and a timeout. Broadcast terminates once (1) the network is stable, (2) the timeout is sufficiently larger than the network delay, and (3) the leader is honest. Liveness thus hinges on the fact that (1) the network always eventually stabilizes, (2) the timeout increases exponentially, and (3) the leaders rotate in a cyclic order.

# 4.1 Top-level theorem

As we describe in $\ S 3$ , our concrete state machine models the partially-synchronous network instantiated with our PBFT implementation. Figure 9 describes our abstract state machine, which specifies correct behavior by encoding three properties of interest:

‚Ä¢ agreement, the property that all honest nodes with a value agree on the same value (which is st.reg);   
‚Ä¢ termination, the property that all honest nodes eventually terminate with some value (encoded by the task TerminateF); and   
‚Ä¢ validity, the property that if the client and first leader are honest, if the system is stable, and if a request was submitted early enough, then the system eventually agrees on the client‚Äôs request (encoded with st.send and the task SetF).

(Note that if either the client or the first leader are malicious, agreement holds but not validity, and this is represented by the Set transition allowing an attacker‚Äôs value into st.reg.)

In order to connect the concrete state machine and the abstract state machine, we need to prove a trace refinement theorem between the concrete transitions and abstract transitions. The trace refinement hides the network and code states, which are quite complex. Instead, the theorem exposes the mapping between the concrete and the abstract transitions. Among other things, this function maps a local call to an honest client to the transition which sets st.send; it also maps the receipt of a quorum of commit messages to the Terminate transition.

# 4 PBFT Case Study

To demonstrate Shipwright‚Äôs capacity for complexity, we implement part of the PBFT protocol. Specifically, the PBFT protocol establishes an ordered sequence of commands in response to client requests to execute commands. To do this, the protocol attempts to agree on each command in the sequence. If it succeeds, the command is appended to the sequence. Otherwise, the special value null is appended.

We state the following top-level theorem in Dafny.

Theorem 1. There exists a modular refinement $\overline { { r _ { C , A } } }$ between our PBFT implementation and our abstract speùëücùê∂i,fùê¥ication.

# 4.2 Decomposition strategy

In order to make our proof verification overhead tractable to Dafny, we decompose the entire program as follows. First, we decompose the client request from the rest of broadcast.

module Broadcast { ghost predicate Init(st: State) { && st.send.None? && st.reg.None? && forall i: nat | $\mathrm { ~ i ~ } <$ |st.nodes| && st.nodes[i].Some? :: !st.nodes[i].v.commit }

datatype Trans<Value> $\mathbf { \tau } = \mathbf { \tau }$ | Send(v: Value)| Set(faultv: Option.T<Value>)| Terminate(id: nat, val: Option.T<Value>)

predicate Validity(st: State) { && Honest(st, st.client) && Honest(st, st.leader0) && st.stable && st.clock $^ +$ ((st.delay $\mathbf { + } \mathbf { \beta } \mathbf { \uparrow }$ ) $^ +$ (st.delay + 1)) < st.deadline $^ +$ st.duration0   
}

function Next(st: State, tr: Trans) : State { if tr.Send? && st.send.None? && HonestSend(st) then st.(send : $\mathbf { \tau } = \mathbf { \tau }$ Option.Some(tr.v)) else if tr.Set? && st.reg.None? && Validity(st) then st.(reg : $\mathbf { \tau } = \mathbf { \tau }$ Option.Some(st.send)) else if tr.Set? && st.reg.None? && !HonestSend(st) then st.(reg : $\mathbf { \tau } = \mathbf { \tau }$ Option.Some(tr.faultv)) else if tr.Terminate? && st.reg.Some? && Honest(st, tr.id) then var node : $\mathbf { \tau } = \mathbf { \tau }$ Option.Some(Node(true)); var nodes : $\mathbf { \tau } = \mathbf { \tau }$ st.nodes[tr.id : $\mathbf { \tau } = \mathbf { \tau }$ node]; st.(nodes : $\mathbf { \tau } = \mathbf { \tau }$ nodes) else } datatype Task $\mathbf { \Sigma } = \mathbf { \Sigma }$ | SetF | TerminateF(id: nat) | StabilizeF | TickF ghost predicate Fair(task: Task, st: State, tr: Trans) { if task.SetF? then Validity(st) && st.send.Some? $\Rightarrow$ tr.Set? else if task.TerminateF? then && st.stable && st.reg.Some? && Honest(st, task.id) && !st.nodes[task.id].v.commit $\Rightarrow$ tr.Terminate? && tr.id $\scriptstyle = =$ task.id else } $\}$

Second, we decompose the broadcast service to an infinite map of view implementations. Third, we decompose the views themselves into their constituent messages as in Figure 1. Figure 10 illustrates this strategy.

Our proof broadly follows the structure of the decomposition. We create an abstraction for each individual message type and prove that our sub-protocol for that message type refines into the abstraction. We are able to reuse modules where implementations are identical. For instance, the prepare and commit sub-protocols have identical implementations; so do the client reqest and the pre-prepare sub-protocols. For each message type, we prove liveness properties by constructing measures which rely on the underlying liveness of message delivery as well as by counting down the remaining messages yet to be received. Figure 7 illustrates the measure for prepare and commit.

![](images/6f727fb98a763ad02630f0e29e81c4427cbbc0032aaabc85af39622687d8583d.jpg)  
Figure 9: Fragment of top-level specification for PBFT prototype.   
Figure 10: A diagram of the refinement proof‚Äôs compositional structure; Figure 1 shows the detailed structure of the refinement between a single view implementation and a single graded consensus spec.

Once we have atomic, per-message-type refinements, we combine them together using Shipwright‚Äôs composition operators, which are liveness-preserving. We build a view out of PBFT‚Äôs message types. Views guarantee that view-change quorums are always eventually delivered once all honest nodes have started the view. In addition, if the validity conditions hold, then the view guarantees that commit quorums are also always eventually delivered.

We build the broadcast service out of an infinite sequence of views. The invariants on the state machine transitions ensure that whenever a quorum of view-change messages are received in some view, the timeouts for the following view immediately begin. Figure 5 illustrates the code which implements this. This concrete constraint here is mapped to the corresponding abstract constraint via the view‚Äôs trace refinement theorem. At the abstract level, it is then possible to prove that the infinite sequence of views refine the broadcast service by incorporating into the measure (1) the concrete measure representing stabilization, (2) the difference between the current view timeout and the timeout of the first view long enough to accommodate the network delay, and (3) the difference between the current view and the first view with an honest leader. Before all three conditions are met, we rely on the liveness of view-change quorums. Once they are met, we proceed to terminate the protocol.

Finally, we show that coupling the client with the broadcast service refines broadcast. Proving termination here requires composing the termination of the abstract client proposal with the termination of the broadcast service.

Limitations. There are two limitations in our current PBFT prototype, stemming from the fact that our prototype implements just one iteration of PBFT instead of an append-only log over multiple entries. First, our top-level theorem does not currently capture the reply messages sent to clients once a majority of honest nodes has seen a commit-quorum. (A client needs $f + 1$ signed replies to conclude that the request was sucùëìces+sf1ul.) Second, in order to state and prove an end-to-end liveness property, we need to allow for multiple iterations of broadcast itself, since a malicious initial leader can force the view to commit with null. We expect both of these limitations would be addressed by extending our prototype to agree on multiple entries in PBFT.

# 4.3 Bugs Found

We found several bugs during the verification process.

As described in $\ S 1$ , we discovered a liveness bug where, when sending a new-view message, a node would attach signatures from an incorrect previous view. Attaching the incorrect signatures caused the receiver to reject otherwise valid messages, preventing the start of the next view.

We caught another two bugs related to certificates in which we would count signatures incorrectly. The implementation accepted certificates with too few signatures, which could allow a malicious node to convince an honest node to accept any value. We were able to catch this bug because our model of cryptography does not assume that noncryptographic message validation is correct.

Another liveness bug relates to timekeeping. In some cases, a node would start its timer too early and thus time out of the next view prematurely. No view would complete in time, even after the system had stabilized.

Finally, we caught another bug also related to timeouts. A node sends a view-change message when either the view times out or when it receives $f { + } 1$ votes. Crucially, the node can only send a view-changeùëìmessage on exactly one value. An early implementation sent view-change messages on both of these events without checking that their values were the same. Depending on the implementation of the commit messages, this may have resulted in a safety violation as a quorum of null view-change votes could have coexisted with a quorum of commit messages.

# 5 Shipwright Implementation

Figure 11 summarizes the implementation of Shipwright and the PBFT case study, and their breakdown in terms of major components. The Shipwright framework consists of roughly 13300 lines of code, of which around $10 \%$ are trusted. The trusted parts include the definition of state machines and the network in Dafny, and the Go implementation of the Shipwright runtime. The PBFT case study consists of roughly 31200 lines of code, of which just under 270 lines of code are trusted‚Äînamely, the top-level specification. The rest of the PBFT implementation and proofs are not trusted. Aside from our code, we also trust the implementations of systems components such as the Dafny and Go compilers, the Go libraries and runtime, the OS kernel, the networking stack, the hardware, etc.

Figure 11: The number of lines of code necessary to implement the trusted and untrusted portions of our implementation. Total figures are in bold.   

<html><body><table><tr><td>Component</td><td>Trusted</td><td>Untrusted</td><td>Total</td></tr><tr><td>Shipwright framework</td><td>1351</td><td>12006</td><td>13357</td></tr><tr><td>utilities</td><td>9</td><td>842</td><td>851</td></tr><tr><td>statemachines</td><td>650</td><td>2271</td><td>2921</td></tr><tr><td>environment model</td><td>309</td><td>0</td><td>309</td></tr><tr><td>composition</td><td>0</td><td>8893</td><td>8893</td></tr><tr><td>Go runtime</td><td>383</td><td>0</td><td>383</td></tr><tr><td>PBFT case study</td><td>266</td><td>30872</td><td>31138</td></tr><tr><td>top-level spec</td><td>266</td><td>0</td><td>266</td></tr><tr><td>sub-protocol specs</td><td>0</td><td>10337</td><td>10337</td></tr><tr><td>sub-protocol proofs</td><td>0</td><td>18647</td><td>18647</td></tr><tr><td>implementation</td><td>0</td><td>1888</td><td>1888</td></tr><tr><td>Total</td><td>1617</td><td>42878</td><td>44495</td></tr></table></body></html>

The Shipwright framework is divided into two main libraries. The first library defines foundational concepts such as state machines, executions, liveness, and trace refinement. It includes reasoning principles, proven sound, that enable safety and liveness reasoning with measures. It also describes how to compose state machines with the $\otimes$ operator and how to strengthen protocol invariants. This lib‚äórary describes concepts that are independent of particular assumptions about the environment under which a system operates.

The second library, which depends on the first, specializes the state machines to our environment. This includes our model of partial synchrony and the security of digital signatures. It defines the API (Figure 2) against which an application developer must write code.

It also establishes how code can be soundly transformed under our formalization of state machines. The library contains code implementing synchronous dispatch and specifies how dispatch functions correspond to the protocol invariants between state machines. At the lowest level, the library contains (untrusted) routines for producing canonical byte encodings of network messages and a proof that a corresponding refinement follows from these encodings. It was useful to prove these refinements sound in a generic manner‚Äî not only to ease proof reuse, but also so that we could hide complex compositional definitions from the Dafny verifier in a principled manner in order to speed up verification.

We provide a trusted implementation of the runtime in the Go programming language. This runtime implements our untrusted code‚Äôs server environment. It uses the standard libraries time, net, and crypto/ed25519 to implement timing, networking, and cryptography, respectively.

In addition to the main components, we provide library code for a variety of utilities for transforming Dafny collections such as sets, sequences, and infinite maps. These libraries allow us to manage quantifier instantiation, which has a significant impact on Dafny verification performance. We also implement a library specialized for efficient automated reasoning about quorums.

Limitations. The proof of the refinements in the PBFT prototype to and from the broadcast service are works-inprogress and are not yet complete. We have not yet proven correct all of the trace properties required for safety and liveness of the end-to-end specification.

# 6 Evaluation

Our evaluation attempts to answer the following questions.

‚Ä¢ How does our implementation perform, end-to-end? ‚Ä¢ How does our implementation preserve liveness when there are attacks by participants or on the network?

We evaluate our PBFT implementation on a virtual machine with 24 cores, 6 GB of RAM, a Intel Xeon E5-2699 CPU, and running Ubuntu 22.04. All of the PBFT nodes run on the same virtual machine and connect to each other via localhost. Each node is a Linux process, and the nodes are fully connected to each other through all-to-all TCP connections. Nodes send messages to themselves using an asynchronous Go goroutine. Every $2 5 0 \mathrm { m s }$ , we deliver a timeout event to a node with the current time. We set the initial PBFT view timeout to 1s. We use Dafny version 4.9.1 and Go version 1.24.2.

# 6.1 Common Case

To evaluate common-case performance of our PBFT prototype, we ran a PBFT system consisting of $3 f + 1$ nodes, varying $f$ from 1 to 10. When the system is star3tùëìed,+o1ne node immediaùëìtely broadcasts a client request to all other nodes. Figure 12 reports the time (in ms) it takes for this node to receive $f + 1$ signed replies over 10 trials.

In this scenario, there are no failures, so the time includes five message types: the client request, the pre-prepare, prepare, and commit messages, and the signed service response. Thus there are $1 + 2 { \left( 2 f + 1 \right) } + 2 { \left( 2 f + 1 \right) } ^ { 2 }$ total messages on the critical path (co1u+n2t(i2nùëìg +m1e)ss+a2g(e2sùëìfr+o1m) nodes to themselves).

# 6.2 Performance Under Failure

To measure the effects of failure on the system liveness and end-to-end performance, we simulate three scenarios representing various attacks on $3 f + 1 = 7$ nodes (setting $f = 2$ ). Since our implementation o3nùëìly+co1ve=rs7 agreement on aùëìsin=g2le value in the PBFT protocol (as opposed to many values forming an entire replicated log), we consider scenarios where we will obtain a non-null value.

In the first case, we consider a network under some denialof-service attack. In order to prevent the system from making progress, an attacker forces the network to drop all commit messages from view 0. The network recovers shortly afterwards. We expect the system to time out, enter view 1, and for the view 1 leader to recover with the correct value.

![](images/e002b05670a2b1ebe86247aa58dcf98da69e1893ca3677a8128ba105dfe31f33.jpg)  
Figure 12: End-to-end latency of a client request in a system with $N = 3 f { + } 1$ nodes, varying values of $f$ from 1 to 10 for 10 iterations each. TùëÅhe=sc3aùëìtt+e1r plot represents the raw dùëìata while the line plot represents averages. The labels on the $\mathbf { y }$ -axis correspond to the averages.

![](images/01dc488496151484a9d3148337349bdb40da5f5d5daa55aa3a2e3d1ef550d1af.jpg)  
Figure 13: End-to-end latency of a client request under a variety of scenarios representing different attacks, given $f = 2$ . In the first scenario, an attacker intermittently prevents the deliveryùëì o=f c2ommit messages in view 0, but the system recovers shortly afterwards. In the second, the attacker controls two nodes. In the last two scenarios, both the network attack and node corruption take place (for one and two nodes, respectively).

In the second case, we suppose that $f$ of the nodes, which are neither the client nor the view-0 lùëìeader, are malicious. This node sends pre-prepare (and the attached new-view), prepare, commit, and view-change messages on the incorrect value. Under this attack, we expect the system to commit the correct client value in view 0.

In the third case, we consider both failures simultaneously. We explore scenarios in which the first $f$ leader nodes after view 1 are malicious. In all cases, we eùëìxpect the system to recover in the first view with an honest leader the malicious ones (i.e., views 2 and 3, respectively).

Figure 13 illustrates our results. As expected, our clients experience an end-to-end latency consistent with the sizes of views. In particular, when the network is faulty, our clients receive a response at either 2s, 4s, or 8s, depending on how many nodes are malicious. Moreover, when the network is not faulty, end-to-end latency is unaffected, as we expect.

# 7 Conclusion

We design and implement Shipwright, a framework for proving liveness of distributed systems with Byzantine participants. Shipwright allows developers to prove that implementations of complex protocols, like PBFT, refine a simpler high-level specification, by introducing tools to manage the burden of proof. First, developers can decompose larger protocols into smaller ones in a liveness-preserving manner. Second, completion measures enable them to prove liveness properties about whole executions via proof obligations over pairs of states. Third, Shipwright allows developers to prove that their implementation uses digital signatures correctly (e.g., in message stapling) without resorting to low-level cryptographic details. We use Shipwright to verify our executable implementation that agrees on a single log entry in the PBFT protocol.