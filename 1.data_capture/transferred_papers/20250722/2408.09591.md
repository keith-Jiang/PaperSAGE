# Pre-Assignment Problem for Unique Minimum Vertex Cover on Bounded Clique-Width Graphs

Shinwoo $\mathbf { A } \mathbf { n } ^ { 1 }$ , Yeonsu Chang2, Kyungjin Cho1, O-joung Kwon2,3\*, Myounghwan Lee2, Eunjin $\mathbf { O h } ^ { 1 }$ Hyeonjun Shin1

1 Department of Computer Science and Engineering, POSTECH, Pohang, South Korea 2 Department of Mathematics, Hanyang University, Seoul, South Korea 3 Discrete Mathematics Group, Institute for Basic Science (IBS), Daejeon, South Korea shinwooan $@$ postech.ac.kr, yeonsu $@$ hanyang.ac.kr, kyungjincho $@$ postech.ac.kr, {ojoungkwon, sycuel}@hanyang.ac.kr, {eunjin.oh, tlsguswns119} $@$ postech.ac.kr

# Abstract

Horiyama et al. (AAAI 2024) considered the problem of generating instances with a unique minimum vertex cover under certain conditions. The PRE-ASSIGNMENT FOR UNIQUIFICATION OF MINIMUM VERTEX COVER problem (shortly PAU-VC) is the problem, for given a graph $G$ , to find a minimum set $S$ of vertices in $G$ such that there is a unique minimum vertex cover of $G$ containing $S$ . We show that PAU-VC is fixed-parameter tractable parameterized by clique-width, which improves an exponential algorithm for trees given by Horiyama et al. Among natural graph classes with unbounded clique-width, we show that the problem can be solved in polynomial time on split graphs and unit interval graphs.

# Introduction

Designing AI algorithms to tackle NP-hard graph problems has become a prominent trend in the field of artificial intelligence. The inherent complexity of NP-complete problems presents a significant challenge, making them an ideal testbed for AI-driven approaches that aim to push the boundaries of what can be achieved in terms of efficiency and scalability. To evaluate the performance of those AI algorithms, it is essential to have robust benchmark datasets. Such datasets provide a controlled environment where the strengths and weaknesses of different algorithms can be systematically analyzed. As constructing a benchmark dataset is a critical aspect of AI research, several well-known benchmark datasets were presented such as TSPLIB, UCI, SATLIB, and DIMACS for various NP-hard combinatorial problems (Reinelt 1991; Asuncion, Newman et al. 2007; Hoos and Stützle 2000).

However, it seems hard to use them to evaluate the performances of AI algorithms for the uniqueness version of combinatorial problems where a solution is unique. In several problems, the presence of a unique solution can lead to more efficient algorithms (Thomason 1978; Gabow, Kaplan, and Tarjan 1999). Also, algorithms for the unique SAT problem are used as subroutines for its search version (Scheder and Steinberger 2017; Hertli 2014a). Due to these reasons, the uniqueness version also has been extensively studied from both theory and practice (Calabro et al. 2008; Hertli 2014b).

Therefore, generating graphs with a unique solution offers a valuable addition to benchmark datasets, enabling a more thorough evaluation of AI-driven solvers for the uniqueness version of combinatorial problems.

One natural approach for generating graphs with a unique solution is to make use of graphs in well-known benchmark datasets. More specifically, we choose a graph $G$ in a wellknown benchmark dataset, and pre-assign a part of $G$ so that only one solution is consistent with this assignment. This pre-assignment for uniquification has been studied for classic NP-hard problems such as the coloring and clique problems (Harary, Slany, and Verbitsky 2007), the dominating set problem and its variants (Chartrand et al. 1997; Bozeman et al. 2019; Ferrero et al. 2018) and the vertex cover problem (Horiyama et al. 2024). Also, several pencil/video puzzles such as SUDOKU and Picross 3D have been studied in the context of the pre-assignment for uniquification (Demaine et al. 2018; Kimura, Kamehashi, and Fujito 2018; Tjusila et al. 2024).

In this paper, we focus on the PRE-ASSIGNMENT FOR UNIQUIFICATION OF MINIMUM VERTEX COVER (PAUVC) problem introduced by (Horiyama et al. 2024). A set $S$ of vertices in a graph $G$ is called a vertex cover of $G$ if $S$ meets all edges of $G$ . The goal of this problem is to compute a minimum-cardinality vertex cover of a given graph. In the unique vertex cover problem, it is assured that an input graph has a unique minimum vertex cover. The formal definition of PAU-VC is the following.

PAU-VC   
Input : A graph $G$   
Question : Find a minimum set $S \subseteq V ( G )$ such that there is a unique minimum vertex cover of $G$ containing $S$ .

Notice that one can use an algorithm for PAU-VC to generate a graph with a unique solution for the vertex cover problem. Consider an arbitrary graph $G$ (possibly from a known benchmark dataset), and compute an optimal solution $S$ for PAU-VC on $G$ . Since there is a unique minimum vertex cover of $G$ containing $S$ , $G - S$ has a unique minimum vertex cover as well, where $G - S$ is the graph obtained from $G$ by removing all vertices of $S$ and their incident edges.

Although the pre-assignment for uniquification of the dominating set problem and its variants has been studied extensively, little is known about PAU-VC, except for (Horiyama et al. 2024). More specifically, (Horiyama et al. 2024) proved that PAU-VC is $\bar { \Sigma _ { 2 } ^ { P } }$ -complete on general graphs, and NPcomplete on bipartite graphs. On the positive side, they provided an algorithm that runs in time $\mathcal { O } ( 2 . 1 9 9 6 ^ { n } )$ for general graphs, an algorithm that runs in time $\mathcal { O } ( 1 . 9 1 8 1 ^ { n } )$ for bipartite graphs, and an algorithm that runs in time $\mathcal { O } ( 1 . 4 1 4 3 ^ { n } )$ for trees, where $n$ denotes the number of vertices.

As PAU-VC is $\Sigma _ { 2 } ^ { P }$ -complete and NP-complete for general graphs and bipartite graphs, respectively, it is unlikely to admit polynomial-time algorithms for either general or bipartite graphs. However, the time complexity for trees remains an open question. In fact, (Horiyama et al. 2024) also mentioned this explicitly: “Many readers might consider that PAUVC for trees is likely solvable in polynomial time. On the other hand, not a few problems are intractable (e.g., NODE KAYLES) in general, but the time complexity for trees still remains open, and only exponential-time algorithms are known. In the case of PAU-VC, no polynomial-time algorithm for trees is currently known.”

Our results. In this paper, we resolve this open problem by presenting a polynomial-time algorithm for PAU-VC on trees, which significantly improves the exponential-time algorithm by Horiyama et al. Moreover, we showed that it can be extended to classes of bounded clique-width. Clique-width is a graph parameter that measures the complexity of constructing a graph using a set of specific operations, including the creation of new vertices, disjoint union of graphs, relabeling of vertex labels, and connecting vertices based on their labels. Trees have clique-width at most 3 (Courcelle and Olariu 2000) and complete graphs have clique-width at most 2. A precise definition will be given in the clique-width section.

More precisely, we prove the following theorem. We say a problem is fixed-parameter tractable with parameter $k$ if it can be solved in time $f ( k ) n ^ { \mathcal { O } ( 1 ) }$ , where $n$ denotes the input size and $f ( \cdot )$ is a computable function.

# Theorem 1. PAU-VC is fixed-parameter tractable parameterized by clique-width.

One may ask whether we can further obtain polynomialtime algorithms for PAU-VC on natural classes of graphs of unbounded clique-width. We investigate two such classes. Split graphs are graphs that can be partitioned into an independent set and a clique. Unit interval graphs are intersection graphs of intervals of the same length on the real line. It is known that split graphs have unbounded cliquewidth (Makowsky and Rotics 1999) and unit interval graphs have unbounded clique-width (Golumbic and Rotics 2000). Split graphs and unit interval graphs are well-known graph classes that have been widely studied (Corneil et al. 1995; Hell, Shamir, and Sharan 2001; Bertossi 1984). We prove that PAU-VC can be solved in linear time on both classes.

Theorem 2. PAU-VC can be solved in linear time on unit interval graphs and split graphs.

Note that the class of split graphs and the class of unit interval graphs are well-known subclasses of the class of chordal graphs. It would be interesting to determine whether PAUVC can be solved in polynomial time on chordal graphs.

Proofs of statements marked with $^ { 6 6 } ( * ) ^ { 3 }$ are deferred to the appendix.

Brief introduction on clique-width. The notion of cliquewidth is closely related to the concept of tree-width. Treewidth is a well-studied graph parameter which measures how close a graph is to being a tree (Robertson and Seymour 2004). (Courcelle 1990) showed that every problem expressible in $\mathbf { M S O } _ { 2 }$ -logic is fixed-parameter tractable when parameterized by the tree-width of a graph. However, classes of bounded tree-width must be sparse. To address this limitation, (Courcelle and Olariu 2000) introduced clique-width to extend properties of classes of bounded tree-width to dense graph classes, such as the class of complete graphs.

Every class of bounded tree-width has bounded cliquewidth (Courcelle and Olariu 2000; Corneil and Rotics 2005), but there are classes of bounded clique-width and unbounded tree-width, such as the class of complete graphs or complete bipartite graphs. (Courcelle, Makowsky, and Rotics 2000) showed that every problem expressible in $\mathbf { M S O } _ { 1 }$ -logic is fixed-parameter tractable when parameterized by the cliquewidth of a graph. It is not difficult to see that PAU-VC cannot be expressible in $\mathbf { M S O } _ { 1 }$ -logic, as we cannot represent the property that a set is a unique minimum vertex cover. So, the algorithmic meta theorem by Courcelle, Makowsky, and Rotics cannot be adapted for PAU-VC. The parameterized complexity of problems cannot be expressible by $\mathbf { M S O } _ { 1 }$ - logic, such as HAMILTONAIN CYCLE and Graph Coloring, have been studied (Kobler and Rotics 2003; Fomin et al. 2010, 2014, 2019; Bergougnoux, Kanté, and Kwon 2020).

# Preliminary

For every positive integer $n$ , let $[ n ]$ denote the set of positive integers at most $n$ . All graphs in this paper are simple and finite. For a graph $G$ we denote by $V ( G )$ and $E ( G )$ the vertex set and edge set of $G$ , respectively. For graphs $G$ and $H$ , let $G \cup H$ be the graph with vertex set $V ( G ) \cup V ( H )$ and edge set $E ( G ) \cup E ( H )$ .

Let $G$ be a graph. For a vertex $v$ of a graph $G$ , let $N _ { G } ( v )$ denote the set of neighbors of $v$ in $G$ . For $X \subseteq V ( G )$ , let $G [ X ]$ denote the subgraph of $G$ induced by $X$ . We denote by $G - X$ the graph $G [ V ( G ) \backslash X ]$ , and for a single vertex $x \in V ( G )$ , we use the shorthand $\mathbf { \epsilon } \cdot \boldsymbol { G } - \boldsymbol { x } ^ { \prime }$ for $\mathbf { \hat { G } } - \{ x \} ^ { , }$ For two sets $X , Y \subseteq V ( G )$ , let $G [ X , Y ]$ be the graph $X \cup$ $Y , \{ x y \in E ( G ) : x \in X , y \in Y \}$ ).

A set $X \subseteq V ( G )$ is a clique if any two vertices of $X$ are adjacent in $G$ , and it is an independent set if any two vertices of $X$ are not adjacent in $G$ .

# Trees

Before diving into our main theorems, we present an idea for having a simpler polynomial time algorithm for PAU-VC on trees. Recall that this significantly improves the best-known algorithm for this problem (Horiyama et al. 2024), which runs in exponential time. Let $G$ be a tree. We choose an arbitrary vertex as the root of $G$ . For each node $v \in V ( G )$ , we use $G _ { v }$ to denote the subtree of $G$ rooted at $v$ .

For each vertex $v$ , there are two types of vertex covers of $G _ { v }$ ; one is a vertex cover of $G _ { v }$ containing $v$ and the other is a vertex cover of $G _ { v }$ not containing $v$ . We want to find a set $S$ which forces the number of minimum vertex covers of each type to satisfy a certain condition. This naturally suggests the following definition. For a function $\beta : \{ 0 , 1 \} \stackrel { \cdot } {  } \{ \bar { 0 , } 1 , 2 \}$ , a set $S \subseteq { \bar { V } } ( G _ { v } )$ is a $\beta$ -set in $G _ { v }$ if the following hold:

• If $\beta ( 0 ) \in \{ 0 , 1 \}$ , then there is exactly $\beta ( 0 )$ many minimum vertex covers of $G _ { v }$ not containing $v$ and containing $S$ .   
• If $\beta ( 0 ) = 2$ , then there are at least two minimum vertex covers of $G _ { v }$ not containing $v$ and containing $S$ .   
• If $\beta ( 1 ) \in \{ 0 , 1 \}$ , then there is exactly $\beta ( 1 )$ many minimum vertex covers of $G _ { v }$ containing $v$ and containing $S$ .   
• If $\beta ( 1 ) = 2$ , then there are at least two minimum vertex covers of $G _ { v }$ containing $\boldsymbol { v }$ and containing $S$ .

We will recursively compute a minimum $\beta$ -set in $G _ { v }$ for every possible function $\beta$ and every vertex $v \in V$ , if one exists.

It is not difficult to observe that if we have a minimum $\beta$ - set of $G _ { r } = G$ for every possible function $\beta$ , then we can find an optimal solution of PAU-VC. That would be a minimum set among minimum $\beta$ -sets of $G _ { r }$ for which $\beta ( 0 ) + \beta ( 1 ) = 1 .$

Therefore, it suffices to recursively compute a minimum $\beta$ -set of $G _ { v }$ for every vertex $v \in V$ . The idea is straightforward. We need to propagate the information to children of $v$ . Assume $\beta : \{ 0 , \bar { 1 } \} \stackrel { - } {  } \{ 0 , 1 , 2 \}$ is a given function. For example, if $\beta ( 0 ) = 1$ , then the $\beta$ -set in $G _ { v }$ should force a unique minimum vertex cover of $G _ { v }$ not containing $v$ . Then for each child $w$ of $v$ , we have to determine a set forcing a unique minimum vertex cover of $G _ { w }$ that contains $w$ . This suggests how to split $\beta$ into functions $\beta _ { w }$ for each child $w$ , and we can find the corresponding $\beta$ -set by taking the union of $\beta _ { w }$ -sets for children $w$ of $v$ .

This idea is generalized into graphs of bounded cliquewidth in the next section. We will provide the dynamic programming algorithm and prove the correctness.

# Graphs of Bounded Clique-width

In this section, we prove Theorem 1. Before we describe our strategy, we provide a formal definition of the clique-width and introduce some necessary notations. Let $k$ be a positive integer. A $k$ -labeled graph is a pair $( G , \mathrm { l a b } _ { G } )$ of a graph $G$ and a function $\operatorname { l a b } _ { G } : V ( G ) \ { \overset { } { \to } } \ [ k ]$ , called the labeling function. We denote by $\mathrm { l a b } _ { G } ^ { - 1 } ( i )$ the set of vertices in $G$ with label $i$ .

# Definitions of Clique-Width and NLC-Width

We first define the clique-width of graphs. For a $k$ -labeled graph $( G , \mathrm { l a b } _ { G } )$ and $i , j \in [ k ]$ with $i \neq j$ , let $\eta _ { i , j } ( G , \mathrm { l a b } _ { G } )$ be the $k$ -labeled graph obtained from $( G , \mathrm { l a b } _ { G } )$ by adding an edge between every vertex of label $i$ and every vertex of label $j$ , and let $\rho _ { i \to j } ( G , \operatorname { l a b } _ { G } )$ be the $k$ -labeled graph obtained from $\left( G , \mathrm { l a b } _ { G } \right)$ by relabeling every vertex of $i$ to $j$ . For two vertex-disjoint $k$ -labeled graphs $( G , \mathrm { l a b } _ { G } )$ and $\left( H , \mathrm { l a b } _ { H } \right)$ , let $( G , \mathrm { l a b } _ { G } ) \oplus ( H , \mathrm { l a b } _ { H } )$ be the disjoint union of them.

The class $\mathrm { C W } _ { k }$ of $k$ -labeled graphs is recursively defined as follows. (1) The single vertex graph $i ( x )$ , with a vertex $x$ labeled with $i \in [ k ]$ , is in $\mathrm { C W } _ { k }$ . (2) Let $( G , \mathrm { l a b } _ { G } )$ and $\left( H , \mathrm { l a b } _ { H } \right)$ be two vertex-disjoint $k$ -labeled graphs in $\mathrm { C W } _ { k }$ . Then $( G , \mathrm { l a b } _ { G } ) \oplus ( H , \mathrm { l a b } _ { H } ) \in \mathrm { C W } _ { k }$ . (3) Let $( G , \operatorname { l a b } _ { G } ) \in$ $\mathrm { C W } _ { k }$ and $i , j \in [ k ]$ with $i \neq j$ . Then $\eta _ { i , j } ( G , \mathrm { l a b } _ { G } ) ~ \in$ $\mathrm { C W } _ { k }$ . (4) Let $( G , \bar { \mathrm { l a b } } _ { G } ) ~ \in ~ \mathrm { C W } _ { k }$ and $i , j ~ \in ~ [ k ]$ . Then $\rho _ { i \to j } ( G , \mathrm { l a b } _ { G } ) \in \mathrm { C W } _ { k }$ . A clique-width $k$ -expression is a finite term built with the four operations above and using at most $k$ labels. The clique-width of a graph, denoted by $\operatorname { c w } ( G )$ , is the minimum $k$ such that $( G , \mathrm { l a b } _ { G } ) \in \mathrm { C W } _ { k }$ for some labeling $\operatorname { l a b } _ { G }$ .

![](images/9edea296496f7b29cfda6d72aa1e4b64b787859a63ffa55f47d6040de70c2869.jpg)  
Figure 1: Illustration of a clique-width 3-expression of $P _ { 4 }$

For example,

$$
\eta _ { 2 , 3 } { \Big ( } \eta _ { 1 , 2 } ( 1 ( a ) \oplus 2 ( b ) ) \oplus \eta _ { 1 , 3 } ( 3 ( c ) \oplus 1 ( d ) ) ) { \Big ) }
$$

is a clique-width 3-expression of a path $P _ { 4 }$ on 4 vertices. See Figure 1. Thus, $P _ { 4 }$ has clique-width at most 3.

Now, we define the NLC-width of graphs introduced by (Wanke 1994). (Johansson 1998) showed that every graph of clique-width at most $k$ has NLC-width at most $k$ , and one can in polynomial time transform an expression for clique-width to an expression for NLC-width. For two vertexdisjoint $k$ -labeled graphs $( G , \mathrm { l a b } _ { G } )$ and $\left( H , \mathrm { l a b } _ { H } \right)$ and a set $M \subseteq [ k ] ^ { 2 }$ of label pairs, we define $( G , \mathrm { l a b } _ { G } ) \ \times _ { M }$ $( H , \mathrm { l a b } _ { H } ) \mathrel { \mathop : } = \mathsf { \bar { ( } } ( V ^ { \prime } , E ^ { \prime } ) , \mathrm { l a b } ^ { \prime } )$ where

• $V ^ { \prime } = V ( G ) \cup V ( H ) .$ ,   
$\begin{array} { r c l } { \bullet \ { \cdot } } & { { \cal E } ^ { \prime } ~ = ~ { \cal E } ( G ) ~ \cup ~ { \cal E } ( H ) ~ \cup ~ \{ u v ~ : } ~ u ~ \in ~ V ( G ) , v ~ \in  \\ { ~ } & { } & { V ( H ) , ( \mathrm { l a b } _ { G } ( u ) , \mathrm { l a b } _ { H } ( v ) ) \in { \cal M } \} , } \\ { ~ } & { } & { \bullet \ \mathrm { l a b } ^ { \prime } ( u ) = \mathrm { l a b } _ { G } ( u ) \ \mathrm { i f } ~ u \in V ( G ) \ \mathrm { a n d } \ \mathrm { l a b } ^ { \prime } ( u ) = \mathrm { l a b } _ { H } ( u ) } \end{array}$ otherwise.

In other words, $( G , \mathrm { l a b } _ { G } ) \times _ { M } ( H , \mathrm { l a b } _ { H } )$ is obtained from the disjoint union of $\left( G , \mathrm { l a b } _ { G } \right)$ and $\left( H , \mathrm { l a b } _ { H } \right)$ by, for every $( i , j ) \in M$ , adding all edges between vertices of label $i$ in $G$ and vertices of label $j$ in $H$ . For a $k$ -labeled graph $( G , \mathrm { l a b } _ { G } )$ and a function $R : [ k ] \to [ k ]$ , let $\rho _ { R } ( G , \mathrm { l a b } _ { G } ) = ( G , \mathrm { l a b } ^ { \prime } )$ where $\mathrm { l a b ^ { \prime } } ( u ) = R ( \bar { \mathrm { l a b } } _ { G } ( \bar { u } ) ) \bar $ for all $u \in V ( G )$ .

The class $\mathrm { N L C } _ { k }$ of $k$ -labeled graphs is recursively defined as follows. (1) The single vertex graph $i ( x )$ , with a vertex $x$ labeled with $\textit { i } \in \ [ k ]$ , is in $\mathrm { N L C } _ { k }$ . (2) Let $( G , \mathrm { l a b } _ { G } ) \in \mathrm { N L C } _ { k }$ and $R : [ k ] \to [ k ]$ be a function. Then $\rho _ { R } ( G , \mathrm { l a b } ) \in \mathrm { N L C } _ { k }$ . (3) Let $( G , \operatorname { l a b } _ { G } )$ and $\left( H , \mathrm { l a b } _ { H } \right)$ be

two vertex-disjoint labeled graphs in $\mathrm { N L C } _ { k }$ , and $M \subseteq [ k ] ^ { 2 }$ .   
Then $( G , \mathrm { l a b } _ { G } ) \times _ { M } ( H , \mathrm { l a b } _ { H } ) \bar { \in } \mathrm { N L C } _ { k }$ .

An NLC-width $k$ -expression is a finite term built with the three operations above and using at most $k$ labels. The NLCwidth of a graph $G$ , denoted by $\operatorname { n l c w } ( G )$ , is the minimum $k$ such that $( \bar { G } , \bar { \mathrm { l a b } } _ { G } ) \in \mathrm { N L C } _ { k }$ for some labeling $\operatorname { l a b } _ { G }$ .

Theorem 3 ((Johansson 1998)). Let $k$ be a positive integer. Every graph of clique-width at most $k$ has NLC-width at most $k$ , and one can in polynomial time transform a clique-width $k$ -expression to an NLC-width $k$ -expression.

We remark about algorithms to find a clique-width expression when it is not given. (Fellows et al. 2006) proved that computing clique-width is NP-hard. (Oum and Seymour 2006) first obtained an approximation algorithm that computes a clique-width $( 2 ^ { 3 k + 2 ^ { 2 } } - 1 )$ -expression of a given graph $G$ of clique-width at most $k$ , which runs in time $\mathcal { \bar { O } } ( \bar { 8 } ^ { k } n ^ { 9 } \log n )$ . $( \mathrm { O u m } 2 0 0 9 )$ later improved this by providing two algorithms; one is an algorithm that computes a cliquewidth $\bar { ( 8 ^ { k } - 1 ) }$ -expression in time $\mathcal { O } ( g ( k ) \cdot \overline { { n ^ { 3 } } } )$ for some function $g$ , and the other one is an algorithm that computes a clique-width $( 2 ^ { 3 k + 2 } - 1 )$ -expression in time $O ( 8 ^ { k } n ^ { \mathbf { \bar { 4 } } } )$ . We may use one of these algorithms to produce a clique-width expression, when it is not given as input.

# FPT Algorithm Parameterized by Clique-Width

Now we are ready to prove Theorem 1. Let $\left( H , \mathrm { l a b } _ { H } \right)$ be a $k$ -labeled graph. For a set $X$ of vertices in $H$ , we denote by $\mathrm { f u l l } _ { H } ( X )$ the set of integers $i \in [ k ]$ where $\operatorname { l a b } _ { H } ^ { - 1 } ( i ) \subseteq \dot { X }$ . For $I \subseteq [ k ]$ , a set $T \subseteq V ( H )$ is a minimum vertex cover of $H$ with respect to $I$ if it is a minimum set among all vertex covers $X$ of $H$ with $\mathrm { f u l l } _ { H } ( X ) = I$ . Note that $T$ is not necessarily a minimum vertex cover of $H$ . Let $\mu _ { H } ( I )$ be the size of a minimum vertex cover of $H$ with respect to $I$ .

Assume that $( F , \mathrm { l a b } _ { F } ) = ( G , \mathrm { l a b } _ { G } ) \times _ { M } ( H , \mathrm { l a b } _ { H } )$ for some $k$ -labeled graphs $\left( G , \mathrm { l a b } _ { G } \right)$ , $\left( H , \mathrm { l a b } _ { H } \right)$ , and $M \subseteq [ k ] ^ { 2 }$ . Observe that for every $( i , j ) \in M$ , every vertex cover of $F$ either contains all vertices of $\mathrm { l a b } _ { G } ^ { - 1 } ( i )$ or contains all vertices of $\operatorname { l a b } _ { H } ^ { - 1 } ( j )$ . Thus, in each side, it is necessary to consider vertex covers that fully contain vertex sets of certain labels. This is the reason why we define minimum vertex covers with respect to $I \subseteq [ k ]$ .

Now, to find sets ${ \dot { S } } \subseteq V ( F )$ that force to have a unique minimum vertex cover, in each of $G$ and $H$ , we need to know whether a set forces to have a unique minimum vertex cover with respect to some $I \subseteq [ k ]$ . For each $I \subseteq [ k ]$ , we need to distinguish three statuses: (1) $S$ does not force any minimum vertex cover with respect to $I$ , (2) $S$ forces a unique minimum vertex cover with respect to $I$ , or (3) $S$ forces at least two minimum vertex covers with respect to $I$ . This property will be captured by the notion of characteristic, defined below.

A function $\beta : 2 ^ { [ k ] } \to \{ 0 , 1 , 2 \}$ is the characteristic of a set $S \subseteq V ( H )$ in $H$ if for every ${ \bar { \boldsymbol { J } } } \subseteq [ k ]$ ,

• if $\beta ( J ) \in \{ 0 , 1 \}$ , then there is exactly $\beta ( J )$ many minimum vertex covers of $H$ with respect to $J$ and containing $S$ , and • if $\beta ( J ) = 2$ , then there are at least two minimum vertex covers of $H$ with respect to $J$ and containing $S$ .

Such a set $S \subseteq V ( H )$ is called a $\beta$ -set in $H$ . Let $\Pi ( H )$ be the collection of functions $\beta : 2 ^ { [ k ] }  \{ 0 , 1 , 2 \}$ such that there is a $\beta$ -set in $H$ .

In the following lemma, we explain how we can solve PAU-VC on a $k$ -labeled graph $H$ if we know the set $\Pi ( H )$ and the function $\mu _ { H }$ and a collection of minimum $\beta$ -sets for each $\beta \in \Pi ( H )$ .

Lemma 1. Let $k$ be a positive integer. Given a $k$ -labeled graph $( G , \operatorname { l a b } _ { G } )$ with $\Pi ( G )$ , $\mu _ { G }$ and a collection of minimum $\beta$ -sets for each $\beta \in \Pi ( G )$ , one can solve PAU-VC for $G$ in time $\mathcal { O } ( 3 ^ { 2 ^ { k } } | V ( G ) | )$ .

Proof. Let $\mu \ : = \ : \mathrm { m i n } _ { I \subseteq [ k ] } \mu _ { G } ( I )$ , and ${ \Gamma } ~ = ~ \{ J ~ \subseteq ~ [ k ] ~ :$ $\mu _ { G } ( J ) = \mu \}$ . Then $\mu$ is the size of a minimum vertex cover of $G$ . We say that a function $\beta : 2 ^ { [ k ] } \to \{ 0 , 1 , 2 \}$ is valid if $\sum _ { J \in \Gamma } \beta ( J ) \dot { = } 1$ . A $\beta$ -set with a valid function $\beta$ in $\Pi ( G )$ is a set forcing a unique minimum vertex set in $G$ . Thus, the minimum $\beta$ -set with a valid function $\beta$ in $\Pi ( G )$ is a required solution for PAU-VC. □

By Lemma 1, it is sufficient to compute $\Pi ( H )$ and $\mu _ { H }$ and a collection of minimum $\beta$ -sets. We will compute them in a bottom-up way, along a given NLC-width $k$ -expression.

In the next lemma, we describe how to merge information for $( G , \mathrm { l a b } _ { G } )$ and $\left( H , \mathrm { l a b } _ { H } \right)$ to obtain information for $( G , \mathrm { l a b } _ { G } ) \times _ { M } ( H , \mathrm { l a b } _ { H } )$ .

Lemma 2. Let k be a positive integer, and let $( G , \mathrm { l a b } _ { G } )$ and $\left( H , \operatorname { l a b } _ { H } \right)$ be vertex-disjoint $k$ -labeled non-empty graphs. Let $\dot { M } \subseteq [ k ] ^ { 2 }$ and let $( F , \mathrm { l a b } _ { F } ) = ( G , \mathrm { l a b } _ { G } ) \times _ { \bar { M } } ( \bar { H } , \mathrm { l a b } _ { H } )$ .

Given $\Pi ( G ) , \Pi ( H )$ and $\mu _ { G } , \mu _ { H }$ and a collection $\mathcal { T } _ { G }$ of minimum $\beta$ -sets for $\beta \in \Pi ( G )$ and a collection $\scriptstyle { \mathcal { T } } _ { H }$ of minimum $\beta$ -sets for $\beta \in \Pi ( H )$ , one can compute $\Pi ( F ) , \mu _ { F }$ and a collection $\mathcal { T } _ { F }$ of minimum $\beta$ -sets for $\beta \in \Pi ( F )$ in time $O ( 2 7 ^ { 2 ^ { k } } \cdot | V ( G ) | ) .$ .

Proof. We construct an auxiliary bipartite graph $Q$ with bipartition $( \{ a _ { i } : i \in [ k ] \} , \{ b _ { i } : i \in [ \bar { k } ] \} )$ such that $a _ { i }$ is adjacent to $b _ { j }$ if and only if $( i , j ) \in M$ . Let $A = \{ a _ { i } : i \in [ \bar { k } ] \}$ , $B = \{ b _ { i } : i \in [ k ] \}$ , and let $\dot { g } ( a _ { i } ) = g ( b _ { i } ) = i$ for all $i \in [ k ]$ . Let $\mathcal { Z }$ be the collection of all vertex covers of $Q$ . Note that the number of all vertex covers of $Q$ is at most $2 ^ { 2 k }$ .

We first compute $\mu _ { F } ( I )$ for each $I \subseteq [ k ]$ , which is the size of a minimum vertex cover of $F$ with respect to $I$ . Note that for any $( i , j ) \in M$ , every vertex cover of $F$ contains either all vertices of $\operatorname { l a b } _ { G } ^ { - 1 } ( i )$ or all vertices of $\operatorname { l a b } _ { H } ^ { - 1 } ( j )$ . We guess a vertex cover of $Q$ corresponding to parts whose all vertices are contained in a vertex cover of $F$ .

We construct a function $\mu ^ { * }$ as below.

• Let $I \subseteq [ k ]$ . For each $Z \in { \mathcal { Z } }$ with $( g ( Z \cap A ) \cap g ( Z \cap B ) ) \backslash$ $I = \emptyset$ , let $\dot { I } _ { G } = I \cup g ( Z \cap A )$ and $I _ { H } = I \cup g ( Z \cap B )$ , and let $\alpha ( Z ) : = \mu _ { G } ( I _ { G } ) + \mu _ { H } ( I _ { H } )$ . • We define $\mu ^ { * } ( I )$ as the minimum such $\alpha ( Z )$ over all $Z \in { \mathcal { Z } }$ with $( g ( Z \cap A ) \cap g ( Z \cap B ) ) \setminus I = \emptyset$ . Note that such a set $Z$ exists as $A$ is such a vertex cover.

Claim 1 $( * )$ . The above procedure correctly computes $\mu _ { F }$ , that is, $\mu ^ { * } ( I ) = \mu _ { F } ( I )$ for every $I \subseteq [ k ]$ .

Since the number of vertex covers of $Q$ is at most $2 ^ { 2 k }$ , for each $I \subseteq [ k ]$ , we can determine $\mu ^ { * } ( I )$ in time $O ( 4 ^ { k } )$ . So, we can output $\mu ^ { * }$ in time $\mathcal { O } ( 4 ^ { k } )$ .

Now, we compute $\Pi ( F )$ and $\scriptstyle { \mathcal { T } } _ { F }$ . We construct sets $\Pi ^ { * }$ and $\boldsymbol { \mathcal { T } ^ { * } }$ and will show that $\dot { \Pi } ^ { * } = \Pi ( F )$ and $\boldsymbol { \mathcal { T } ^ { * } }$ is a collection of minimum $\beta$ -sets for $\beta \in \Pi ( F )$ . For a function $\beta : 2 ^ { [ k ] } \to$ $\{ 0 , 1 , 2 \}$ , we need to determine whether there is a $\beta$ -set in $F$ . Let $\beta : { \dot { 2 } } ^ { [ k ] } \to \{ 0 , 1 , 2 \}$ be a function.

1. Let $I \subseteq [ k ]$ . We say that a pair $\left( { { I _ { G } } , { I _ { H } } } \right)$ of subsets of $[ k ]$ is a split of $I$ with respect to $M$ if • $I _ { G } \cap I _ { H } = I$ , and • for every $( i , j ) \in M$ , $i \in I _ { G }$ or $j \in I _ { H }$ . A split $\left( I _ { G } , I _ { H } \right)$ of $I$ is proper if $\mu _ { G } ( I _ { G } ) + \mu _ { H } ( I _ { H } ) =$ $\mu _ { F } ( I )$ .   
2. A pair $( \beta _ { G } , \beta _ { H } )$ of functions $\beta _ { G } , \beta _ { H } : 2 ^ { [ k ] } \to \{ 0 , 1 , 2 \}$ is legitimate for $\beta$ if for all subsets $I \subseteq [ k ]$ , we have

$$
\beta ( I ) = \operatorname* { m i n } \left( 2 , \sum _ { { ( I _ { G } , I _ { H } ) \colon } \atop { \mathrm { p r o p e r ~ s p l i t ~ o f } I } } \left( \beta _ { G } ( I _ { G } ) \times \beta _ { H } ( I _ { H } ) \right) \right) .
$$

3. Assume there is a legitimate pair $( \beta _ { G } , \beta _ { H } )$ for $\beta$ where $\beta _ { G } \in \Pi ( G )$ and $\beta _ { H } \in \Pi ( H )$ and $S _ { G }$ is a minimum $\beta _ { G }$ - set in $\mathcal { T } _ { G }$ and $S _ { H }$ is a minimum $\beta _ { H }$ -set in $\scriptstyle { \mathcal { T } } _ { H }$ . Then we add $\beta$ to $\Pi ^ { * }$ and add $S _ { G } \cup S _ { H }$ to $\mathcal { T } ^ { * }$ . Otherwise, we do not add.

Claim 2 $( * )$ . The above procedure correctly computes $\Pi ( F )$ , that is, $\Pi ^ { * } = \Pi ( F )$ . Also, $\boldsymbol { \mathcal { T } ^ { * } }$ is a collection of $\beta$ -sets for $\beta \in \Pi ( F )$ .

Observe that the number of possible functions $\beta : 2 ^ { [ k ] } \to$ $\{ 0 , 1 , 2 \}$ is at most $3 ^ { 2 ^ { k } }$ . Let $\beta$ be such a function. For each $I \subseteq [ k ]$ , there are at most $3 ^ { k - | I | } \leq 3 ^ { k }$ splits of $I$ with respect to $M$ . Thus, for a fixed pair $( \beta _ { G } , \beta _ { H } )$ of functions, one can test whether $( \beta _ { G } , \beta _ { H } )$ is legitimate for $\beta$ in time $O ( 2 ^ { k } \cdot 3 ^ { k } )$ . Thus, we can determine $\Pi ^ { * }$ and $\boldsymbol { \mathcal { T } ^ { * } }$ in time $O ( 3 ^ { 3 \cdot 2 ^ { k } } \cdot 2 ^ { k } \cdot 3 ^ { k } \cdot$ $| V ( G ) | ) = \mathcal { O } ( 2 7 ^ { 2 ^ { k } } | V ( G ) | )$ . This concludes the proof. □

Lemma 3 $( * )$ . Let $k$ be a positive integer, and let $( G , \mathrm { l a b } _ { G } )$ be a $k$ -labeled graph. Let $R : [ k ] \to [ k ]$ be a function and let $( F , \mathrm { l a b } _ { F } ) = \bar { \rho _ { R } ( G , \mathrm { l a b } _ { G } ) }$ .

Given $\Pi ( G )$ , $\mu _ { G }$ , and a collection $\mathcal { T } _ { G }$ of minimum $\beta$ -sets for $\beta \in \Pi ( G )$ , one can compute $\Pi ( F )$ , $\mu _ { F }$ and a collection $\mathcal { T } _ { F }$ of minimum $\beta$ -sets for $\beta \in \Pi ( F )$ in time ${ \mathcal { O } } ( 9 ^ { 2 ^ { k } } \cdot | V ( G ) | )$ .

Now, we are ready to prove Theorem 1.

Proof. (Proof of Theorem 1) Using an algorithm by (Oum 2009), we can compute a clique-width $( 2 ^ { 3 t + 2 } - 1 )$ -expression of a graph of clique-width $t$ in time $\mathcal { O } ( 8 ^ { t } | V ( \tilde { G } ) | ^ { \bar { 4 } } )$ as explained in the preliminary section. In the rest, we discuss how to obtain an algorithm if a clique-width expression is given.

Let $G$ be a graph and assume that its clique-width $k$ - expression is given. By Theorem 3, we can transform it into an NLC-width $k$ -expression $\phi$ in polynomial time.

We design a bottom-up dynamic programming along the NLC-width $k$ -expression. At each $k$ -labeled graph $( F , \mathrm { l a b } _ { F } )$ arising in $\phi$ , we compute sets $\Pi ( F )$ , $\mu _ { F }$ , and a collection $\mathcal { T } _ { F }$ of minimum $\beta$ -sets for $\beta \in \Pi ( { \dot { F } } )$ as follows.

1. Assume $( F , \operatorname { l a b } _ { F } ) = i ( x )$ , that is, $F$ is a graph on a vertex $x$ with label $i$ . • Observe that $\mu _ { F } ( \{ i \} ) = 1$ because $\{ x \}$ is the unique minimum vertex cover of $F$ with respect to $\{ x \}$ . Also, $\mu _ { F } ( \emptyset ) = 1$ because $\varnothing$ is the unique minimum vertex cover of $F$ with respect to $\varnothing$ . For other subsets $I$ of $[ k ]$ $, \mu _ { F } ( I ) = 0$ , as there is no vertex cover of $F$ with respect to $I$ . • Note that the empty set has the characteristic $\beta _ { 0 }$ where $\beta _ { 0 } ( J ) = 1$ for $J = \{ i \}$ or $\varnothing$ , and $\beta _ { 0 } ( J ) = 0$ otherwise. The set $\{ x \}$ has characteristic $\beta _ { 1 }$ where $\beta _ { 1 } ( J ) = 1$ for $J =  { \left\{ i \right\} }$ , and $\beta _ { 1 } ( J ) = 0$ otherwise. Let $\Pi ( F ) =$ $\{ \beta _ { 0 } , \beta _ { 1 } \}$ . We store the empty set as a minimum $\beta _ { 0 }$ -set, and $\{ x \}$ as a minimum $\beta _ { 1 }$ -set. • These can be computed in time ${ \mathcal { O } } ( k )$ .   
2. Assume that $( F , \mathrm { l a b } _ { F } ) = \rho _ { R } ( F _ { 1 } , \mathrm { l a b } _ { 1 } )$ for some function $R : [ k ] \ \to \ [ k ]$ . By Lemma 3, we can in time $\mathcal { O } ( 9 ^ { 2 ^ { k } } \cdot | V ( G ) | )$ compute $\Pi ( F )$ , $\mu _ { F }$ , and a collection $\mathcal { T } _ { F }$ of minimum $\beta$ -sets for $\beta \in \Pi ( F )$ .   
3. Assume that $( F , \mathrm { l a b } _ { F } ) ~ = ~ ( F _ { 1 } , \mathrm { l a b } _ { 1 } ) { } ~ \times _ { M } { } ~ ( F _ { 2 } , \mathrm { l a b } _ { 2 } )$ for some $M \subseteq [ k ] ^ { 2 }$ . By Lemma 2, we can in time $\mathcal { O } ( 2 7 ^ { 2 ^ { k } } \cdot | V ( F ) | )$ compute $\Pi ( F ) , \mu _ { F }$ , and a collection $\mathcal { T } _ { F }$ of minimum $\beta$ -sets for $\beta \in \Pi ( F )$ .

At the end, by Lemma 1, we can solve PAU-VC in time $\mathcal { O } ( 3 ^ { 2 ^ { k } } | V ( G ) | )$ . Note that there are at most $\mathcal { O } ( k ^ { 2 } | V ( G ) | )$ operations in the NLC-width $k$ -expression. Thus, in total, we can solve PAU-VC in time $\mathcal { O } ( 2 7 ^ { 2 ^ { k } } | V ( G ) | ^ { 2 } )$ . □

# Unit Interval Graphs

In this section, we give a linear time algorithm of PAU-VC for a unit interval graph $G$ . A unit interval graph $G$ is a graph that has a set $\boldsymbol { \mathcal { T } }$ of intervals of length one on the real line so that $G$ is an intersection graph of $\boldsymbol { \mathcal { T } }$ , refer to Figure 2.

Theorem 4. PAU-VC can be solved in linear time for a unit interval graph.

Proof. Let $G$ be a given unit interval graph. We can find a set $\boldsymbol { \mathcal { T } }$ of unit intervals representing $G$ in linear time (Corneil et al. 1995). Furthermore, the obtained $\boldsymbol { \mathcal { T } }$ is sorted by the left end points. For clarity, we refer to the intervals in $\boldsymbol { \mathcal { T } }$ as the vertices of $G$ . By perturbing if necessary, we may assume that all intervals are pairwise distinct.

First, we find a maximum independent set $\{ \tilde { I } _ { 1 } , \dots , \tilde { I } _ { m } \}$ of $G$ as follows: $\tilde { I } _ { 1 }$ is the leftmost interval in $\boldsymbol { \mathcal { T } }$ and $\tilde { I } _ { i + 1 }$ is the leftmost interval in $\boldsymbol { \mathcal { T } }$ disjoint to $\tilde { I } _ { j }$ for all $j \in [ i ]$ . It is easy to see that the obtained set is a maximum independent set of $G$ . Then, for each ${ \tilde { I } } _ { i }$ , let $\mathcal { T } _ { i }$ be the set of intervals in $\boldsymbol { \mathcal { T } }$ that start after ${ \tilde { I } } _ { i }$ and intersect with ${ \tilde { I } } _ { i }$ , along with ${ \tilde { I } } _ { i }$ itself. Then $\{ \mathcal { T } _ { 1 } , \ldots , \mathcal { T } _ { m } \}$ gives a partition of $\boldsymbol { \mathcal { T } }$ , and each $\mathcal { T } _ { i }$ forms a clique in $G$ . Note that if two intervals $I \in \mathcal { I } _ { i }$ and $J \in \mathcal { I } _ { j }$ are intersecting, then $| i - j | \le 1$ since every interval has a unit length.

![](images/c694e545c53556733fafaeaf59ed5a211d4016117fd3d475024db0394277c0de.jpg)  
Figure 2: Illustration of the algorithm for a unit interval graph $G$ . Figures (a) and (b) represent the unit interval graph $G$ and its representation, respectively. The algorithm returns $\{ I _ { 1 , 1 } , I _ { 2 , 2 } \}$ as an optimal solution of PAU-VC of $G$ , where $\{ I _ { 1 , 1 } , I _ { 2 , 2 } \} = S [ 3 , 3 ]$ as $S [ 1 , 2 ] = \{ I _ { 1 , 1 } \} , A _ { 1 , 2 , 3 } = \{ I _ { 2 , 2 } \}$ , and $A _ { 2 , 3 , 3 } = \varnothing$ . Precisely, $S [ 3 , 3 ] = S [ 1 , 2 ] \cup A _ { 1 , 2 , 3 } \cup A _ { 2 , 3 , 3 } .$ .

Claim 3. Every minimum vertex cover of $G$ excludes exactly one vertex in $\mathcal { T } _ { i }$ for each $i \in [ m ]$ .

Proof. It is well known that the complement of a maximum independent set is a minimum vertex cover, and vice versa. Since $m$ is the size of the maximum independent set of $G$ , every minimum vertex cover should exclude $m$ vertices. Note that each $\mathcal { T } _ { i }$ forms a clique in $G$ , it cannot exclude more than one vertex from the same $\mathcal { T } _ { i }$ . Thus, exactly one vertex for each $\mathcal { T } _ { i }$ is excluded. $\diamondsuit$

Now we describe a dynamic programming to solve PAUVC for $G$ .

Let $i \in [ m ]$ and $j \in [ | \mathcal { T } _ { i } | ]$ . Let $I _ { i , j }$ be the $j$ th leftmost interval in $\mathcal { T } _ { i }$ , and let $G _ { i , j }$ be the subgraph of $G$ induced by the intervals starting before $I _ { i , j }$ along with $I _ { i , j }$ .

For $j \in [ | \mathcal { I } _ { 1 } | ]$ , let $A _ { 1 , j } : = \{ I _ { 1 , i } : i < j \}$ . For $ 2 \leq i \leq$ $m - 1$ and $a \in [ | \mathcal { I } _ { i } | ]$ and $b \in [ | \mathcal { T } _ { i + 1 } | ]$ , let

$$
\begin{array} { r l } & { A _ { i , a , b } : = \{ I _ { i , x } : a < x \mathrm { ~ a n d ~ } I _ { i , x } \cap I _ { i + 1 , b } = \emptyset \} } \\ & { \qquad \cup \{ I _ { i + 1 , y } : y < b \mathrm { ~ a n d ~ } I _ { i + 1 , y } \cap I _ { i , a } = \emptyset \} , } \end{array}
$$

Intuitively, $A _ { 1 , j }$ and $A _ { i , a , b }$ are sets of vertices that have to be included in a set forcing a unique minimum vertex cover $S$ when we want that $I _ { i , a }$ and $I _ { i + 1 , b }$ are not in $S$ .

Now, for each $I _ { i , j } \in \mathcal { I }$ , we denote $S [ i , j ]$ as the smallest vertex set in $G _ { i , j }$ that forces the unique minimum vertex cover in $G _ { i , j }$ and the vertex cover excludes $I _ { i , j }$ .

We compute $S [ i , j ]$ in a lexicographic order. As the base case, we set $S [ 1 , j ] : = A _ { 1 , j }$ for each $\bar { j } \in [ | \mathcal { I } _ { 1 } | ]$ . By assuming that every $S [ i , j ^ { \prime } ]$ has been computed for $j ^ { \prime } \in [ | \mathcal { T } _ { i } | ]$ , we set $S [ i + 1 , j ]$ as the smallest vertex set among

$$
S [ i , j ^ { \prime } ] \cup A _ { i , j ^ { \prime } , j }
$$

where $I _ { i , j ^ { \prime } } \in \mathcal { T } _ { i }$ is disjoint from $I _ { i + 1 , j }$ . Note that $S [ i { + } 1 , j ]$ is well-defined, because $I _ { i , 1 } = \tilde { I } _ { i }$ is disjoint from $I _ { i + 1 , 1 } = \tilde { I } _ { i + 1 }$ along with Ii+1,j .

1C,1laim 4. For evIe2,r1y $i \in [ m ]$ and $j ~ \in ~ [ | \mathcal { T } _ { i } | ] , ~ S [ i , j ]$ is a smallest vertex set in $G _ { i , j }$ that forces a unique minimum verIt1e,2x cover in $G _ { i , j }$ Ia2n,2d the vertex covIe3r,2excludes $I _ { i , j }$ .

Proof. We prove this by induction on $i + j$ . First, assume that $i = 1$ 1.,3Then $G _ { 1 , j }$ is a c2,o4mplete graph. Thus, there is only one vertex cover excluding $I _ { 1 , j }$ , namely $V ( G _ { 1 , j } ) \backslash$ $\{ I _ { 1 , j } \}$ . If we do not preassign a vertex of $V ( G _ { 1 , j } ) \backslash \{ I _ { 1 , j } \}$ , we may take $I _ { i , j }$ instead of this vertex, to make another minimum vertex cover of $G _ { 1 , j }$ . Thus, $S [ 1 , j ]$ should be exactly $V ( G _ { 1 , j } ) \backslash \{ I _ { 1 , j } \}$ .

Suppose that $i \geq 2$ . Let $T$ be a minimum vertex set in $G _ { i , j }$ that forces a unique minimum vertex cover in $G _ { i , j }$ and the vertex cover excludes $I _ { i , j }$ . We will show that $T$ is of the form $S [ i - 1 , j ^ { \prime } ] \cup A _ { i - 1 , j ^ { \prime } , j }$ in the definition. Let $U$ be the unique vertex cover in $G _ { i , j }$ containing $T$ , and let $W = V ( G _ { i , j } ) \backslash U$ . Observe that $W$ contains exactly one vertex from each of $\mathcal { T } _ { 1 } , \ldots , \mathcal { T } _ { i }$ . Let $j _ { 1 } , \dotsc , j _ { i - 1 }$ be integers such that $W = \{ I _ { 1 , j _ { 1 } } , I _ { 2 , j _ { 2 } } , \dotsc , I _ { i - 1 , j _ { i - 1 } } , I _ { i , j } \}$ .

We claim that

$$
A ^ { * } : = A _ { 1 , j _ { 1 } } \cup \left( \bigcup _ { x \in [ i - 1 ] } A _ { x , j _ { x } , j _ { x + 1 } } \right) \subseteq T .
$$

Suppose for contradiction that this is not true. First assume that $A _ { 1 , j _ { 1 } }$ contains a vertex $I$ that is not in $T$ . Then $( U \backslash$ $\{ I \} ) \cup \{ I _ { 1 , j _ { 1 } } \}$ is also a minimum vertex cover of $G _ { i , j }$ containing $T$ , a contradiction.

We assume that for some $x \in [ i - 1 ]$ , $A _ { x , j _ { x } , j _ { x + 1 } }$ contains a vertex $I$ that is not in $T$ . If

$$
I \in \{ I _ { x , z } : j _ { x } < z \mathrm { ~ a n d ~ } I _ { x , z } \cap I _ { x + 1 , j _ { x + 1 } } = \emptyset \} ,
$$

then $( U \setminus \{ I \} ) \cup \{ I _ { x , j _ { x } } \}$ is a minimum vertex cover of $G _ { i , j }$ , a contradiction. Otherwise, if

$$
I \in \{ I _ { x + 1 , z } : z < j _ { x + 1 } \mathrm { ~ a n d ~ } I _ { x + 1 , z } \cap I _ { x , j _ { x } } = \emptyset \} ,
$$

then $( U \setminus \{ I \} ) \cup \{ I _ { x + 1 , j _ { x + 1 } } \}$ is a minimum vertex cover of $G _ { i , j }$ , a contradiction. Therefore, $A ^ { * } \subseteq T$ .

Now, we verify that $A ^ { * }$ already forces that $U$ is a unique minimum vertex cover containing $A ^ { * }$ . Suppose there is another minimum vertex cover $U ^ { \prime }$ containing $A ^ { * }$ . As $U ^ { \prime } \neq$ $U , U ^ { \prime }$ does not contain a vertex of $U \backslash A ^ { * }$ . Then $G _ { i , j } - U ^ { \prime }$ cannot contain an independent set of size $i$ , a contradiction. By our construction, $T$ is $S [ i - 1 , j ^ { \prime } ] \cup A _ { i - 1 , j ^ { \prime } , j }$ for some $j ^ { \prime }$ where $I _ { i - 1 , j ^ { \prime } } \in \mathcal { T } _ { i - 1 }$ disjoint from $I _ { i , j }$ . On the other hand, we compute $S [ i , j ]$ as a smallest vertex set among all possible $S [ i - 1 , j ^ { \prime } ] \cup A _ { i - 1 , j ^ { \prime } , j }$ . Thus, $S [ i , j ]$ is a smallest vertex set in $G _ { i , j }$ that forces a unique minimum vertex cover in $G _ { i , j }$ and the vertex cover excludes $I _ { i , j }$ . $\diamondsuit$

Furthermore, the smallest vertex set among

$$
S [ m , j ] \cup \{ I _ { m , k } \in \mathcal { I } _ { m } : j < k \}
$$

for $j \in [ | \mathcal { T } _ { m } | ]$ is an optimal solution of PAU-VC for $G$ .

This algorithm returns a solution in polynomial time. In the following, we slightly modify it as a linear time algorithm.

Linear time algorithm. We compute the interval set $\boldsymbol { \mathcal { T } }$ corresponds to the given unit interval graph $G$ , and its decomposition $\mathcal { T } _ { 1 } , \ldots , \mathcal { T } _ { m }$ as described above. It takes a linear time. To obtain a linear time algorithm for PAU-VC, we compute and store the size $s [ i + 1 , j ]$ of the set $S [ i + 1 , j ]$ for each $( i + 1 , j )$ with $i \in [ m - 1 ]$ and $j \in [ | \mathcal { T } _ { i + 1 } | ]$ instead of explicitly constructing the set $S [ i + 1 , j ]$ . Since the set $S [ i + 1 , j ]$ is the union of disjoint sets $S [ i , j ^ { \prime } ]$ and $A _ { i , j ^ { \prime } , j }$ , we can compute $s [ i + 1 , j ]$ without explicitly constructing $S [ i , j ]$ . Furthermore, we also store the index $j ^ { \prime } \in [ | \mathcal { T } _ { i } | ]$ at the pair $( i + 1 , j )$ so that $S [ i + 1 , j ] = S [ i , j ^ { \prime } ] \cup A _ { i , j ^ { \prime } , j }$ . We can compute all values of $s [ \cdot , \cdot ]$ in $\mathcal { O } ( | \mathcal { T } | )$ time.

# Claim 5. We can compute all $s [ \cdot , \cdot ] i n \mathcal { O } ( | \mathcal { I } | )$ time.

Proof. We set $s [ 1 , j ] = j - 1$ by the definition. For an index $i \in [ m - 1 ]$ , we assume that every $s [ i , \cdot ]$ is computed already, and describe how to compute all $s [ i + 1 , \cdot ]$ in $\mathcal { O } ( | \mathcal { T } _ { i } \cup \mathcal { T } _ { i + 1 } | )$ time which directly implies the claim. For this, we first compute an index $k ( j ) \in [ | \mathcal { T } _ { i } | ]$ for each $j \in$ $\big [ \big | \mathscr { T } _ { i + 1 } \big | \big ]$ so that the interval $I _ { i , k ( j ) }$ is the rightmost interval in $\mathcal { T } _ { i }$ disjoint from $I _ { i + 1 , j }$ . Since $\mathcal { \bar { T } } _ { i }$ and ${ \mathcal { T } } _ { i + 1 }$ are sorted, the indices $k ( j )$ ’s are monotonic increasing. Furthermore, we can compute all $k ( j )$ ’s in $\mathcal { O } ( | \mathcal { T } _ { i } \cup \mathcal { T } _ { i + 1 } \bar { | } )$ time. For clarity, we set $k ( 0 ) = 0$ in the following. Note that $I _ { i , j ^ { \prime } } \cap I _ { i + 1 , j } =$ $\varnothing$ if and only if $j ^ { \prime } \leq k ( j )$ for $j \in [ | \mathcal { T } _ { | i + 1 } ]$ .

Recall that $s [ i + 1 , j ]$ is the smallest value among $s [ i , j ^ { \prime } ] +$ $| A _ { i , j ^ { \prime } , j } |$ with $j ^ { \prime } \le k ( j )$ . Furthermore, if $j ^ { \prime } \leq k ( j - 1 )$ , then $A _ { i , j ^ { \prime } , j }$ is same with

$$
A _ { i , j ^ { \prime } , j - 1 } \cup \{ I _ { i , x } : k ( j - 1 ) < x \leq k ( j ) \} \cup \{ I _ { i + 1 , j - 1 } \} .
$$

If an index $j ^ { \prime } \leq k ( j )$ gives the smallest set $S [ i , j ^ { \prime } ] \cup A _ { i , j ^ { \prime } , j }$ , then either $j ^ { \prime } > k ( j - 1 )$ or it gives a smallest set among $S [ i , j ^ { \prime } ] \cup A _ { i , j ^ { \prime } , j - 1 }$ . Thus, we can compute the size $s [ i + 1 , j ]$ of $S [ i + 1 , j ]$ by comparing $k ( j ) - \bar { k } ( j - 1 ) + \mathrm { i }$ values. Totally, computing all $s [ i + 1 , \cdot ]$ requires ${ \mathcal { O } } ( | { \mathcal { T } } _ { i } \cup { \mathcal { T } } _ { i + 1 } | )$ time, and thus, computing all $s [ \cdot , \cdot ]$ takes $\mathcal { O } ( | \mathcal { T } | )$ time. $\diamondsuit$

After we compute every $s [ \cdot , \cdot ]$ , we find out the index $j ^ { \ast } \in$ $\left[ \left. \mathcal { I } _ { m } \right. \right]$ minimizing the value $\dot { s } [ \dot { m } , j ^ { * } ] + | \mathcal { T } _ { m } | - j ^ { * }$ . Then we define $j _ { m } = j ^ { * }$ and $j _ { i }$ as the index with $\begin{array} { r l r } { S [ i + 1 , j _ { i + 1 } ] = } \end{array}$ $S [ i , j _ { i } ] \cup A _ { i , j _ { i } , j _ { i + 1 } }$ for $i \in [ m - 1 ]$ . By the definition of the sets $S [ \cdot , \cdot ]$ , the following set is same with $S [ m , j ^ { * } ] \cup \{ I _ { m , k } \in$ ${ \mathcal { T } } _ { m } : { \dot { j } } _ { m } \not < k \}$ that is an optimal solution of PAU-VC

$$
A _ { 1 , j _ { 1 } } \cup \left( \bigcup _ { i \in [ m - 1 ] } A _ { i , j _ { i } , j _ { i + 1 } } \right) \cup \{ I _ { m , k } \in \mathbb { Z } _ { m } : j _ { m } < k \} .
$$

In conclusion, our algorithm returns a solution of PAU-VC for $G$ in linear time, and thus, Theorem 4 holds. □

# Split Graphs

In this section, we describe a linear time algorithm for split graphs. A split graph $G$ is a graph in which there exist disjoint subsets $A$ $4 , B \subseteq V ( G )$ such that $V ( G ) = A \cup B ,$ ， $A$ is a clique and $B$ is an independent set.

Theorem 5. PAU-VC can be solved in linear time for a split graph.

Proof. Let $G$ be a given split graph, of which the vertex set consists of a clique $A$ and an independent set $B$ . Observe that a minimum vertex set excludes at most one vertex from $A$ , and furthermore, $A$ is a vertex cover of $G$ . We claim that we can safely remove all vertices in $A$ from $G$ which has at least two adjacent vertices in $B$ and also remove isolated vertices.

Claim 6 $( * )$ . If $v \in A$ has at least two adjacent vertices in $B$ , then every minimum vertex cover of $G$ includes $v$ .

In the following, suppose that every vertex in $A$ has at most one adjacent vertex in $B$ and there is no isolated vertex. Let $A _ { 0 }$ be the set of vertices in $A$ which has no adjacent vertex in $B$ . We first consider the case that $A _ { 0 }$ is not empty. In such a case, a minimum vertex cover of $G$ has size $| A | - 1$ , furthermore, $A \backslash \{ v \}$ is a minimum vertex cover of $G$ for every vertex $v \in A _ { 0 }$ . Thus, $A _ { 0 } \setminus \{ v \}$ is an optimal solution of PAU-VC for an arbitrary vertex $v \in A _ { 0 }$ .

In the following, we consider the other case that $A _ { 0 } = \varnothing$ . In this case, the size of a minimum vertex cover of $G$ is $| A |$ .

For each $a \in A$ , let $\boldsymbol { v } _ { a }$ be the vertex of $A$ that is adjacent to $a$ . Observe that for each $a \in A$ , $( A \setminus \{ a \} ) \cup \{ v _ { a } \}$ is also a minimum vertex cover. We find a vertex $b ^ { * } \in B$ minimizing $N _ { G } ( b ^ { * } )$ , and return $( N _ { G } ( b ^ { * } ) \setminus \{ v \} ) \cup \{ b ^ { * } \}$ as a solution of PAU-VC, where $\boldsymbol { v }$ is an arbitrary vertex in $N _ { G } ( b ^ { * } )$ .

$\mathbf { C l a i m 7 } \left( * \right)$ . Let $b ^ { * } \in B$ such that $| N _ { G } ( b ^ { * } ) |$ is minimum, and let $v \in N _ { G } ( B ^ { * } )$ . Then $( N _ { G } ( b ^ { * } ) \setminus \{ v \} ) \cup \{ b ^ { * } \}$ is a solution of PAU-VC.

In conclusion, we can find a solution of PAU-VC of a split graph $G$ by checking all neighbors for each vertex in $B$ . Thus, it takes $\mathcal { O } ( | V ( G ) | )$ time, because every vertex in $A$ has at most one neighbor in $B$ . □

# Conclusion

In this paper, our main contributions are three-fold: a fixedparameter tractable algorithm for PAU-VC parameterized by clique-width, and linear-time algorithms for unit interval graphs and split graphs. In particular, the first algorithm improves the best-known algorithm for PAU-VC on trees significantly. We believe that these algorithms can be used to generate benchmark datasets for evaluating the performances of AI algorithms on the unique vertex cover problem.

There are still lots of open problems in this topic. Can we design polynomial-time algorithms for interval graphs, chordal graphs, or perfect graphs? It is known that these graph classes admit polynomial-time algorithms for the minimum vertex cover problem (Grötschel, Lovász, and Schrijver 1981). Can we reduce the dependency on clique-width to be single-exponential, or can we show that our algorithm is optimal? Recall that our algorithm runs in time double exponential in the clique-width of a graph. Although the running time seems large, it is still possible that our algorithms are optimal; there are several problems with lower bounds that are double exponential in the tree-width or clique-width (Marx and Mitsou 2016; Golovach et al. 2018; Foucaud et al. 2024; Bliznets and Hecher 2024). Last but not least, can we design approximation algorithms for PAU-VC on general graphs or bipartite graphs?

# Acknowledgments

Y. Chang, O. Kwon, and M. Lee are supported by the National Research Foundation of Korea (NRF) grant funded by the Ministry of Science and ICT (No. NRF2021K2A9A2A11101617 and No. RS-2023-00211670). O. Kwon is also supported by the National Research Foundation of Korea (NRF) grant funded by Institute for Basic Science (IBS-R029-C1).   
S. An, K. Cho, E. Oh, and H. Shin are supported by Institute of Information Communications Technology Planning Evaluation (IITP) grant funded by the Korea government (MSIT) (No.RS-2024-00440239) and the National Research Foundation of Korea (NRF) grant funded by the Korea government (MSIT) (No.RS-2024-00358505). K. Cho is also supported by the National Research Foundation of Korea (NRF) grant funded by the Korea government (MSIT) (No.RS-2024-00410835).