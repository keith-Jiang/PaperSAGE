# Parallel Greedy Best-First Search with a Bound on Expansions Relative to Sequential Search

Takumi Shimoda, Alex Fukunaga

Graduate School of Arts and Sciences, The University of Tokyo takumi35shimoda $@$ yahoo.co.jp, fukunaga@idea.c.u-tokyo.ac.jp

# Abstract

Parallelization of non-admissible search algorithms such as GBFS poses a challenge because straightforward parallelization can result in search behavior which significantly deviates from sequential search. Previous work proposed PUHF, a parallel search algorithm which is constrained to only expand states that can be expanded by some tie-breaking strategy for GBFS. We show that despite this constraint, the number of states expanded by PUHF is not bounded by a constant multiple of the number of states expanded by sequential GBFS with the worst-case tie-breaking strategy. We propose and experimentally evaluate One Bench At a Time (OBAT), a parallel greedy search which guarantees that the number of states expanded is within a constant factor of the number of states expanded by sequential GBFS with some tie-breaking policy.

# 1 Introduction

Best-first search (BFS) algorithms such as $A ^ { * } ( \mathrm { H a r t }$ , Nilsson, and Raphael 1968) and GBFS (Doran and Michie 1966) are a key component of planning and scheduling systems. In order to fully exploit the increasing number of cores on modern CPUs, it is necessary to parallelize these BFS algorithms. Successful approaches to parallelization have been developed for admissible BFS algorithms such as $A ^ { * } ( \mathrm { B u r n s }$ et al. 2010; Kishimoto, Fukunaga, and Botea 2013; Phillips, Likhachev, and Koenig 2014; Fukunaga et al. 2017).

Parallelization of GBFS has turned out to be more challenging. Parallel portfolios which execute completely independent instances of GBFS (with a different tie-breaking on each thread), e.g., (Kuroiwa and Fukunaga 2020) are a simple approach. However, this approach does not exploit the potential for explicit cooperation among threads.

A natural approach to implement a more “cooperative” multi-threaded search is to use shared data structures (Open, Closed ), similar to parallel $A ^ { * }$ . It is easy to implement a state expansion policy which seems similar to sequential GBFS, e.g., “expand a state with the best heuristic value in the (shared) Open list”. However the resulting state expansion behavior of such a parallel GBFS can deviate drastically from that of sequential GBFS. This poses two issues:

(1) the relationship between the states expanded by parallel vs. sequential GBFS is nontrivial to analyze theoretically, and it is difficult to answer basic questions such as: “what is the worst-case performance of this parallel GBFS relative to sequential GBFS?” (2) For some problems, the empirical performance of parallel GBFS is much worse than sequential GBFS, resulting in orders of magnitude of slowdown on some IPC benchmarks (Kuroiwa and Fukunaga 2019), and in general, the number of states expanded by simple approaches to parallel GBFS with shared Open and/or Closed lists is not bounded by a constant factor relative to sequential GBFS (Kuroiwa and Fukunaga 2020).

Previous work proposed PUHF (Kuroiwa and Fukunaga 2020), a parallel GBFS algorithm which is constrained to only expand states in the Bench Transition System (BTS), the set of states that can be expanded by some tie-breaking strategy for GBFS (Heusner, Keller, and Helmert 2017). The BTS provides a natural theoretical constraint on the states expanded by an algorithm which “behaves similarly to sequential GBFS”, somewhat analogous to the (much stronger) constraint that a parallel $A ^ { * }$ must expand all states with evaluation value less than the optimal. However, although PUHF guarantees that only states in the BTS are expanded, it does not guarantee a bound on the number of states expanded compared to sequential GBFS, i.e., PUHF provides a qualitative guarantee about search behavior, but it does not provide any performance guarantee.

Thus, previous parallel GBFS algorithms with shared Open/Closed lists pose an unbounded risk – on any given instance, parallel GBFS may outperform sequential GBFS, or it may perform much worse, with no known general bound on how badly search performance can degrade. In this paper, we directly address the problem of establishing a bound on the number of states expanded by parallel GBFS relative to sequential GBFS. While PUHF constrained expansion to only states which could be expanded by sequential GBFS with some tie-breaking strategy, we propose a new algorithm which further constrains the search so that it explores only one bench at a time. This allows us to bound the number of state expansions by parallel search to be no worse than the number of states expanded by sequential search with some tie-breaking policy plus a small constant.

The main contributions of this paper are: (1) We propose One Bench At a Time (OBAT), the first parallel search algorithm with shared Open/Closed lists with a guaranteed bound on the number of expansions relative to sequential GBFS. (2) We show that this theoretical guarantee does not require sacrificing practical performance – OBAT, combined with SGE (a method that parallelizes both state generation and evaluation) (Shimoda and Fukunaga 2024b), performs comparably to baselines which have no such guarantee.

The rest of the paper is structured as follows. After a review of preliminaries and background (Sec. 2), we first show that the number of states expanded by PUHF is not bounded by a constant multiple of the number of states expanded by GBFS with the worst-case tie-breaking strategy (Sec. 3). We then propose One Bench At a Time (OBAT), which guarantees that the number of states expanded is within a constant factor of the number expanded by sequential GBFS with some tie-breaking policy (Sec. 4-5). We also propose ${ \mathrm { O B A T } } _ { S }$ , which significantly improves the state evaluation rate by using SGE (Sec. 6). We experimentally show that although the number of states expanded by OBAT is competitive with previous parallel algorithms, the state evaluation rate is significantly lower. However, we show that $\mathrm { \ O B A T } _ { S }$ is competitive with previous methods (Sec. 7). An extended version of this paper which includes the Supplement (additional technical details) is available (Shimoda and Fukunaga 2024a).

# 2 Preliminaries and Background

State Space Topology State space topologies are defined following Heusner, Keller, and Helmert (2018).

Definition 1. A state space is a 4-tuple $\begin{array} { r l } { s } & { { } = } \end{array}$ $\langle S , s u c c , s _ { i n i t } , S _ { g o a l } \rangle$ , where $S$ is a finite set of states, succ : $S  2 ^ { S }$ is the successor function, $s _ { i n i t } \in S$ is the initial state, and $S _ { g o a l } \subseteq S$ is the set of goal states. If $s ^ { \prime } \in s u c c ( s )$ , we say that $s ^ { \prime }$ is a successor of $s$ and that $s  s ^ { \prime }$ is a (state) transition. $\forall s \in S _ { g o a l } , s u c c ( s ) = \emptyset$ . A heuristic for $s$ is a function $h : S  \mathbb { R }$ and $\forall s \in S _ { g o a l } , h ( s ) = 0$ . A state space topology is a pair $\langle S , h \rangle$ , where $s$ is a state space.

We call a sequence of states $\langle s _ { 0 } , . . . , s _ { n } \rangle$ a path from $s _ { 0 }$ to $s _ { n }$ , and denote the set of paths from $s$ to $s ^ { \prime }$ as $P ( s , s ^ { \prime } )$ . $s _ { i }$ is the $i$ th state in a path $p$ and $| p |$ is the length of $p$ . A solution of a state space topology is a path $p$ from $s _ { i n i t }$ to a goal state. We assume at least one goal state is reachable from $s _ { i n i t }$ , and $\forall s \in S , s \notin s u c c ( s )$ .

Best-First Search Best-First Search (BFS) is a class of search algorithms that use an evaluation function $f : S $ $\mathbb { R }$ and a tie-breaking strategy $\tau$ . BFS searches states in the order of evaluation function values $f$ -values). States with the same $f$ -value are prioritized by $\tau$ . In Greedy Best-First Search (GBFS; Doran and Michie 1966), $f ( s ) \stackrel { \cdot } { = } h ( s )$ .

K-Parallel GBFS (KPGBFS) K-Parallel BFS (Vidal, Bordeaux, and Hamadi 2010) is a straightforward, baseline parallelization of BFS. All $k$ threads share a single Open and Closed. Each thread locks Open to remove a state $s$ with the lowest $f$ -value in Open, locks Closed to check duplicates and add $s u c c ( s )$ to Closed, and locks Open to add

Algorithm 1: K-Parallel GBFS (KPGBFS)   

<html><body><table><tr><td></td><td>1:Open ← {Sinit},Closed ←{Sinit};∀i,si ←NULL 2: for i ← O,.., k -1 in parallel do > k is the number of threads</td></tr><tr><td>3:</td><td>loop</td></tr><tr><td>4:</td><td>whilesi=NULL do</td></tr><tr><td>5:</td><td>lock(Open)</td></tr><tr><td>6:</td><td>if∀j,sj = NULL then</td></tr><tr><td>7:</td><td>if Open = @ then</td></tr><tr><td>8:</td><td>unlock(Open); return NULL</td></tr><tr><td>9:</td><td>else</td></tr><tr><td>10:</td><td>Si ←top(Open);Open ← Open\{si}</td></tr><tr><td>11:</td><td>unlock(Open)</td></tr><tr><td>12:</td><td>if si ∈ Sgoal then return Si</td></tr><tr><td>13:</td><td>lock(Open),lock(Closed)</td></tr><tr><td>14:</td><td>for s' ∈ succ(si) do</td></tr><tr><td>15:</td><td>if s' Closed then</td></tr><tr><td>16:</td><td>Closed ← Closed U{s'}</td></tr><tr><td>17:</td><td>Open ← Open U{s'};</td></tr><tr><td>18: 19:</td><td>unlock(Open), unlock(Closed) Si←NULL</td></tr></table></body></html>

$s u c c ( s )$ to Open. KPGBFS is KPBFS with $f ( s ) = h ( s )$ .   
Algorithm 1 shows the pseudocode for KPGBFS.

T-bounded and T-pathological Kuroiwa and Fukunaga (2020) proposed the following in order to classify the quantitative behavior of parallel BSF algorithms.

Definition 2. Given a state space topology $\tau$ , a search algorithm $A$ is $t$ -bounded relative to search algorithm $B$ on $\tau$ iff $A$ performs no more than $t$ -times as many expansions as $B . A$ is $t$ -pathological relative to search algorithm $B$ on $\tau$ iff $A$ is not $t$ -bounded relative to $B$ on $\tau$ .

$A$ is $t$ -bounded relative to $B$ iff $A$ is $t$ -bounded relative to $B$ for all state space topologies. $A$ is $t$ -bounded relative to $B$ on state space topologies with the property $P$ iff $A$ is $t$ -bounded relative to $B$ for all state space topologies with $P$ .

$A$ is pathological relative to $B$ iff for all $t > 0$ there exists a state space topology $\tau$ , such that $A$ is $t$ -pathological relative to $B$ on $\tau . A$ is pathological relative to $B$ on state space topologies with property $P$ iff for all $t > 0$ there exists a state space topology $\tau$ with property $P$ such that $A$ is $t$ -pathological relative to $B$ on $\tau$ .

Kuroiwa and Fukunaga (2020) showed that straightforward parallelizations of GBFS with shared Open and/or Closed, including KPGBFS, are pathological.

Bench Transition Systems Heusner et al. (2017) defined progress states and bench transition systems in order to characterize the behavior of GBFS, building upon the definition of high-water marks by Wilt and Ruml (2014).

Definition 3. Let $\langle S , h \rangle$ be a state space topology with states $S$ and ${ \cal P } ( s ) = \{ p \dot { \in } { \cal P } ( s , s ^ { \prime } ) \mid s ^ { \prime } \stackrel { . } { \in } S _ { g o a l } \bar  \} \} \nonumber$ . The high-water mark of $s \in S$ is

$$
h w m ( s ) : = { \left\{ \begin{array} { l l } { \operatorname* { m i n } _ { p \in P ( s ) } ( \operatorname* { m a x } _ { s ^ { \prime } \in p } h ( s ^ { \prime } ) ) } & { { \mathrm { i f ~ } } P ( s ) \neq \emptyset } \\ { \infty } & { { \mathrm { o t h e r w i s e } } } \end{array} \right. }
$$

The high-water mark of a set of states $S ^ { \prime } \subseteq S$ is defined as

$$
h w m ( S ^ { \prime } ) : = \operatorname* { m i n } _ { s \in S ^ { \prime } } h w m ( s )
$$

Definition 4. A state $s$ of a state space topology $\langle S , h \rangle$ is a progress state iff $h w m ( s ) > h w m ( s u c c ( s ) )$ .

Definition 5. Let $\langle S , h \rangle$ be a state space topology with a set of states $S$ . Let $s \in S$ be a progress state.

The bench level of $s$ is $l \bar { e } v e \bar { l } ( s ) = h w m ( s u c c ( s ) )$ .

The inner bench states inner $( s )$ for $s$ consist of all states $s ^ { \prime \prime } \neq s$ that can be reached from $s$ on paths on which all states $s ^ { \prime } \neq s$ (including $s ^ { \prime \prime }$ itself) are non-progress states and satisfy $h ( s ^ { \prime } ) \leq l e v e l ( s )$ .

The bench exit states $e x i t ( s )$ for $s$ consist of all progress states $s ^ { \prime }$ with $h ( s ^ { \prime } ) = l e v e l ( s )$ that are successors of $s$ or of some inner bench state of $s$ .

The bench states states $( s )$ for $s$ are $\{ s \} \cup i n n e r ( s ) \cup$ $e x i t ( s )$ .

The bench induced by $s$ , denoted by $B ( s )$ , is the state space with states $s t a t e s ( s )$ , initial state $s$ , and goal states $e x i t ( s )$ . The successor function is the successor function of $S$ restricted to states $( s )$ without transitions to $s$ and from bench exit states $e x i t ( s )$ .

Definition 6. Let ${ \mathcal { T } } = \langle S , h \rangle$ be a state space topology with initial state $s _ { i n i t }$ . The bench transition system $B ( \tau )$ of $\tau$ is a directed graph $\langle V , E \rangle$ whose vertices are benches. The vertex set $V$ and directed edges $E$ are inductively defined as the smallest sets that satisfy the following properties:

1. $B ( s _ { i n i t } ) \in V$   
2. if $B ( s ) \in V$ , $s ^ { \prime } \in e x i t ( s )$ , and $s ^ { \prime }$ is a non-goal state, then $B ( s ^ { \prime } ) \in V$ and $\langle B ( s ) , { \dot { B } } ( s ^ { \prime } ) \rangle \in E$

Theorem 1. (Heusner, Keller, and Helmert 2017) Let $\boldsymbol { \mathcal { T } } =$ $\langle S , h \rangle$ be a state space topology with set of states $S$ and bench transition system $\langle V , E \rangle$ . For each state $s \in S$ , it holds that $s \in B ( s ^ { \prime } )$ for some $B ( s ^ { \prime } ) \in V$ iff there is a tie-breaking strategy with which GBFS expands $s$ .

BTS-Constrained Search By Theorem 1, the bench transition system $( B T S )$ defines the set of all states which are candidates for expansion by GBFS with some tie-breaking strategy.

Restricting the search to only expand states which are in the $B T S$ is a natural constraint for parallel GBFS.

Definition 7. A search algorithm is $B T S$ -constrained if it expands only states which are in the $B T S$ (Shimoda and Fukunaga 2023).

PUHF: A BTS-Constrained Parallel GBFS Kuroiwa and Fukunaga (2020) proposed Parallel Under High-water mark First (PUHF), a $B T S$ -constrained parallel GBFS. PUHF marks states which are guaranteed to be in the BTS as certain, and only expands states marked as certain. The criterion used by PUHF to mark states as certain was a restrictive, sufficient (but not necessary) condition for being in the BTS. Recently, looser sufficient conditions for marking states were proposed, resulting in PUHF2–4, which significantly improved performance over PUHF (Shimoda and Fukunaga 2023).

Constrained vs. Unconstrained Parallel GBFS More generally, we say that a best-first search algorithm is constrained if it expands the best state $s$ in OPEN only if $s$ satisfies some additional constraint $C$ . For example, PUHF is constrained, as it expands the best state in OPEN only if it is in the BTS. We say that a best-first search algorithm is unconstrained if it unconditionally expands the best state $s$ in OPEN. For example, KPGBFS is unconstrained.

SGE: Separate Generation and Evaluation Unconstrained parallel algorithms such as KPGBFS will unconditionally expand the top states in Open, so threads will be kept fully busy as long as Open is not empty. In contrast, constrained algorithms such as PUHF can only expand states when it is guaranteed that they satisfy some state expansion constraint. Even if Open is non-empty, threads will remain idle until a state which satisfies the expansion constraint becomes available. This results in lower evaluation rates compared to unconstrained algorithms (Kuroiwa and Fukunaga 2020; Shimoda and Fukunaga 2023).

Separate Generation and Evaluation (SGE) (Shimoda and Fukunaga 2024b) is an implementation technique for parallel search which parallelizes state evaluations in addition to expansions. This allows better utilization of threads which would otherwise be idle (waiting for a state which satisfies expansion constraints). The main idea is to decompose the expansion of state $s$ into separate units of work which can be parallelized: (1) successor generation, which generates the $\bar { s u c c } ( s )$ , the successors of $s$ , and (2) successor evaluation, which evaluates $s u c c ( s )$ .

In SGE, after a thread selects a state for expansion from the shared Open, it generates $s u c c ( s )$ , and inserts $s u c c ( s )$ into a shared Unevaluated queue. The evaluation of states in Unevaluated is done in parallel, taking precedence over selection of states for expansion (a thread will select a state for expansion from Open only if Unevaluated is currently empty). Evaluated states are not immediately inserted into Open. Instead, SGE inserts all members of $s u c c ( s )$ of $s$ simultaneously into Open, after they have all been evaluated This is so that the parallel search is able to prioritize $s u c c ( s )$ similarly to GBFS (otherwise, $s u c c ( s )$ can be expanded in a completely different order than by GBFS).

# 3 Pathological Behavior of PUHF

In this section, “PUHF” refers to PUHF (Kuroiwa and Fukunaga 2020) and PUHF2-4 (Shimoda and Fukunaga 2023) – although these PUHF variants use slightly different state expansion constraints, the arguments and conclusions below are unaffected by these differences.

While PUHF is guaranteed to only expand states in the BTS, previous work did not guarantee a bound on the number of states expanded relative to sequential GBFS. We show that in fact PUHF is pathological relative to sequential GBFS. The example we use in the proof motivates OBAT, the new bounded approach we propose in Section 4.

Consider the search space in Figure 1a. GBFS, under any tie-breaking policy must expand either $s _ { 0 }  s _ { 1 , 1 }  \mathbf { s _ { 2 , 1 } ^ { i } } \stackrel { \cdot } {  }$ $s _ { 3 , 1 } \to s _ { g o a l } , s _ { 0 } \to s _ { 1 , 2 } \to s _ { 2 , 2 } \to { \bf s _ { 3 , 2 } ^ { i } } \to s _ { 4 , 2 } \to s _ { g o a l } ,$ or $s _ { 0 }  s _ { 1 , 2 }  s _ { 2 , 3 }  \mathbf { s _ { 3 , 3 } ^ { i } }  s _ { 4 , 3 }  s _ { g o a l }$ where $\mathbf { s ^ { i } }$ denotes a line of $x$ states.

![](images/e1ccfe73ec91083b1266cdc1a84b56056563a60c84d4fe0cf8095c9c85beadc7.jpg)  
Figure 1: Pathological Search Behavior in PUHF

However, PUHF with $k \geq 2$ $k$ is the number of threads) may (depending on tie-breaking) expand states in the order: $s _ { 0 } \ { \stackrel { \cdot } { \to } } \ ( s _ { 1 , 1 } / \Sigma s _ { 1 , 2 } ) \to { \bf s _ { 2 , 1 } ^ { i } } \to ( \acute { s } _ { 2 , 2 } \& s _ { 2 , 3 } ) \to ( { \bf s _ { 3 , 2 } ^ { i } } \cup$ $\mathbf { s _ { 3 , 3 } ^ { i } } )  ( s _ { 4 , 2 } \& s _ { 4 , 3 } )  s _ { g o a l }$ pwahnedred $a \& b$ doefntohtesetshtat estsaateres $a$ $b$ in the BTS, and when they are expanded in this order, they satisfy the expansion criteria used by all previous variants of PUHF.

PUHF expands $3 x$ states (denoted by the boxes $s _ { 2 , 1 } , s _ { 3 , 2 }$ , $^ { s _ { 3 , 3 } ) }$ , as well as the 6 other non-goal states. For large $x$ , PUHF with $k \geq 2$ may expand 3 times the number of states expanded by GBFS with the worst-case tie-breaking policy.

By recursively nesting the structure of the search space in Figure 1a, we can construct the search space of Figure 1b. On this search space, following the reasoning above for Figure 1a, GBFS with the worst-case tie-breaking policy will expand $t + x + c$ states ( $\dot { } c$ is a constant). In contrast, PUHF may expand more than $x \cdot t$ , where $t$ can be made arbitrarily large. Thus, PUHF with $k \geq 2$ and any tie-breaking strategy is pathological relative to GBFS. PUHF is pathological relative to GBFS even if the heuristic is consistent. For example, consider an instance of the search space with the structure shown in Figure 1b, where all edge costs are 1. If we replace all $h$ -values by $h ^ { \prime }$ , such that $\boldsymbol { h ^ { \prime } } = \boldsymbol { h } / c$ , where $c$ is a sufficiently large constant such that $h / c < 1$ , then $h ^ { \prime }$ is consistent, but PUHF is pathological on this search space.

Why PUHF is pathological relative to GBFS even though it is BTS-constrained is that unlike GBFS, parallel algorithms such as PUHF can explore multiple benches simultaneously.

In Figure 1a, $s _ { 1 , 1 }$ and $s _ { 1 , 2 }$ are both progress states. The benches entered through $s _ { 1 , 1 }$ and $s _ { 1 , 2 }$ are both part of the BTS, and are candidates for exploration by GBFS. GBFS will expand either $s _ { 1 , 1 }$ or $s _ { 1 , 2 }$ and explore one of the corresponding benches, and cannot explore the other bench until exiting the first bench. On the other hand, PUHF can expand both $s _ { 1 , 1 }$ and $s _ { 1 , 2 }$ , causing both benches to be explored. As a result, although PUHF only expands states in the BTS, it can explore sets of benches which are not explored by GBFS with any one specific tie-breaking strategy.

# 4 One Bench At a Time (OBAT)

We now propose One Bench At a Time (OBAT), a BTSconstrained parallel BFS which behaves similarly to GBFS in that it is constrained to explore one bench at a time. The main idea is to enforce this constraint by carefully controlling the expansion of potential progress states so that if multiple potential progress states are expanded simultaneously, only the successors of one of these potential progress states are allowed to be inserted into Open. For example, if $s _ { 1 }$ and $s _ { 2 }$ are expanded simultaneously, and they are both potential progress states, then only the successors of $s _ { 1 }$ are inserted into Open, because if both $s u c c ( s _ { 1 } )$ and $s u c c ( s _ { 2 } )$ are inserted into Open, we may start to explore multiple benches simultaneously.

OBAT classifies states into two categories, $a$ -states and $b$ -states. A state $s$ is an $a$ -state if it does not have any successor with a lower $h$ -value than $h ( s )$ . An $a$ -state cannot be a progress state (because if $s ^ { \prime } \in s u c c ( s )$ and $h ( s ) \leq h ( s ^ { \prime } )$ , then $\bar { h } w m ( s ) \leq h w m ( s ^ { \prime } )$ , so if no successor of $s$ has a lower $h$ -value than $s$ , then $s$ cannot satisfy Definition 4). A state $s$ is a $b$ -state if it has a successor with a lower $h$ -value than $h ( s )$ . A $b$ -state is potentially a progress state. It is possible to determine whether a state is an $a$ -state or $b$ -state immediately after its successors are generated and their $h$ -values are evaluated.

If $s$ is an $a$ -state, OBAT proceeds normally as with standard GBFS, inserting its successors in Open. However, if $s$ is a $b$ -state, it is a potential progress state, so instead of inserting the successors of $s$ into Open, it inserts $s$ into Deferred , a priority queue (priority function is $h$ -value). A state $s$ in Deferred is “on hold” – its successors are not inserted in Open until $s$ is removed from Deferred. Thus, if multiple $b$ -states are simultaneously expanded from Open, Deferred prevents their successors from being simultaneously inserted into Open.

The sequence in which a state moves among the data structures in OBAT (i.e., its “life cycle”) depends on whether it is an $a$ -state or $b$ -state. $a$ -states are: (a1) generated and evaluated, (a2) inserted in Open and Closed, (a3) removed from Open. $b$ -states are: (b1) generated and evaluated, (b2) inserted in Open and Closed, (b3) removed from Open, (b4) inserted in Deferred, (b5) removed from Deferred.

Definition 8. A state is committed after it leaves Open or Deferred for the last time. Specifically, $a$ -states are committed after (a3), and $b$ -states are committed after (b5).

Definition 9. A state $s$ is completely expanded if it is committed and $s u c c ( s )$ have all been inserted in Open.

Algorithm 2 shows the pseudocode for OBAT. $\scriptstyle t o p ( Q )$ returns a highest priority (minimal $h$ -value, ties broken according to a tie-breaking policy) state from queue $Q$ . By convention, $h ( t o p ( Q ) ) = \infty$ if $Q$ is empty. For all threads in parallel, OBAT proceeds as follows.

When $h ( t o p ( D e f e r r e d ) ) \leq h ( t o p ( O p e n ) )$ (line 10) and $h ( t o p ( D e f e r r e d ) )$ is less than or equal to the minimal $h$ - value among all states currently being expanded by other threads (line 11), we pop $t o p ( D e f e r r e d )$ and insert its successors into Open, completing its expansion.

If $h ( t o p ( O p e n ) ) ~ < ~ h ( t o p ( D e f e r r e d ) )$ (line 20) and $h ( t o p ( O p e n ) )$ is less than or equal to the smallest $h$ -value among states currently being expanded by other threads (line 21), we set $s _ { i }$ to $t o p ( O p e n )$ , pop top(Open) (line 22), and generate $s u c c ( s _ { i } )$ .

If $s _ { i }$ is an $a$ -state (line 26), $s u c c ( s _ { i } )$ are inserted into Open (so $s _ { i }$ is completely expanded). If $s _ { i }$ is a $b$ -state (line 33), $s _ { i }$ is inserted into Deferred, and $s u c c ( s _ { i } )$ are not inserted anywhere, but they remain linked to $s _ { i }$ .

Lines 11 and 21 ensure that OBAT will not expand states with a higher $h$ -value than any state which is currently expanded by another thread. This is the same expansion constraint as PUHF2, so it follows directly from (Shimoda and Fukunaga 2023, Theorem 4) that:

# Proposition 1. OBAT is BTS-constrained.

Example of OBAT Search Behavior To illustrate the behavior of OBAT, consider an example run of OBAT with 2 threads on the search space in Figure 1a. First, one thread expands the initial state $s _ { 0 }$ . Since $s _ { 0 }$ does not have any successors with a smaller $h$ -value, $s _ { 1 , 1 }$ and $s _ { 1 , 2 }$ are both inserted in Open. Next, threads 1 and 2 remove $s _ { 1 , 1 }$ and $s _ { 1 , 2 }$ from Open, respectively and expand them. Since $s _ { 1 , 1 }$ and $s _ { 1 , 2 }$ both have successors with a smaller $h$ -value than themselves, $s _ { 1 , 1 }$ and $s _ { 1 , 2 }$ are both potential progress states, so they are both inserted into Deferred. Next, a state is removed from Deferred. Assume $s _ { 1 , 1 }$ is removed (the specific state depends on the tie-breaking policy). $s _ { 1 , 1 }$ is completely expanded $( s u c c ( s _ { 1 , 1 } )$ are inserted into Open). Then, both threads will search the line of states $s _ { 2 , 1 } ^ { 1 } , . . , s _ { 2 , 1 } ^ { x }$ , and then $s _ { 3 , 1 }$ , reaching the goal. Thus, whenever OBAT selects for expansion a potential progress state $\cdot { s _ { 1 , 1 } }$ and $s _ { 1 , 2 }$ in this example), OBAT defers them, and will only completely expand one of them, thereby preventing simultaneous exploration of multiple benches.

# 5 Analysis of State Expansions by OBAT

We now compute a bound on the number of states expanded by OBAT. The number of states expanded by OBAT is the sum of (1) the number of completely expanded states and (2) the number of states remaining in Deferred when the algorithm terminates.

Theorem 2. The number of states completely expanded by OBAT is less than or equal to the number of states expanded by GBFS with some tie-breaking policy.

Proof. Let $\quad s _ { 1 } , s _ { 2 } , s _ { 3 } \ldots$ be a serialized ordering of the states which are completely expanded by OBAT, in the order in which they are committed. We show that there exists a tiebreaking policy for sequential GBFS which expands states in this same order. The proof is by induction. For both sequential GBFS and OBAT, the first (completely) expanded state $s _ { 1 }$ corresponds to the initial state $s _ { i n i t }$ . Next, assume that for the ordering $s _ { 1 } , . . . , s _ { i }$ , there exists a tie-breaking policy for GBFS which expands states in that order. We show that there exists a tie-breaking policy for sequential GBFS which will expand $s _ { i + 1 }$ after $s _ { i }$ .

When sequential GBFS removes $s _ { i + 1 }$ from Open, the set of states in Open are $\cup _ { k = 1 } ^ { k = i } s u c c ( s _ { k } ) \backslash \bigcup _ { k = 1 } ^ { k = i } s _ { k }$ (the set of all generated states minus the set of all expanded states). Now consider when OBAT commits $s _ { i + 1 }$ . Let $A$ and $B$ denote the set of $a$ -states and $b$ -states currently being expanded by other threads. Let $A ^ { \prime }$ denote the set of successors of all states in $A$ $\begin{array} { r } { . \bigcup _ { k = 1 } ^ { k = i } s u c c ( s _ { k } ) \backslash \bigcup _ { k = 1 } ^ { k = i } s _ { k } = ( O p e n \cup D e f e r r e d \cup B \cup } \end{array}$ $( A ^ { \prime } \setminus \bigcup _ { k = 1 } ^ { k = i } s _ { k } ) ,$ ). $s _ { i + 1 }$ has the smallest $h$ -value among all states in Deferred Open.

Algorithm 2: One Bench At a Time (OBAT)   

<html><body><table><tr><td>1: Open ← {Sinit},Closed ← {Sinit};∀i,si ← NULL 2:for i ←O,.., k-1in parallel do</td><td></td></tr><tr><td></td><td></td></tr><tr><td>loop</td><td></td></tr><tr><td>3:</td><td></td></tr><tr><td>4:</td><td>while si = NULL do</td></tr><tr><td>5:</td><td>lock(Open),lock(Deferred)</td></tr><tr><td>6:</td><td>if Open =Dand Deferred=の then</td></tr><tr><td>7:</td><td>if∀j,sj = NULL then</td></tr><tr><td>8:</td><td>unlock(Open), unlock(Deferred); return NULL</td></tr><tr><td>9:</td><td>else</td></tr><tr><td>10:</td><td>if h(top(Deferred)) ≤ h(top(Open)) then</td></tr><tr><td>11:</td><td>if h(top(Deferred)) ≤mino≤j<kh(sj) then</td></tr><tr><td>12:</td><td>s ← top(Deferred)</td></tr><tr><td>13:</td><td>Deferred ← Deferred\{s}</td></tr><tr><td>14:</td><td>lock(Closed)</td></tr><tr><td>15:</td><td>for s' E succ(s) do</td></tr><tr><td>16:</td><td>if s' Closed then</td></tr><tr><td>17:</td><td>Closed ← Closed U{s'}</td></tr><tr><td>18:</td><td>Open ← Open U{s'}</td></tr><tr><td>19:</td><td>unlock(Closed) s is completely expanded</td></tr><tr><td>20:</td><td>else</td></tr><tr><td>21:</td><td> if h(top(Open)) ≤mino≤j<kh(sj) then</td></tr><tr><td>22:</td><td>Si ← top(Open); Open ← Open\{si}</td></tr><tr><td>23:</td><td>unlock(Open),unolock(Deferred)</td></tr><tr><td>24:</td><td>if si E Sgoal then</td></tr><tr><td>25:</td><td>return Path(si)</td></tr><tr><td>26:</td><td>if h(si) ≤ min(h(succ(si))) then</td></tr><tr><td>27:</td><td>lock(Open), lock(Closed)</td></tr><tr><td>28:</td><td>for s' ∈ succ(si) do</td></tr><tr><td>29:</td><td>if s'  Closed then</td></tr><tr><td>30:</td><td>Closed ← Closed U{s'}</td></tr><tr><td>31:</td><td>Open ← Open U {s'}</td></tr><tr><td>32:</td><td>unlock(Open), unlock(Closed) si is completely expanded</td></tr><tr><td>33:</td><td>else</td></tr><tr><td>34:</td><td>lock(Deferred)</td></tr><tr><td>35:</td><td>Deferred ← Deferred U {si}</td></tr><tr><td>36:</td><td>unlock(Deferred)</td></tr><tr><td>37:</td><td>Si ← NULL</td></tr></table></body></html>

$A \cup B$ cannot contain any states taken from Deferred, because Open and $D$ eferred are locked while a thread removes a state from $D$ eferred and inserts its successors into Open, so this cannot occur simultaneously with the complete expansion of $s _ { i + 1 }$ , which requires access to Open and Deferred . Thus, all states in $A \cup B$ were taken from Open. All states in $B$ will later be inserted in Deferred , so are not in $s _ { 1 } , . . . s _ { i }$ . All states in $A$ will be included in $s _ { 1 } , . . . , s _ { i }$ . By definition, $a$ -states do not have any successors with a smaller $h$ -value than itself.

Due to lines 11 and 21, $h ( s _ { i + 1 } ) \leq h ( c ) \forall c \in ( A \cup B )$ .

Therefore, $h ( s _ { i + 1 } ) \leq m i n _ { a \in A } h ( a ) \leq m i n _ { u \in A ^ { \prime } } h ( u )$ . Thus, $h ( s _ { i + 1 } )$ has the smallest $h$ -value among (Open Deferred $B \cup ( A ^ { \prime } \setminus \bigcup _ { k = 1 } ^ { k = i } s _ { k } ) \rangle$ ).

This implies, $s _ { i + 1 }$ has the smallest $h$ -value in Open after GBFS expands $s _ { i }$ , so there exists a tie-breaking policy for sequential GBFS which will select $s _ { i + 1 }$ for expansion immediately after $s _ { i }$ . Thus, there exists a tie-breaking policy for GBFS which expands states in the same order as they are committed in OBAT. Therefore, the number of states completely expanded by OBAT is less than or equal to the number of states expanded by GBFS with the worst-case tiebreaking policy. □

To bound the number of states in Deferred when OBAT terminates, we bound the number of different $h$ -values for which there is a state in $D$ eferred (Lemma 1) and the number of states per $h$ -value (Lemma 2).

Lemma 1. When OBAT terminates after finding a solution path $p$ , the number of $h$ -values for which at least one state is in Deferred is at most $| p |$ .

Proof. Let $p = s _ { 1 } , s _ { 2 } , . . . , s _ { n }$ be the sequence of all states on the solution path (in the order they appear in the solution path), such that all states after $s _ { i }$ on the solution path have a smaller $h$ -value than $s _ { i }$ . From the definition of $p$ , all states in the solution path between $s _ { i }$ and $s _ { i + 1 }$ have an $h$ -value less than or equal to $h ( s _ { i + 1 } )$ . Thus, after the successors of $s _ { i }$ are inserted in Open, there is a state with $h$ -value less than or equal to $h ( s _ { i + 1 } )$ in Open, Deferred, or a state currently being expanded by some thread. OBAT will not select a state from Open with a $h$ -value larger than a state currently being expanded by some thread (lines 11 and 21), so between the time after the successors of $s _ { i }$ are inserted in Open and $s _ { i + 1 }$ is completely expanded, no states with $h$ -values larger than $h ( s _ { i + 1 } { \bar { ) } }$ will be removed from Open.

States with $h$ -value less than $h ( s _ { i + 1 } )$ will have higher priority for expansion than $s _ { i + 1 }$ , so no such state can be in Deferred when $s _ { i + 1 }$ is expanded. Thus, in the time between when $s _ { i }$ is completely expanded, and when $s _ { i + 1 }$ is removed from Deferred and committed, the only states which can be removed from Open and inserted into Deferred (and can remain in Deferred after OBAT terminates) have an $h$ -value of $h ( s _ { i + 1 } )$ . Similarly, for the base case $( s _ { 1 } )$ , the only states which can be removed from Open before $s _ { 1 }$ and might remain in Deferred after OBAT terminates have a $h$ -value of $h { \big ( } s _ { 1 } { \big ) }$ . Therefore, the only possible $h _ { - }$ - values of states in Deferred when OBAT terminates are $h ( s _ { 1 } ) , h ( s _ { 2 } ) , . . . , h ( s _ { n } )$ , which is $\leq n$ unique values. □

Lemma 2. At all times, for every $h$ -value, Deferred contains at most $k$ states, where $k$ is the number of threads.

Proof. Assume that Deferred contains $k { + 1 }$ states which all have the same $h$ -value. By the pigeonhole principle, there must be 2 such states $s _ { 1 }$ and $s _ { 2 }$ , which were inserted into Deferred by the same thread $T$ , where $s _ { 1 }$ was inserted before $s _ { 2 }$ . States in Deferred come from Open, i.e., a state is inserted in Deferred only after it is removed from Open. Therefore, for $s _ { 2 }$ to be inserted into Deferred , it must first be removed from Open, and by assumption, at that time, $s _ { 1 }$ is already in Deferred. However, if $h ( t o p ( O p e n ) ) \ =$ $h ( t o p ( D e f e r r e d ) )$ , then OBAT will remove a state from Deferred (Algorithm 2, line 12), so $s _ { 2 } ~ \in ~ O p e n$ will not be removed before $s _ { 1 } \in D e f e r r e d$ , a contradiction. □

Lemma 1 and Lemma 2 directly give us a bound on the number of states in Deferred when OBAT terminates.

Theorem 3. When OBAT terminates after finding a solution path $p$ , the number of states which remain in Deferred is less than or equal to $k | p |$ , where $k$ is the number of threads.

Finally, from Theorem 2 and Theorem 3, we have the following bound on the number of states expanded:

Theorem 4. The number of states expanded by OBAT is at most $N _ { g b f s } + k | p |$ , where $N _ { g b f s }$ is the number of states expanded and $p$ is the solution path found by GBFS with the tie-break policy which maximizes $N _ { g b f s } + k | p |$ .

As an aside, since $| p | \leq N _ { g b f s }$ , OBAT is $t$ -bounded relative to GBFS with the tie-break policy which maximizes $N _ { g b f s } +$ $k | p |$ , where $t = k + 1$ . However, $N _ { g b f s }$ is usually much larger than $| p |$ , so the bound in Theorem 4 is more meaningful than the $t$ -boundedness.

# 6 $\mathbf { O B A T } _ { S }$ : OBAT with SGE

Like PUHF and its variants, OBAT is a constrained parallel GBFS, and threads can be forced to be idle while they wait until a state which is guaranteed to satisfy the expansion constraint becomes available, resulting in worse performance than unconstrained algorithms such as KPGBFS which never leave threads idle. As with PUHF, this issue can be alleviated using Separate Generation and Evaluation (Shimoda and Fukunaga 2024b), an implementation technique which decouples successor generation and evaluation to reduce idle waiting.

Applying SGE to OBAT is straightforward. Algorithm S.1 in the Supplement (Shimoda and Fukunaga 2024a) shows $\operatorname { O B A T } _ { S }$ , which is OBAT with SGE. As SGE does not change the set of states which are possibly expanded, it can be proven straightforwardly that the upper bound on the number of states expanded by OBAT (Theorem 4) also holds in $\operatorname { O B A T } _ { S }$ .

# 7 Experimental Evaluation

We evaluated the performance of OBAT and $\mathrm { O B A T } _ { S }$ with 4, 8, 16 threads. As baselines, we also evaluate KPGBFS, ${ \mathrm { K P G B F S } } _ { S }$ (KPGBFS with SGE), PUHF3, $\mathrm { P U H F } 3 _ { S }$ (PUHF3 with SGE) , and single-thread GBFS.

Experimental Settings We compared the algorithms using a set of instances based on the Autoscale-21.11 satisficing benchmark set (42 STRIPS domains, 30 instances/- domain, 1260 total instances) (Torralba, Seipp, and Sievers 2021), an improved benchmark suite based on the IPC classical planning benchmarks. However, for domains where (1) all methods solved all instances (i.e., the instances were too easy for the purpose of comparing the performance of KPGBFS vs. OBAT), and (2) an instance generator for the domain is available in the Autoscale repository, we replaced the Autoscale-21.11 instances with more difficult instances generated using the Autoscale generator. Specifically, the domains where criteria (1) and (2) above applied were gripper and miconic. See Supplement Section S.2 (Shimoda and Fukunaga 2024a) for additional details, including instance generator parameters.

All algorithms use the FF heuristic (Hoffmann and Nebel 2001). Each run had a time limit of 5 min., 3GB RAM/thread (e.g., 8 threads: 24GB total) limit on an Intel Xeon CPU $\mathrm { E 5 - } 2 6 7 0 ~ \mathrm { v } 3 @ 2 . 3 0 \mathrm { G H z }$ processor. All tie-breaking is FIFO. The code is available at https://github.com/TakuShimoda/ AAAI25.

Results Table 1a shows the total coverage (number of instances solved out of 1260) for 4/8/16 threads. Table 1b shows per-domain coverage for 16 threads. Figure 2 compares the number of states expanded by the algorithms. Figure 3 compares the state evaluation rates of the algorithms.

![](images/56e2e9e7df27c52e5e231a1734b5996fd76405e9fdb61773d3c2022c7718f7e0.jpg)  
Figure 3: State evaluation rates (states/second), 16 threads. Diagonal lines are $y = 0 . 1 x$ , $y = x$ , and $y = 1 0 x$

Additional figures comparing number of state expansions, state evaluation rates, and search time including data for 4 and 8 threads, are in the Supplement, Figures 1-6.

Compared to KPGBFS, OBAT expands significantly fewer states (Figure 2, left). However, OBAT has significantly lower state evaluation rates than KPBGFS (Figure 3 top left). This results in significantly lower total coverage than KPGBFS (Table 1a), although the difference is domaindependent, e.g., OBAT significantly outperforms KPGBFS on openstacks. Compared to PUHF3, OBAT also expands fewer states (Figure 2, middle) has a lower evaluation rate (Figure 3 top right), and has comparable total coverage. Thus, the expansion constraint appears to enable OBAT to search good regions of the search space, at the cost of low evaluation rates.

$\mathrm { O B A T } _ { S }$ has a significantly higher evaluation rate than OBAT (Figure 3, bottom left) and a comparable number of state expansions (Figure 2, right), showing that SGE significantly alleviates the drawback of OBAT without sacrificing search efficiency. As a result, $\mathrm { O B A T } _ { S }$ achieves significantly higher coverage than OBAT (Table 1a).

Overall, ${ \mathrm { O B A T } } _ { S }$ achieves coverage competitive with all other methods for 4/8/16 threads, showing that the guaranteed bound on the number of expansions does not require sacrifing practical performance. As shown in Table 1b, none of the algorithms clearly dominate the others, and comparative performance is domain-dependent. Despite the state evaluation rate boost due to SGE, $\mathrm { O B A T } _ { S }$ still has a significantly lower evaluation rate than ${ \mathrm { K P G B F S } } _ { S }$ and $\mathrm { P U H F } 3 _ { S }$ (Figure 3, bottom middle and right) – further decreasing the evaluation rate gap (improving thread utilization) while maintaining search efficiency is a direction for future work.

# 8 Conclusion

We proposed OBAT, a parallel GBFS algorithm which, to our knowledge, is the first parallel GBFS with a shared Open list that guarantees a bound on the number of states (b) Coverage (number of problems solved) per domain on Autoscale-21.11 IPC-based planning benchmark set (1260 instances total; gripper, and miconic are replaced with harder instances. See S.2) for $k { = } 1 6$ threads (except $k { = } 1$ for GBFS).

(a) Coverage (number of problems solved out of 1260)   

<html><body><table><tr><td>#threads</td><td>1 thread</td><td>4 threads</td><td>8 threads</td><td>16 threads</td></tr><tr><td>GBFS</td><td>401</td><td colspan="3"></td></tr><tr><td>KPGBFS</td><td></td><td>462</td><td>488</td><td>529</td></tr><tr><td>KPGBFS s</td><td>-</td><td>472</td><td>500</td><td>532</td></tr><tr><td>PUHF3</td><td></td><td>459</td><td>477</td><td>494</td></tr><tr><td>PUHF3 s</td><td></td><td>468</td><td>494</td><td>510</td></tr><tr><td>OBAT</td><td></td><td>458</td><td>477</td><td>496</td></tr><tr><td>OBATs</td><td></td><td>478</td><td>506</td><td>532</td></tr></table></body></html>

Table 1: Coverage results   

<html><body><table><tr><td></td><td></td><td>B R</td><td></td><td>P</td><td>P</td><td>A 88</td><td>A BR</td></tr><tr><td>agricola</td><td>26</td><td>30</td><td>30</td><td>30</td><td>30</td><td>30</td><td>30</td></tr><tr><td>airport</td><td>18</td><td>17</td><td>18</td><td>17</td><td>19</td><td>15</td><td>18</td></tr><tr><td>barman</td><td>2</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>5</td></tr><tr><td>blocksworld</td><td>6</td><td>7</td><td>7</td><td>7</td><td>8</td><td>6</td><td>7</td></tr><tr><td>childsnack</td><td>4</td><td>5</td><td>3</td><td>5</td><td>4</td><td>4</td><td>4</td></tr><tr><td>data-network</td><td>4</td><td>7</td><td>6</td><td>6</td><td>4</td><td>5</td><td>5</td></tr><tr><td>depots</td><td>4</td><td>5</td><td>5</td><td>4</td><td>4</td><td>4</td><td>4</td></tr><tr><td>driverlog</td><td>4</td><td>7</td><td>8</td><td>8</td><td>8</td><td>7</td><td>9</td></tr><tr><td>elevators</td><td>11</td><td>18</td><td>19</td><td>20</td><td>20</td><td>20</td><td>19</td></tr><tr><td>floortile</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>freecell</td><td>20</td><td>24</td><td>23</td><td>21</td><td>22</td><td>22</td><td>25</td></tr><tr><td>ged</td><td>7</td><td>9</td><td>9</td><td>7</td><td>8</td><td>10</td><td>8</td></tr><tr><td>grid</td><td>5</td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr><tr><td>gripper (replaced)</td><td>2</td><td>7</td><td>21</td><td>7</td><td>20</td><td>19</td><td>20</td></tr><tr><td>hiking</td><td>4</td><td>14</td><td>9</td><td>11</td><td>8</td><td>10</td><td>9</td></tr><tr><td>logistics</td><td>4</td><td>6</td><td>6</td><td>5</td><td>5</td><td>6</td><td>6</td></tr><tr><td>miconic (replaced)</td><td>10</td><td>9</td><td>15</td><td>9</td><td>15</td><td>10</td><td>21</td></tr><tr><td>mprime</td><td>4</td><td>6</td><td>6</td><td>6</td><td>6</td><td>5</td><td>5</td></tr><tr><td>nomystery</td><td>6</td><td>14</td><td>11</td><td>11</td><td>11</td><td>3</td><td>6</td></tr><tr><td>openstacks</td><td>7</td><td>12</td><td>11</td><td>11</td><td>11</td><td>15</td><td>22</td></tr><tr><td>organic-synthesis-split</td><td>9</td><td>17</td><td>17</td><td>16</td><td>16</td><td>13</td><td>16</td></tr><tr><td>parcprinter</td><td>30</td><td>30</td><td>30</td><td>30</td><td>30</td><td>30</td><td>30</td></tr><tr><td>parking</td><td>6</td><td>9</td><td>10</td><td>9</td><td>9</td><td>9</td><td>10</td></tr><tr><td>pathways</td><td>11</td><td>15</td><td>12</td><td>10</td><td>12</td><td>11</td><td>12</td></tr><tr><td></td><td>30</td><td>30</td><td>30</td><td>30</td><td>30</td><td>30</td><td>30</td></tr><tr><td>pegsol</td><td></td><td></td><td>9</td><td></td><td>9</td><td>9</td><td></td></tr><tr><td>pipesworld-notankage</td><td>8</td><td>11</td><td></td><td>9</td><td></td><td></td><td>11</td></tr><tr><td>pipesworld-tankage</td><td>9</td><td>12</td><td>12</td><td>11</td><td>11</td><td>12</td><td>12</td></tr><tr><td>rovers</td><td>26</td><td>27</td><td>27</td><td>26</td><td>26</td><td>26</td><td>26</td></tr><tr><td>satellite</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td>scanalyzer</td><td>7</td><td>11</td><td>11</td><td>11</td><td>11</td><td>11</td><td>11</td></tr><tr><td>snake</td><td>7</td><td>10</td><td>10</td><td>9</td><td>9</td><td>9</td><td>9</td></tr><tr><td>sokoban</td><td>16</td><td>23</td><td>22</td><td>21</td><td>21</td><td>19</td><td>19</td></tr><tr><td>storage</td><td>3</td><td>2</td><td>4</td><td>4</td><td>4</td><td>3</td><td>4</td></tr><tr><td>termes</td><td>12</td><td>18</td><td>18</td><td>16</td><td>18</td><td>15</td><td>16</td></tr><tr><td>tetris</td><td>8</td><td>13</td><td>12</td><td>13</td><td>12</td><td>13</td><td>13</td></tr><tr><td>thoughtful</td><td>14</td><td>21</td><td>18</td><td>19</td><td>16</td><td>16</td><td>14</td></tr><tr><td>tidybot</td><td>12</td><td>14</td><td>13</td><td>12</td><td>11</td><td>14</td><td>13</td></tr><tr><td>tpp</td><td>8</td><td>10</td><td>11</td><td>9</td><td>10</td><td>11</td><td>12</td></tr><tr><td>transport</td><td>5</td><td>8</td><td>7</td><td>8</td><td>7</td><td>7</td><td>7</td></tr><tr><td>visitall</td><td>14</td><td>20</td><td>19</td><td>13</td><td>14</td><td>15</td><td>16</td></tr><tr><td>woodworking</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>zenotravel</td><td>7</td><td>11</td><td>12</td><td>12</td><td>10</td><td>11</td><td>11</td></tr><tr><td></td><td>401</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Sum(1260)</td><td></td><td>529</td><td>532</td><td>494</td><td>510</td><td>496</td><td>532</td></tr></table></body></html>

expanded relative to sequential GBFS. The worst-case gap in the number of state expansions between OBAT and sequential GBFS is the gap between the best-case sequential GBFS tie-breaking policy and the worst-case sequential GBFS tiebreaking policy.

These results establish a close relationship between parallel greedy best-first search and theoretical work in tiebreaking policies and opens interesting avenues for future work – for example, any upper bound on the gap between best vs. worst-case tie-breaking will also imply an upper bound on the gap between sequential and parallel greedy best-first search.

We showed experimentally that while OBAT achieves search efficiency competitive with previous shared-Open parallel GBFS algorithms, the state evaluation rate was significantly lower than previous algorithms. Finally, we showed that applying SGE to OBAT significantly increases the state evaluation rate of OBAT, resulting in overall performance which is comparable to previous methods, at least up to 16 threads. Investigating and improving scalability to larger number of threads is a direction for future work.

# Acknowledgments

This research was supported by JSPS KAKENHI Grant 24K15083.