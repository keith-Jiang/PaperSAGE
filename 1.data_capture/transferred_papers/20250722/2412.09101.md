# Temporal Numeric Planning with Patterns

Matteo Cardellini, Enrico Giunchiglia

DIBRIS, Universita\` degli Studi di Genova, Italy matteo.cardellini@edu.unige.it, enrico.giunchiglia $@$ unige.it

# Abstract

We consider temporal numeric planning problems $\Pi$ expressed in PDDL 2.1 level 3, and show how to produce SMT formulas $( i )$ whose models correspond to valid plans of $\Pi$ , and $( i i )$ that extend the recently proposed planning with patterns approach from the numeric to the temporal case. We prove the correctness and completeness of the approach and show that it performs very well on 10 domains with required concurrency.

# Introduction

We consider temporal numeric planning problems expressed in PDDL 2.1 level 3 (Fox and Long 2003). Differently from the classical case, where plans are sequences of instantaneous actions and variables are Boolean, in these problems actions may have a duration, are executed concurrently over time, and can affect Boolean and numeric variables at both the start and end of their execution. These two extensions make the problem of finding a valid plan much more difficult –even undecidable in the general case (Helmert 2002; Gigante et al. 2022)– and extending state-of-the-art solving techniques from the classical/numeric to the temporal numeric setting is far from easy.

In this paper, we extend the recently proposed Symbolic Pattern Planning (SPP) approach (Cardellini, Giunchiglia, and Maratea 2024) to handle temporal numeric problems. Specifically, given one such problem $\Pi$ and a bound $n \in$ ${ \mathbb { N } } ^ { \geq 0 }$ , we show how to produce a Satisfiability Modulo Theory (SMT) formula (Barrett et al. 2021) $( i )$ whose models correspond to valid plans of $\Pi$ (correctness), $( i i )$ which is ensured to be satisfiable for some value of the bound $n$ when $\Pi$ has a valid plan (completeness), and $( i i i )$ which is equivalent to the pattern encoding proposed by Cardellini, Giunchiglia, and Maratea when the problem is numeric, i.e., when all the actions are instantaneous. These results significantly advance the state-of-the-art, as all symbolic temporal numeric planners are based on the standard encoding with effect and explanatory frame axioms. Given this, we expect to obtain also in the temporal setting the substantial improvements achieved in the numeric case, where it was shown $( i )$ that the pattern encoding dominates (i.e., is able to produce valid plans with a bound $n$ possibly lower and never higher than) both the relaxed-relaxed $R ^ { 2 } \bar { \exists }$ encoding (Balyo 2013; Bofill, Espasa, and Villaret 2017), and the action rolling $R$ encoding (Scala et al. 2016b); $( i i )$ that both the $R ^ { 2 } \exists$ and $R$ encodings dominate the standard one, and $( i i i )$ that theoretical dominance leads to improved experimental performance, as shown by the analysis in (Cardellini, Giunchiglia, and Maratea 2024) on the numeric benchmarks of the 2023 International Planning Competition.

To test the effectiveness of our approach, we compare our planner with all publicly available temporal planners (both symbolic and based on search) on 10 temporal domains with required concurrency (Cushing et al. 2007). The results highlight the strong performances of our planner, which achieved the highest coverage (i.e., number of solved problems) in 9 out of 10 domains, while the second-best planner had the highest coverage in 4 domains. Additionally, compared to the other symbolic planners, our system is able to find a valid plan with a lower bound on all the problems.

The main contributions of this paper are thus:

1. We extend the SPP approach to handle temporal numeric problems specified in PDDL 2.1.   
2. We prove the correctness and completeness of our SMT encoding.   
3. We conduct an extensive comparative analysis with all available temporal numeric planners, both searchbased and symbolic-based, and show that our approach achieves the highest coverage in 9 out of 10 domains.

After the preliminary definitions, we present the basic ideas underlying current standard encodings in SMT, followed by the presentation of our approach, the experimental comparative analysis and the conclusions. A running example is used to illustrate the features of our encoding.

# Preliminaries

In PDDL2.1 (Fox and Long 2003) a temporal numeric planning problem is a tuple $\Pi = \langle V _ { B } , V _ { N } , A , I , G \rangle$ , where

1. $V _ { B }$ and $V _ { N }$ are finite sets of Boolean and numeric variables, ranging over $\{ \top , \bot \}$ and $\mathbb { Q }$ respectively,   
2. $I$ is a selected initial state, and a state is a function mapping each variable to an element in its domain,

3. $G$ is a finite set of conditions, called goals. A condition is either $v = \top$ or $v = \perp$ or $\psi \trianglerighteq { \geq } 0$ , with $v \in V _ { B }$ , $\psi$ a linear expression in $V _ { N }$ and $\underline { { \vartriangleright } } \in \left\{ < , \leq , = , \geq , > \right\}$ .

4. $A$ is a finite set of (instantaneous/snap) actions and durative actions. An action $a$ is a pair $\mathsf { \bar { \langle p r e ( } } a ) , \mathsf { e f f } ( a ) \rangle$ in which $( i ) \mathrm { \ p r e } ( a )$ are the (pre)conditions of $a$ , and $\dot { ( i i ) }$ $\operatorname { e f f } ( a )$ are the effects of $a$ of the form $v : = \top$ , $v : = \perp$ , $x : = \psi$ , with $v \in V _ { B }$ , $x \in V _ { N }$ and $\psi$ a linear expression in $V _ { N }$ . For each action $a$ , every variable $v \in V _ { B } \cup V _ { N }$ must occur in $\operatorname { e f f } ( a )$ at most once to the left of the assignment operator “: $= ^ { \ast }$ , and when this happens $\boldsymbol { v }$ is said to be assigned by $a$ . A durative action $b$ is a tuple $\langle b ^ { \vdash } , b ^ { \vdash } , b ^ { \dash } , \overline { { \lfloor L , U \rfloor } } \rangle$ , where $\boldsymbol { b } ^ { \vdash } , \boldsymbol { b } ^ { \vdash } , \boldsymbol { b } ^ { \scriptscriptstyle { - } 1 }$ are the actions starting, lasting and ending $b$ , respectively, and $L , U \in$ $\mathbb { Q } ^ { > 0 }$ are bounds on the duration $d$ of $b$ , $L \ \leq \ U$ . The action $b ^ { \mathsf { H } }$ has no effects, and its preconditions $\mathrm { p r e } ( b ^ { \mapsto } )$ must hold throughout the execution of $b$ . From here on, for simplicity, we consider only durative actions, as snap actions can be treated as durative actions without lasting and ending actions, as in (Panjkovic and Micheli 2023).

Let $\Pi = \langle V _ { B } , V _ { N } , A , I , G \rangle$ be a temporal numeric planning problem. A timed durative action is a pair $\left. t , b \right.$ with $t \in \mathbf { \mathbb { Q } } ^ { \geq 0 }$ and $b$ a durative action $\langle b ^ { \vdash } , b ^ { \lnot } , b ^ { \hat { \ l } } , [ \bar { L } , U ] \rangle$ in which $[ L , U ]$ is replaced with a single duration value $d \in [ L , U ] ;$ t (resp. $t + d )$ is the time in which $b ^ { \vdash }$ (resp. $b ^ { - 1 }$ ) is executed. A temporal (numeric) plan $\pi$ for $\Pi$ is a finite set of timed durative actions. Thus, in $\pi$ , multiple snap actions can be executed at the same time, but any two such actions $a$ and $a ^ { \prime }$ must be non mutex, i.e., $a$ must not interfere with $a ^ { \prime }$ , and vice versa. An action $a$ does not interfere with an action $a ^ { \prime }$ if for every variable $v$ assigned by $a$

1. $\boldsymbol { v }$ does not occur in the preconditions of $a ^ { \prime }$ , and   
2. if $v \in V _ { B }$ , either $\boldsymbol { v }$ is not assigned by $a ^ { \prime }$ or $v : = \top \in$ $\operatorname { e f f } ( a )$ if and only if $v : = { \top \in \bar { \mathrm { e f f } } ( a ^ { \prime } ) }$ , and   
3. if $v \in V _ { N }$ then either $v$ does not occur in the effects of $a ^ { \prime }$ or the only occurrences of $v$ in both $a$ and $a ^ { \prime }$ are within linear increments of $v$ . An expression $\boldsymbol { v } : = \boldsymbol { v } + \boldsymbol { \psi }$ is a linear increment of $v$ if $v$ does not occur in $\psi$ .

If $a$ and $a ^ { \prime }$ are not in mutex, the order in which they are executed in any state $s$ is not relevant, i.e., $r e s ( a , r e s ( a ^ { \prime } , s ) ) =$ $r e s ( a ^ { \prime } , r e s ( a , s ) )$ . The expression $\textstyle r e s ( a , s )$ is the result of executing $a$ in state $s$ , which $( i )$ is defined when $s$ satisfies the preconditions of $a$ , and $( i i )$ is the state $s ^ { \prime } = { }$ $r e s ( a , s )$ such that for each $v \in V _ { B } \cup V _ { N }$ , $s ^ { \prime } ( v ) = s ( e )$ if $v : = e \in \mathrm { e f f } ( a )$ , and $s ^ { \prime } ( v ) = s ( v )$ otherwise. Given a set $A = \{ a _ { 1 } , \ldots , \dot { a _ { n } } \}$ of pairwise non mutex actions, we write $r e s ( A , s )$ as an abbreviation for $r e s ( a _ { 1 } , \dots , r e s ( a _ { n } , s ) \dots )$ , order not relevant.

Consider a temporal plan $\pi$ . The execution of $\pi$ induces a sequence of states $s _ { 0 } , s _ { 1 } ; \ldots ; s _ { m }$ , each state $s _ { i }$ with an associated time $t _ { i } > t _ { i - 1 }$ at which a non empty set $A _ { i }$ of actions, each starting/ending a durative action in $\pi$ , is executed. The temporal plan $\pi$ is valid if:

1. $s _ { 0 }$ is the initial state, $s _ { i + 1 } = r e s ( A _ { i + 1 } , s _ { i } )$ and $s _ { m }$ satisfies the goal formulas, with $i \in [ 0 , m )$ ; 2. $\epsilon$ -separation: for any pair of mutex actions $a \in A _ { i }$ and $a ^ { \prime } \in A _ { j }$ , $| t _ { i } - t _ { j } | \geq \bar { \epsilon } > 0$ (and thus $i \neq j$ );

3. no self-overlapping: for any two distinct timed durative actions $\left. t , b \right.$ and $\langle t ^ { \prime } , b \rangle$ with durations $d$ and $d ^ { \prime }$ respectively, if $t ^ { \prime } \geq t$ in $\pi$ , then $t ^ { \prime } \geq t + d$ ;   
4. lasting-action: for each timed durative action $\langle t , \langle b ^ { \mapsto } , b ^ { \dashv } , b ^ { \mapsto } , d \rangle \rangle$ in $\pi$ , if $b ^ { \vdash }$ and $b ^ { - 1 }$ are executed at $t _ { i } = t$ and $t _ { j } = t _ { i } + d$ respectively, the preconditions of $b ^ { \mapsto }$ are satisfied in each state $s _ { i } , \ldots , s _ { j - 1 }$ .

We thus considered the standard notion of validity used, e.g., in (Fox and Long 2003; Rankooh and Ghassem-Sani 2015; Haslum et al. 2019; Panjkovic and Micheli 2024), in which, assuming $V _ { N } ~ = ~ \varnothing$ , the problem of deciding the existence of a valid temporal plan is in PSPACE. Other, more general definitions of plan validity can be given, relaxing the second condition to allow for $| t _ { i } - t _ { j } | > 0$ and/or removing the third condition. With such generalizations, the complexity of deciding the existence of a valid temporal plan, still with $V _ { N } = \emptyset$ , can become EXPSPACE-complete (Rintanen 2007) and can even become undecidable (Gigante et al. 2022).

# Standard Encodings in SMT

Several approaches for computing a valid plan of $\Pi$ have been proposed, either based on search (see, e.g., (Benton, Coles, and Coles 2012; Gerevini, Saetti, and Serina 2010; Eyerich, Mattmu¨ller, and R¨oger 2012)) or on planning as satisfiability (see, e.g., (Shin and Davis 2004, 2005; Rankooh and Ghassem-Sani 2015; Rintanen 2015; Cashmore et al. 2016; Rintanen 2017; Cashmore, Magazzeni, and Zehtabi 2020; Panjkovic and Micheli 2023, 2024)). We follow the second approach, in which $( i )$ a bound or number of steps $n$ (initially set to 0) is fixed, $( i i )$ a corresponding SMT formula is produced, and $( i i i )$ a valid plan is returned if the formula is satisfiable, while $n$ is increased and the previous step iterated, otherwise. In more detail, given a temporal numeric planning problem $\Pi = \langle V _ { B } , V _ { N } , A , I , G \rangle$ and a value for the bound $n \geq 0$ , in the second step, these works:

1. Make $n + 1$ copies of a set $\chi$ of state variables which includes $V _ { B } \cup V _ { N }$ , each copy $\mathcal { X } _ { i }$ meant to represent the state at the $i$ -th step; make $n$ copies of a set $\mathcal { A }$ of (Boolean) durative action variables which includes $A$ , each copy $\mathbf { \mathcal { A } } _ { i }$ meant to represent the durative actions executed at the $i$ - th step; and introduce a set $\{ t _ { 0 } , \ldots , t _ { n } \}$ of time variables, each $t _ { i }$ being the time associated to the $i$ -th state $\mathcal { X } _ { i }$ .   
2. Impose proper axioms defining the value of the variables in $\mathscr { X } _ { i + 1 }$ based on the values of the variables in ${ \mathbf { \mathcal { X } } } _ { i }$ , and of the snap actions which are executed in the state $\mathcal { X } _ { i }$ . In particular, these axioms enforce in the state $\mathscr { X } _ { i + 1 }$ the effects of the actions executed in the state $\mathcal { X } _ { i }$ , and also that no two mutex actions are executed in $\mathcal { X } _ { i }$ .

A similar construction underpins also the standard encoding used for classical and numeric planning problems. However, in these contexts, the standard encoding is known to underperform compared to the $R$ encoding by Scala et al. (2016b), the $R ^ { 2 } \exists$ encoding by Bofill, Espasa, and Villaret (2016), and the pattern $\prec$ -encoding by Cardellini, Giunchiglia, and Maratea (2024). Indeed, at each step $i \in [ 0 , n )$ ,

1. in the $R$ encoding, each action variable can be “rolledup” taking a value in $ { \mathbb { N } } ^ { \geq 0 }$ representing how many times the action is consecutively executed,

2. the $R ^ { 2 } \exists$ encoding allows for the execution of actions in mutex and/or with contradictory effects, and 3. the $\prec$ -encoding allows for the consecutive execution of actions, even if in mutex and with contradictory effects.

As a consequence, the $\prec$ -encoding dominates the $R ^ { 2 } \exists$ and $R$ encodings, which in turn dominate the standard encoding. This dominance usually leads to better performance, as the number of solver calls, along with the number of variables and the encoding size, all increase linearly with the bound $n$ .

To highlight the potential benefits of moving from the standard encoding to the $\prec$ -encoding also in the temporal numeric setting, consider the following simplified version of the bottle example from (Shin and Davis 2005).

Example. There is a set $\{ 1 , \ldots , q \}$ of bottles, the first p of which containing $l _ { i }$ litres of liquid $\ d ( i \in [ 1 , p ] ,$ ), and the action $p r _ { i , j }$ of pouring from the $i$ -th bottle (with effects at start) in $[ 1 , p ]$ into the $j$ -th bottle in $( p , q ]$ (with effects at end), one litre every $d _ { i , j }$ seconds. In the current encodings, each $p r _ { i , j }$ is Boolean and thus can be executed at most once in between two consecutive states. Further, time variables are associated to the states. For these reasons, with a current encoding $S$ , the goal of emptying the bottles in $[ 1 , p ]$ needs a number of steps $n \geq \mathrm { m a x } _ { i = 1 } ^ { \bar { p } } \bar { l } _ { i }$ , how many depending also on the specific $d _ { i , j }$ values since each executed $p r _ { i , j }$ can start/end at a different time from the others. Further, $\check { S }$ needs at least $n = \textstyle \sum _ { i = 1 } ^ { p } l _ { i }$ steps when $q = p + 1$ , due to the conflicting effec s of pouring to a single bottle.

Despite the apparent complexity introduced by the temporal aspects, (Cushing et al. 2007) demonstrated that these problems are no more difficult than their numeric counterparts without the temporal requirements. Indeed, in the above domain each problem admits a solution in which all the durative actions are sequentially executed, one after the other. For this reason, such problems are said to be without required concurrency (Cushing et al. 2007), and they can be (more easily) solved by non-temporal planners by $( i )$ replacing each durative action $b$ with a snap action combining the preconditions and effects of $\boldsymbol { b } ^ { \vdash } , \boldsymbol { b } ^ { \vdash } , \boldsymbol { b } ^ { \vdash }$ , $( i i )$ finding a sequential solution to the resulting non-temporal problem, and $( i i i )$ post-process the found solution to introduce execution times. We thus consider the following example, whose problems require concurrency.

Example (cont’d). Consider the previous example extended with $n c _ { k }$ which at start uncaps the bottle $k \ \in \ [ 1 , q ]$ and then caps it back after $d _ { k }$ seconds. Any problem in which all the bottles are initially capped requires concurrency, since pouring from $i$ to $j$ is possible only if both bottles i and $j$ are uncapped. This scenario can be modelled in PDDL 2.1 with $V _ { B } \overset {  } { = } \{ c _ { k } ~ | ~ k \in [ 1 , q ] \}$ , $V _ { N } = \{ l _ { k } \ | \ k \in [ 1 , q ] \}$ and the set of durative actions $A = \{ n c _ { k } \mid k \in [ 1 , q ] \} \cup \{ p x _ { i , j } \mid$ $i \in [ 1 , p ] , j \in ( p , q ] \}$ whose actions are:

$$
\begin{array} { r l } & { \quad p r _ { i , j } ^ { \vdash } : \langle \{ c _ { i } = \bot , l _ { i } > 0 , c _ { j } = \bot \} , \{ l _ { i } - = 1 \} \rangle , } \\ & { \quad p r _ { i , j } ^ { \vdash } : \langle \{ c _ { i } = \bot , c _ { j } = \bot \} , \emptyset \rangle , p r _ { i , j } ^ { \bot } : \langle \emptyset , \{ l _ { j } + = 1 \} \rangle , } \\ & { \quad n c _ { k } ^ { \vdash } : \langle \{ c _ { k } = \top \} , \{ c _ { k } : = \bot \} \rangle , n c _ { k } ^ { \bot } : \langle \{ c _ { k } = \bot \} , \{ c _ { k } : = \top \} \rangle . } \end{array}
$$

As customary, $v \ + = \psi$ (resp. $v \ - = \psi ,$ ) is an abbreviation for $\boldsymbol { v } : = \boldsymbol { v } + \boldsymbol { \psi }$ (resp. $v : = v - \psi ,$ . With $q = 2$ and $p = 1$ , there are three durative actions $p r _ { 1 , 2 }$ , $n c _ { 1 }$ and $n c _ { 2 }$ . Considering the starting/ending actions, $p r _ { 1 , 2 } ^ { \vdash }$ is mutex with $n c _ { 1 } ^ { \vdash }$ , $n c _ { 1 } ^ { - 1 }$ . $n c _ { 2 } ^ { \vdash }$ , $n c _ { 2 } ^ { - 1 }$ . If the bottles are initially capped and the durations allow to pour all the litres with just one execution of $n c _ { 1 }$ and $n c _ { 2 }$ ), we need a bound

1. $\textit { n } = l _ { 1 } + 3$ with the standard encoding (one step for uncapping the bottles, $\jmath$ step for starting the first pour action after $\epsilon$ time, $l _ { 1 }$ steps for pouring the litres and the final step for executing the capping of the bottles),   
2. $n = 4$ if we generalize the $R$ encoding since we can rollup the $p r _ { 1 , 2 }$ action and collapse the $l _ { 1 }$ steps into $\jmath$ ,   
3. $n = l _ { 1 }$ if we generalize the $R ^ { 2 } \exists$ encoding since we can execute all the actions (even the mutex ones) in one step except for the repeated execution of $p r _ { 1 , 2 }$ (action variables are still Boolean),   
4. $n = 1$ if we generalize the $\prec$ -encoding since we can execute all the actions in one step.

$H ,$ e.g., $q \ = \ 4$ and $p \ = \ 2$ in the standard encoding we need $n = l _ { 1 } + l _ { 2 } + 3$ steps if the durations of the pour actions forces them to start/end at different times, while we can maintain $n = 1$ generalizing the $\prec$ -encoding.

# Temporal Numeric Planning with Patterns

Let $\Pi = \langle V _ { B } , V _ { N } , A , I , G \rangle$ be a temporal numeric planning problem. Here, we extend the SPP approach to the temporal setting by $( i )$ formally defining the notion of pattern $\prec$ and defining the sets $\chi , \mathring { A } ^ { \prec } , \tau ^ { \prec } , \bar { \chi } \cdot$ of variables used in our encoding; $( i i )$ extending the definition of rolling to durative actions; $( i i i )$ defining the pattern state encoding formula, $T _ { s } ^ { \prec } ( \mathcal { X } , \mathcal { A } ^ { \prec } , \mathcal { X } ^ { \prime } )$ , setting the value of each variable in $\mathcal { X } ^ { \prime }$ as a function of $\mathcal { X }$ and $\mathcal { A } ^ { \prec }$ ; $( i v )$ defining the pattern time encoding formula, $T _ { t } ^ { \prec } ( \mathcal { A } ^ { \prec } , \bar { T } ^ { \prec } )$ , enforcing the desired temporal properties of the actions; and $( v )$ proving the correctness and completeness of the presented encoding. Each point is treated in a separate subsection. Intuitively, a pattern is a sequence of starting/ending actions. For each of these actions, the encoding sets $( i )$ an integer specifying how many times the corresponding durative action is executed in sequence, $( i i )$ the conditions for its executability and effects, and $( i i i )$ the time at which each durative action sequence has to be started/ended. While durative action sequences that do not interfere might swap order, those that interfere need to maintain the ordering given in the pattern for their starting/ending actions, to ensure executability.

# Pattern and Language Definition

A pattern is a finite sequence $\prec = a _ { 1 } ; a _ { 2 } ; . . . ; a _ { k }$ of actions, each starting/ending a durative action in $A$ . A pattern is arbitrary, allowing for multiple occurrences of the same action, even consecutively. Each action occurrence in the pattern corresponds to a distinct variable in the encoding, and, given the variable name, we have to be able to uniquely identify

1. which durative action it is starting/ending, and 2. which of the possible multiple occurrences of the action in $\prec$ we are considering.

For these reasons, we perform the following two initial steps which do not affect the generality of our approach:

1. Whenever in $A$ there are two distinct durative actions $b _ { 1 }$ and $b _ { 2 }$ with $b _ { 1 } ^ { \vdash } = b _ { 2 } ^ { \vdash }$ or $b _ { 1 } ^ { \vdash } = b _ { 2 } ^ { - 1 }$ or $b _ { 1 } ^ { - 1 } = b _ { 2 } ^ { - 1 }$ , we break the identity by adding to the preconditions of one of the two actions an always satisfied condition like $0 = 0$ , and   
2. In a pattern $\prec$ , repeated occurrence of an action $a$ are replaced with distinct copies $a ^ { \prime }$ . Both $a$ and $a ^ { \prime }$ are assumed to be starting/ending the same durative action $b$ , and, abusing notation, we write, e.g., $a = b ^ { \vdash }$ and $a ^ { \prime } = b ^ { \vdash }$ .

We can therefore take the action in the pattern to be the action variables in our encoding, and we can assume that each action starts/ends exactly one durative action.

Consider a pattern $\prec = a _ { 1 } ; a _ { 2 } ; . . . ; a _ { k }$ , $k \geq 0$ . Our encoding is based on the following sets of variables:

1. $\mathcal { X } = V _ { B } \cup V _ { N }$ to represent the initial state;   
2. $\mathcal { X } ^ { \prime }$ containing a next state variable $x ^ { \prime }$ for each state variable $x \in \mathcal { X }$ , used to represent the goal state;   
3. $\mathcal { A } ^ { \prec }$ consisting of the set of actions in the pattern $\prec$ , each variable $a _ { i }$ ranging over $\mathbb { N } ^ { \ge 0 }$ and whose value represents the number of times the durative action started/ended by $a _ { i }$ is consecutively executed/rolled up, with $i \in [ 1 , k ]$ ;   
4. $\mathcal { T } ^ { \prec }$ , with $( i )$ a variable $t _ { i } \in \mathbb { Q } ^ { \geq 0 }$ representing the time in which the $i$ -th action $a _ { i }$ in $\prec$ is executed; $( i i )$ if $a _ { i }$ is starting $b$ , a variable $d _ { i } \in \mathbb { Q } ^ { \geq 0 }$ representing the time taken by the consecutive execution of $b$ for $p$ times, where $p \geq 0$ is the value assumed by the variable $a _ { i } \in \mathcal { A } ^ { \prec }$ , and $( i i i )$ for convenience, a variable $t _ { 0 } = 0$ as the initial time.

In the following we keep using $v , w , x$ for state variables, $\psi$ for a linear expression, $a$ for a (snap) action, $b$ for a durative action, $t$ for a time variable and $d$ for a duration, each symbol possibly decorated with subscripts/superscripts.

# Rolling Durative Actions

We start by defining when a durative action $b$ can be rolled up. Intuitively, $b$ can be consecutively executed more than once when $( i )$ the Boolean effects of its starting/ending actions do not disable the repetition of $b$ given the preconditions of its starting/lasting/ending actions, $( i i )$ the numeric effects of $b ^ { \vdash }$ and $\mathbf { \bar { \boldsymbol { b } } } ^ { - 1 }$ do not interfere between themselves, and $( i i i )$ it might be useful to execute $b$ more than once. Formally, we say that $b$ is eligible for rolling if the following three conditions are satisfied:

1. if $V , V ^ { \prime } \in \{ \bot , \top \}$ , $V \neq V ^ { \prime }$ , then (i) $v = V \in \mathrm { p r e } ( b ^ { \vdash } )$ iff $v : = V \in \mathrm { e f f } ( b ^ { \dash } )$ or $v : = V ^ { \prime } \not \in \mathrm { e f f } ( b ^ { \vdash } ) \cup \mathrm { e f f } ( b ^ { \dashv } )$ , and $( i i )$ $v = V \in \mathrm { p r e } ( b ^ { \mapsto } ) \cup \mathrm { p r e } ( b ^ { \dash } )$ iff $v : = V \in \mathrm { e f f } ( b ^ { \vdash } )$ or $v : = V ^ { \prime } \notin \mathrm { e f f } ( b ^ { \vdash } ) \cup \mathrm { e f f } ( b ^ { \dash } )$ ; 2. if $v : = \psi$ is a numeric effect of $b ^ { \vdash }$ or $b ^ { - 1 }$ , then $( i ) \ v$ does not occur in any other effect of $b ^ { \vdash }$ or $b ^ { - 1 }$ , and $( i i )$ either $v$ does not occur in $\psi$ or $v : = \psi$ is a linear increment; 3. $b ^ { \vdash }$ or $b ^ { - 1 }$ include a linear increment in their effects (this last condition imposed for the usefulness of rolling).

If $b$ has a duration in $[ L , U ]$ and is eligible for rolling, consecutively executing $b$ for $p \geq 1$ times

1. has a duration in $[ p \times L + ( p - 1 ) \times \epsilon _ { b } , p \times U + ( p -$ $\left. 1 \right) \times \epsilon _ { b } ]$ , where $\epsilon _ { b } = \epsilon$ if $b ^ { \vdash }$ and $b ^ { - 1 }$ are mutex, and $\epsilon _ { b } = 0$ otherwise. Such interval allows for $\epsilon$ -separation if $b ^ { \vdash }$ and $b ^ { - 1 }$ are mutex;

2. causes $v$ to get value $( p \times \psi )$ if $v + = \psi$ is a linear increment of $b ^ { \vdash }$ or $b ^ { - 1 }$ , while all the other variables keep the value they get after the first execution of $b$ .

Notice that it is assumed that all the consecutive executions of $b$ have the same duration. Indeed, according to the semantics, the duration of $b$ can be arbitrarily fixed as long as each single execution respects the duration constraints, which are part of the domain specification. This assumption does not affect the completeness of our encoding. Should every valid plan require two consecutive executions of $b$ with different durations, we will find a plan when considering a pattern with two or more occurrences of the starting/ending actions of $b$ . Indeed, rolling is an optimization, and our procedure is complete even if we rule out rolling by adding the constraint $a \leq 1$ for each action $a$ .

Then, for each $i \in [ 0 , k ]$ , the value of a variable $v \in$ $V _ { B } \cup V _ { N }$ after the sequential execution of $a _ { 1 } ; \ldots ; a _ { i }$ , each action possibly repeated multiple times, is given by $\sigma _ { i } ( v )$ , inductively defined as $\sigma _ { 0 } ( v ) = v$ , and, for $i > 0$ ,

1. if $v$ is not assigned by $a _ { i }$ , $\sigma _ { i } ( v ) = \sigma _ { i - 1 } ( v )$ ;   
2. if $v : = { \top \in \mathrm { e f f } ( a _ { i } ) }$ , $\sigma _ { i } ( v ) = ( \sigma _ { i - 1 } ( v ) \lor a _ { i } > 0 )$ ;   
3. if $v : = \bot \in \mathrm { e f f } ( a _ { i } )$ , $\sigma _ { i } ( v ) = ( \sigma _ { i - 1 } ( v ) \wedge a _ { i } = 0 )$ ;   
4. if $v \mathrm { ~ + = ~ } \psi \in \operatorname { e f f } ( a _ { i } )$ is a linear increment,

$$
\sigma _ { i } ( v ) = \sigma _ { i - 1 } ( v ) + a _ { i } \times \sigma _ { i - 1 } ( \psi ) ,
$$

i.e., the value of $v$ is incremented by $\sigma _ { i - 1 } ( \psi )$ a number of times equal to the value assumed by the variable $a _ { i }$ ;

5. if $v : = \psi \in \mathrm { e f f } ( a _ { i } )$ is not a linear increment,

$$
\sigma _ { i } ( v ) = \mathrm { { I T E } } \big ( a _ { i } > 0 , \sigma _ { i - 1 } ( \psi ) , \sigma _ { i - 1 } ( v ) \big ) ,
$$

where $\mathrm { I T E } \big ( c , t , e \big )$ (for ${ } ^ { \bullet } J f ( c )$ Then t Else $e ^ { , \flat }$ returns $t$ or $e$ depending on whether $c$ is true or not, and is a standard function in SMTLIB (Barrett, Fontaine, and Tinelli 2016).

Above and in the following, for any linear expression $\psi$ and $i \in [ 0 , k ]$ , $\sigma _ { i } ( \psi )$ is the expression obtained by substituting each variable $v \in V _ { N }$ in $\psi$ with $\sigma _ { i } ( v )$ .

Given a durative action $b$ eligible for rolling and a state $s$ , to determine the maximum number of times that $b$ can be executed consecutively in $s$ , we rely on the following Theorem, in which $\psi [ p , b ^ { \vdash } , q , b ^ { \dash } ]$ represents the value of $\psi$ after $p$ and $q$ repetitions of the actions $b ^ { \vdash }$ and $b ^ { - 1 }$ , respectively. Formally, $\bar { \psi } [ p , b ^ { \vdash } , q , b ^ { \dash } ]$ is the expression obtained from $\psi$ by substituting each variable $x$ with

1. $x + p \times \psi ^ { \prime }$ (resp. $x + q \times \psi ^ { \prime } )$ , when $x + = \psi ^ { \prime } \in \mathrm { e f f } ( b ^ { \vdash } )$ (resp. $x \to \mp = \psi ^ { \prime } \in \mathrm { e f f } ( b ^ { \dash } ) )$ is a linear increment, and   
2. $\psi ^ { \prime \prime }$ , when $x : = \psi ^ { \prime \prime } \in \mathrm { e f f } ( b ^ { \vdash } ) \cup \mathrm { e f f } ( b ^ { \dash } )$ is not a linear increment.

Theorem 1. Let b be a durative action eligible for rolling. Let s be a state. The result of executing $\boldsymbol { b } ^ { \vdash } ; \boldsymbol { b } ^ { \vdash } ; \boldsymbol { \dot { b } } ^ { \scriptscriptstyle { - 1 } }$ consecutively for $p \geq 1$ times in $s$ is defined if and only if for each numeric condition $\psi \trianglerighteq { \trianglerighteq } 0$ ,

1. if $\psi \trianglerighteq \psi \vdash 0 \in \mathrm { p r e } ( b ^ { \vdash } )$ , s satisfies $\psi [ 0 , b ^ { \vdash } , 0 , b ^ { \dash } ] \trianglerighteq 0$ (i.e., $\psi \trianglerighteq { \sum } 0 )$ and $\bar { \psi } [ p - \dot { 1 } , b ^ { \flat } , p - \dot { 1 } , b ^ { \dash } ] \bar { \trianglerighteq } 0$ ; 2. if $\cdot \psi { \underline { { \lor } } } 0 \in \mathrm { p r e } ( b ^ { \mapsto } ) \cup \mathrm { p r e } ( b ^ { \dash } )$ , s satisfies $\psi [ 1 , b ^ { \vdash } , 0 , b ^ { \dash } ] \subseteq 0$ and $\psi [ p , b ^ { \vdash } , p - 1 , b ^ { \scriptscriptstyle { - } } ] \subseteq 0$ .

Proof. The thesis follows from the monotonicity in $p$ of the functions $\psi [ p - 1 , b ^ { \vdash } , p - 1 , b ^ { \dash } ]$ and $\psi [ p , b ^ { \vdash } , p - 1 , \mathsf { \bar { b } } ^ { \vdash } ]$ (see (Scala et al. 2016b)). □

Example (cont’d). For $i \in [ 1 , p ]$ , $j \in \left( p , q \right]$ , the pouring action $p r _ { i , j }$ is eligible for rolling while both $n c _ { i }$ and $n c _ { j }$ are not. Action $p r _ { i , j }$ can be consecutively executed for $l _ { i }$ times in the states in which bottles i and $j$ are uncapped and at least $l _ { i }$ litres are in the $i$ -th bottle.

# The Pattern State Encoding

Let $\prec = a _ { 1 } ; a _ { 2 } ; . . . ; a _ { k }$ , $k \geq 0$ , be a pattern. The pattern state encoding defines the executability conditions of each action and how to compute the value of each variable in $\mathcal { X } ^ { \prime }$ based on the values of the variable in $\chi$ and in $\mathcal { A } ^ { \prec }$ . Formally, the pattern state $\prec$ -encoding $T _ { s } ^ { \prec } ( \mathcal { X } , \mathcal { A } ^ { \prec } , \mathcal { X } ^ { \prime } )$ of $\Pi$ is the conjunction of the formulas in the following sets:

1. pre $\prec ( A )$ : for each $i \in [ 1 , k ]$ and for each $v = \bot , w = \top$ , $\psi \trianglerighteq { \frac { \ d } { \ d t } } 0$ in $\mathrm { p r e } ( a _ { i } )$ : (a) $\neg v$ and $w$ must hold to execute $a _ { i }$ : $a _ { i } > 0 \to ( \neg \sigma _ { i - 1 } ( v ) \land \sigma _ { i - 1 } ( w ) ) ,$ (b) and, if $a _ { i }$ is starting $b$ , (i.e., if $a _ { i } = b ^ { \vdash }$ ) (Theorem 1): $\begin{array} { c } { { a _ { i } > 0  \sigma _ { i - 1 } ( \psi [ 0 , b ^ { \vdash } , 0 , b ^ { \dash } ] ) \underline { { { \triangleright } } } 0 , } } \\ { { a _ { i } > 1  \sigma _ { i - 1 } ( \psi [ a _ { i } - 1 , b ^ { \vdash } , a _ { i } - 1 , b ^ { \dash } ] ) \underline { { { \triangleright } } } 0 , } } \end{array}$ (c) if $a _ { i }$ is ending $b$ , (i.e., if $a _ { i } = b ^ { - 1 } ,$ ) (Theorem 1, noting that in $\sigma _ { i - 1 }$ , $\bar { b } ^ { \vdash }$ has been executed $a _ { i }$ times): $\begin{array} { r l } & { a _ { i } > 0  \sigma _ { i - 1 } ( \psi [ - a _ { i } + 1 , b ^ { \vdash } , 0 , b ^ { \dash } ] ) \trianglerighteq 0 , } \\ & { \ a _ { i } > 1 \to \sigma _ { i - 1 } ( \psi [ 0 , b ^ { \vdash } , a _ { i } - 1 , b ^ { \dash } ] ) \trianglerighteq 0 . } \end{array}$   
2. $\operatorname { a m o } ^ { \prec } ( A )$ : for each $i \in [ 1 , k ]$ , if a is starting a durative

action which is not eligible for rolling:

$$
a _ { i } \leq 1 .
$$

3. frame $\prec _ { ( V _ { B } \cup V _ { N } ) }$ : for each variable $v \in V _ { B }$ and $w \in V _ { N }$ :

$$
v ^ { \prime }  \sigma _ { k } ( v ) , \qquad w ^ { \prime } = \sigma _ { k } ( w ) .
$$

Example (cont’d). Assume $p = 2$ and $q = 4$ . Let

$$
\begin{array} { r l } & { n c _ { 1 } ^ { \vdash } ; n c _ { 2 } ^ { \vdash } ; n c _ { 3 } ^ { \vdash } ; n c _ { 4 } ^ { \vdash } ; p x _ { 1 , 3 } ^ { \vdash } ; p x _ { 1 , 4 } ^ { \vdash } ; p x _ { 2 , 3 } ^ { \vdash } ; p x _ { 2 , 4 } ^ { \vdash } ; } \\ & { n c _ { 1 } ^ { \dashv } ; n c _ { 2 } ^ { \dashv } ; n c _ { 3 } ^ { \dashv } ; n c _ { 4 } ^ { \dashv } ; p x _ { 1 , 3 } ^ { \dashv } ; p x _ { 1 , 4 } ^ { \dashv } ; p x _ { 2 , 3 } ^ { \lessgtr } ; p x _ { 2 , 4 } ^ {  } . } \end{array}
$$

be the fixed pattern $\prec$ . Assume $i \in [ 1 , 2 ]$ , $j \in [ 3 , 4 ]$ , $k \in$ [1, 4]. The pattern state encoding entails $( n c _ { k } ^ { \vdash } \leq 1 ) ^ { \cdot }$ ) since the durative action nc is not eligible for rolling and

$$
\begin{array} { c } { { n c _ { i } ^ { \vdash } > 0  c _ { i } , \ n c _ { i } ^ { \bot } > 0  \neg ( c _ { i } \wedge n c _ { i } ^ { \vdash } = 0 ) , } } \\ { { p r _ { i , j } ^ {  } > 0  ( \neg ( c _ { i } \wedge n c _ { i } ^ { \vdash } = 0 ) \wedge \neg ( c _ { j } \wedge n c _ { j } ^ { \vdash } = 0 ) ) , } } \\ { { p r _ { i , 3 } ^ { \vdash } > 0  l _ { i } > 0 , \ p x _ { i , 4 } ^ {  } > 0  l _ { i } - p x _ { i , 3 } ^ { \vdash } > 0 , } } \\ { { p r _ { i , 3 } ^ { \vdash } > 1  p x _ { i , 3 } ^ { \vdash } < l _ { i } , \qquad p r _ { i , 4 } ^ {  } > 1  p x _ { i , 4 } ^ {  } < l _ { i } - p x _ { i , 3 } ^ {  } , } } \\ { { c _ { k } ^ { \prime } \equiv ( c _ { k } \wedge n c _ { k } ^ { \vdash } = 0 ) \vee n c _ { k } ^ { \dash } > 0 , } } \\ { { l _ { i } ^ { \prime } = l _ { i } - p x _ { i , 3 } ^ {  } - p x _ { i , 4 } ^ {  } , \qquad l _ { j } ^ { \prime } = l _ { j } + p x _ { 1 , j } ^ { \dash } + p x _ { 2 , j } ^ {  } . } } \end{array}
$$

The first four lines define the preconditions for executing each action, and the last two specify the frame axioms.

As the frame axioms in the example make clear, the $\precsim$ encoding allows in the single state transition from $\chi$ to $\mathcal { X } ^ { \prime }$ $( i )$ the multiple consecutive execution of the same action, as in the rolled-up $R$ encoding (Scala et al. 2016b), and $( i i )$ the combination of multiple even contradictory effects on a same variable by different actions, as in the $\dot { R } ^ { 2 } \exists$ encoding (Bofill, Espasa, and Villaret 2016).

# The Pattern Time Encoding

Let $\prec = a _ { 1 } ; a _ { 2 } ; \ldots ; a _ { k }$ , $k \geq 0$ , be a pattern. The pattern time $\prec$ -encoding associates to each action $a _ { i }$ in $\prec \mathtt { a }$ starting time $t _ { i }$ and duration $d _ { i }$ , which are both set to 0 when $a _ { i }$ is not executed, i.e., when $a _ { i } = 0$ . In defining the constraints for $t _ { i }$ and $d _ { i }$ they have to respect the semantics of temporal planning problems and also the causal relations between the actions in the pattern and exploited in the pattern state $\prec$ -encoding. Consider for instance two actions $a _ { i }$ and $a _ { j }$ in $\prec$ with $i < j$ , $a _ { i } > 0$ and $a _ { j } > 0$ . We surely have to guarantee that $t _ { i } < t _ { j }$ if $a _ { i }$ and $a _ { j }$ are in mutex: the formulas checking that the preconditions of $a _ { j }$ (resp. $a _ { i }$ ) are satisfied, take into account that $a _ { i }$ (resp. $a _ { j }$ ) has been (resp. has not been) executed before $a _ { j }$ (resp. $a _ { i } ^ { \cdot }$ ). Even further, we have to impose that $t _ { i } + \epsilon \leq t _ { j }$ for the $\epsilon$ -separation rule. If, on the other hand, $a _ { i }$ and $a _ { j }$ are not in mutex, then it is not necessary to guarantee $t _ { i } < t _ { j }$ unless $a _ { j }$ is ending the durative action started by $a _ { i }$ or because of the lasting action of the durative action started by $a _ { j }$ . As an example of the impact of the lasting action on the encoding, assume $a _ { j }$ is starting action $b$ . Then, it may be the case $a _ { i }$ is not in mutex with $a _ { j }$ but it is in mutex with the lasting action $b ^ { \mathsf { H } }$ of $b$ . Hence, the formulas checking the executability of $b ^ { \mathsf { H } }$ encode that $a _ { i }$ precedes $a _ { j }$ in the pattern, and consequently we will have to guarantee $t _ { i } < t _ { j }$ .

Given the above, the pattern time $\prec$ -encoding $T _ { t } ^ { \prec } ( \mathcal { A } ^ { \prec } , \mathcal { T } ^ { \prec } )$ of $\prec$ is the conjunction of $( \mathrm { \Delta } t _ { 0 } ~ = ~ 0 ) ,$ ) and the following formulas:

1. $\mathrm { d u r } ^ { \prec } ( A )$ : for each durative action $\langle b ^ { \vdash } , b ^ { \lnot } , b ^ { \lnot } , [ L , U ] \rangle \in$ $A$ and for each action $a _ { i } = b ^ { \vdash }$ and $a _ { j } = b ^ { - 1 }$ in $\prec$ :

$$
\begin{array} { c } { a _ { i } > 0  t _ { i } \geq t _ { 0 } + \epsilon , } \\ { a _ { i } = 0  t _ { i } = t _ { 0 } \wedge d _ { i } = 0 , a _ { j } = 0  t _ { j } = t _ { 0 } , } \\ { a _ { i } > 0  a _ { i } \times ( L + \epsilon _ { b } ) \leq d _ { i } + \epsilon _ { b } \leq a _ { i } \times ( U + \epsilon _ { b } ) . } \end{array}
$$

The last formula guarantees also $\epsilon$ -separation when $b$ is consecutively executed, and $b ^ { \vdash }$ and $b ^ { - 1 }$ are in mutex.

2. start-end $\prec _ { ( A ) }$ : for each durative action $b$ , each starting action $a _ { i } = { \dot { b } } ^ { \mapsto }$ (resp. ending action $a _ { j } = b ^ { - 1 } \gamma$ in $\prec$ must have a matching ending (resp. starting) action:

$$
\begin{array} { r } { a _ { i } > 0  \bigvee _ { j \in E _ { i } } ( a _ { i } = a _ { j } \wedge t _ { j } = t _ { i } + d _ { i } ) , } \\ { a _ { j } > 0  \bigvee _ { i \in S _ { j } } ( a _ { i } = a _ { j } \wedge t _ { j } = t _ { i } + d _ { i } ) , } \end{array}
$$

where $E _ { i } = \{ j \in ( i , k ] \mid a _ { i } = b ^ { \vdash } , a _ { j } = b ^ { + } \}$ , and $S _ { j } =$ $\left\{ i \in [ 1 , j ) \mid a _ { j } = b ^ { \dash } , a _ { i } = b ^ { \vdash } \right\}$ .

3. $\mathrm { e p s i l o n } ^ { \prec } ( A )$ : every two actions $a _ { i }$ and $a _ { j }$ in $\prec$ with $j < i$ are $\epsilon$ -separated if they are mutex or different copies of the same action:

$$
a _ { i } > 0 \to ( t _ { i } \geq t _ { j } + \epsilon ) .
$$

Further, for every two actions $a _ { i }$ and $a _ { j }$ starting respectively $b$ and $b ^ { \prime }$ , if the starting or ending action of $b$ is mutex with the starting or ending action of $b ^ { \prime }$ :

$$
\begin{array} { r } { a _ { i } > 1  ( t _ { i } \geq t _ { j } + d _ { j } \vee t _ { j } \geq t _ { i } + d _ { i } \vee \qquad } \\ { a _ { j } = 1 \wedge t _ { i } \geq t _ { j } \wedge t _ { i } + d _ { i } \leq t _ { j } + d _ { j } ) . } \end{array}
$$

This formula ensures that the start/end actions of $b ^ { \prime }$ are not executed during the multiple consecutive executions of $b$ , thereby guaranteeing $\epsilon$ -separation.

4. noOverlap $\prec _ { ( A ) }$ : for each durative action $b$ , each starting action $a _ { i } = b ^ { \vdash }$ in $\prec$ can be executed only after the previous executions of $b$ ended:

$$
\begin{array} { r } { a _ { i } > 0  \bigwedge _ { j \in B _ { i } } \bigl ( t _ { i } \geq t _ { j } + d _ { j } \bigr ) , } \end{array}
$$

where $B _ { i } = \{ j \in [ 1 , i ) \mid a _ { i } = b ^ { \vdash } , a _ { j } = b ^ { \vdash } \} .$ .

5. lasting $\prec _ { ( A ) }$ : for each durative action $b$ with $\mathrm { p r e } ( b ^ { \mapsto } ) \neq$ $\varnothing$ , and for each action $a _ { i } = b ^ { \vdash }$ in $\prec$ :

(a) The preconditions of $b ^ { \mathsf { H } }$ must be satisfied in each (consecutive) execution of $b$ , i.e., for each $v = \bot , w = \top$ , $\psi \trianglerighteq { \trianglerighteq } 0$ in pre $( b ^ { \mathsf { H } } )$ (Theorem 1):

$$
\begin{array} { c } { { a _ { i } > 0  \neg \sigma _ { i } ( v ) \wedge \sigma _ { i } ( w ) \wedge \sigma _ { i - 1 } ( \psi [ 1 , b ^ { \vdash } , 0 , b ^ { + } ] ) \underline { { { \geq } } } 0 , } } \\ { { a _ { i } > 1 \to \sigma _ { i - 1 } ( \psi [ a _ { i } , b ^ { \vdash } , a _ { i } - 1 , b ^ { + } ] ) \underline { { { \ > } } } 0 . } } \end{array}
$$

(b) For each action $a _ { j }$ in $\prec$ mutex with $b ^ { \mathsf { H } }$ ,

i. if $j < i$ , then $a _ { j }$ cannot be executed after $a _ { i }$

$$
a _ { i } > 0 \to t _ { i } \geq t _ { j } ,
$$

and, when $a _ { j }$ is a starting action, also:

$$
a _ { i } > 0 \land a _ { j } > 1  t _ { i } \geq t _ { j } + d _ { j } .
$$

These formulas ensure that $b$ does not start until all executions of $a _ { j }$ happened.

ii. if $j > i$ and $a _ { j }$ is executed before $b$ ends, then $( i )$ no rolling takes place:

$$
t _ { 0 } + \epsilon \le t _ { j } < t _ { i } + d _ { i } \to a _ { i } \le 1 \land a _ { j } \le 1 ,
$$

and $( i i ) \ a _ { j }$ has to maintain the preconditions of $b ^ { \mathsf { H } }$ , i.e., for each $v = \perp$ , $w = \top$ , $\psi \trianglerighteq { \geq } 0$ in $\mathrm { p r e } ( b ^ { \mapsto } )$ :

$$
t _ { 0 } + \epsilon \leq t _ { j } < t _ { i } + d _ { i }  \neg \sigma _ { j } ( v ) \wedge \sigma _ { j } ( w ) \wedge \sigma _ { j } ( \psi ) \trianglerighteq 0 .
$$

Example (cont’d). For $p x _ { i , j } ^ { \vdash }$ (resp. $n c _ { k } ^ { \vdash } .$ ), let $t _ { i , j } ^ {  }$ (resp. $t _ { k } ^ {  }$ ) be the associated time variable, and analogously for the ending actions. If we further assume that when executed, the durations $d _ { i , j }$ and $d _ { k }$ of $\cdot _ { p r _ { i , j } }$ and $n c _ { k }$ are $\jmath$ and $5$ respectively, the temporal pattern encoding entails:

$$
\begin{array} { r l } & { \quad n c _ { k } ^ { \vdash } = 0 \to d _ { k } = 0 , n c _ { k } ^ { \vdash } = 1 \to d _ { k } = 5 , p x _ { i , j } ^ { \vdash } = d _ { i , j } , } \\ & { \quad n c _ { k } ^ { \vdash } = n c _ { k } ^ { \dashv } , \ p r _ { i , j } ^ { \vdash } = p r _ { i , j } ^ { \dashv } , \quad \neg ( t _ { i , j } ^ {  } \leq t _ { i } ^ {  } < t _ { i , j } ^ {  } + d _ { i , j } ) , } \\ & { \quad \quad p r _ { i , j } ^ { \vdash } > 0 \land n c _ { i } ^ {  } = 1 \to t _ { i , j } ^ {  } \geq t _ { i } ^ {  } + \epsilon . } \end{array}
$$

The formulas in the $3$ lines respectively say that $( i )$ uncapping a bottle takes 5s and pouring $p$ litres takes $p$ seconds, $( i i )$ any started durative action has to be ended and it is not possible to cap a bottle while pouring from it, and $( i i i )$ we can start pouring from a bottle after ϵ time since we uncapped it. Similar facts hold for the destination bottles.

# Correctness and Completeness Results

Let $\prec = a _ { 1 } ; a _ { 2 } ; \ldots ; a _ { k }$ , $k \geq 0$ , be a pattern. Though the pattern $\prec$ can correspond to any sequence of starting/ending actions of a durative action in $\dot { A }$ , it is clear that it is pointless to have $( i )$ an ending action $b ^ { - 1 }$ without the starting action $b ^ { \vdash }$ before $b ^ { - 1 }$ in $\prec$ ; similarly $( i i )$ a starting action $b ^ { \vdash }$ which is not followed by the ending action $b ^ { - 1 }$ , and $( i i i )$ two consecutive occurrences of the same starting (ending) action in the pattern. In such cases, the pattern can be safely simplified by eliminating such actions. On the other hand, it makes sense to consider patterns with non consecutive occurrences of the same starting/ending action. Assuming $b _ { 1 }$ and $b _ { 2 }$ are two durative actions with $\bar { b } _ { 1 } ^ { \vdash } / b _ { 1 } ^ { \scriptscriptstyle { - 1 } }$ mutex with $b _ { 2 } ^ { \vdash }$ , it might be useful to have a pattern including $b _ { 1 } ^ { \vdash } ; b _ { 1 } ^ { \scriptscriptstyle { - 1 } } ; b _ { 2 } ^ { \scriptscriptstyle { - } } ; b _ { 1 } ^ { \scriptscriptstyle { - } } ; b _ { 1 } ^ { \scriptscriptstyle { - } }$ to allow two executions of $b _ { 1 }$ , or $b _ { 1 }$ to start/end before/after $b _ { 2 }$ starts. No matter how $\prec$ is defined, the $\prec$ -encoding $\Pi ^ { \prec }$ of $\Pi$ (with bound 1) is correct, where

$$
\Pi ^ { \prec } = I ( { \mathcal { X } } ) \wedge T _ { s } ^ { \prec } ( { \mathcal { X } } , { \mathcal { A } } ^ { \prec } , { \mathcal { X } } ^ { \prime } ) \wedge T _ { t } ^ { \prec } ( { \mathcal { A } } ^ { \prec } , { \mathcal { T } } ^ { \prec } ) \wedge G ( { \mathcal { X } } ^ { \prime } ) ,
$$

in which $I ( \mathcal { X } )$ and $G ( \mathcal { X } ^ { \prime } )$ are formulas encoding the initial state and the goal conditions. To any model $\mu$ of $\Pi ^ { \prec }$ we associate the valid temporal plan $\pi$ whose durative actions are started by the actions $a _ { i }$ in $\prec$ with $\mu ( a _ { i } ) > 0$ . Specifically, if $a _ { i } = b ^ { \vdash }$ , in $\pi$ we have $\mu ( a _ { i } )$ consecutive executions of $b$ , i.e., one timed durative actions $\left. t , \langle b ^ { \vdash } , b ^ { \vdash } , b ^ { \dash } , d \rangle \right.$ for each value of $p \in [ 0 , \mu ( a _ { i } ) )$ . The $( p + 1 )$ -th execution of $b$ happens at the time $t$ and has duration $d$ such that

$$
t = \mu ( t _ { i } ) + p \times ( d + \epsilon _ { b } ) , ( d + \epsilon _ { b } ) \times \mu ( a _ { i } ) = \mu ( d _ { i } ) + \epsilon _ { b } .
$$

Completeness is guaranteed once we ensure that the sequence $\pi ^ { \downarrow }$ of the starting/ending actions of a valid temporal plan $\pi$ , listed according to their execution times, is a subsequence of the pattern used in the encoding. This can be achieved by starting with a complete pattern, and then repeatedly chaining it till $\Pi ^ { \prec }$ becomes satisfiable. Formally, a pattern $\prec$ is complete if for each durative action $b \in A$ , $b ^ { \vdash }$ and $b ^ { - 1 }$ occur in $\prec$ . Then, we define $\prec ^ { n }$ to be the sequence of actions obtained concatenating $\prec$ for $n \geq 1$ times. Finally, $\Pi _ { n } ^ { \prec }$ is the pattern $\prec$ -encoding of $\Pi$ with bound $n$ , obtained from (2) by considering $\prec ^ { n }$ as the pattern $\prec$ .

Theorem 2. Let Π be a temporal numeric planning problem. Let $\prec$ be a pattern. Any model of $\Pi ^ { \prec }$ corresponds to a valid temporal plan of Π (correctness). If Π admits a valid temporal plan and $\prec$ is complete, then for some $n \geq 0$ , $\Pi _ { n } ^ { \prec }$ is satisfiable (completeness).

Proof (hint). Correctness: Let $\mu$ be a model of $\Pi ^ { \prec }$ and $\pi$ its associated plan. The $\epsilon$ -separation axioms ensure that the relative order between mutex actions in $\pi$ and in $\prec$ is the same. The pattern state encoding ensures that executing sequentially the actions in $\pi$ starting from $I$ leads to a goal state. The axioms in the pattern time encoding are a logical formulation of the corresponding properties for the validity of $\pi$ . Completeness: Let $\pi$ be a valid temporal plan with $n$ durative actions. Let $\prec _ { \pi }$ be the pattern consisting of the starting and ending actions in $\pi$ listed according to their execution times. The formula $\Pi ^ { \prec _ { \pi } }$ is satisfied by the model $\mu$ whose associated plan is $\pi$ . For any complete pattern $\prec$ , $\prec _ { \pi }$ is a subsequence of $\prec ^ { 2 \times n }$ and $\bar { \Pi _ { 2 \times n } ^ { - \prec } }$ can be satisfied by extending $\mu$ to assign 0 to all the action variables not in $\prec _ { \pi }$ . □

Notice that when two actions $a$ and $a ^ { \prime }$ are not in mutex and one is not the starting/ending action of the other, the pattern does not lead to an ordering on their execution times. For this reason, we may find a valid plan $\pi$ for $\Pi$ even before $\prec ^ { n }$ becomes a supersequence of $\bar { \pi ^ { \downarrow } }$ , $\pi ^ { \downarrow }$ defined as above.

<html><body><table><tr><td rowspan="2">Domain</td><td colspan="6">Coverage (%)</td><td colspan="6">Time (s)</td><td colspan="3">Bound (Common)</td></tr><tr><td>PATTYT</td><td>ANMLSMT</td><td>ITSATLPG</td><td></td><td>OPTIC</td><td>TFD</td><td>PATTYT</td><td>ANMLSMT</td><td>ITSAT LPG</td><td></td><td>OPTIC</td><td>TFD</td><td>PATTYT</td><td>ANMLSMT ITSAT</td><td></td></tr><tr><td>Temporal</td><td>9</td><td>4</td><td>2</td><td>1</td><td>4</td><td>0</td><td>6</td><td>1</td><td>0</td><td>0</td><td>3</td><td>0</td><td>10</td><td>0</td><td>0</td></tr><tr><td>CUSHING</td><td>100.0</td><td>30.0</td><td></td><td></td><td>100.0</td><td>10.0</td><td>1.70</td><td>235.35</td><td></td><td></td><td>3.12</td><td>270.02</td><td>3.00</td><td>11.33</td><td></td></tr><tr><td>POUR</td><td>95.0</td><td>5.0</td><td>-</td><td>-</td><td>-</td><td>-</td><td>46.51</td><td>285.96</td><td></td><td></td><td></td><td></td><td>2.00</td><td>15.00</td><td>-</td></tr><tr><td>SHAKE</td><td>100.0</td><td>50.0</td><td></td><td>1</td><td>1</td><td>1</td><td>1.11</td><td>155.15</td><td></td><td></td><td></td><td></td><td>2.00</td><td>9.50</td><td>1</td></tr><tr><td>PACK</td><td>60.0</td><td>5.0</td><td>-</td><td>-</td><td>-</td><td></td><td>154.72</td><td>285.00</td><td>-</td><td></td><td>-</td><td>，</td><td>1.00</td><td>6.00</td><td></td></tr><tr><td>BOTTLES</td><td>10.0</td><td>5.0</td><td></td><td></td><td></td><td></td><td>284.28</td><td>286.36</td><td></td><td></td><td></td><td>1</td><td>7.00</td><td>18.00</td><td></td></tr><tr><td>MAJSP</td><td>85.0</td><td>50.0</td><td></td><td>1</td><td>-</td><td></td><td>90.54</td><td>154.02</td><td></td><td>1</td><td>1</td><td></td><td>8.40</td><td>15.00</td><td></td></tr><tr><td>MATCHAC</td><td>100.0</td><td>100.0</td><td>100.0</td><td>-</td><td>100.0</td><td></td><td>2.20</td><td>0.46</td><td>0.71</td><td>-</td><td>0.01</td><td></td><td>3.85</td><td>10.00</td><td>4.00</td></tr><tr><td>MATCHMS</td><td>100.0</td><td>100.0</td><td>100.0</td><td></td><td>100.0</td><td></td><td>1.22</td><td>0.43</td><td>0.68</td><td>-</td><td>0.01</td><td>1</td><td>3.60</td><td>10.00</td><td>4.00</td></tr><tr><td>OVERSUB</td><td>100.0</td><td>100.0</td><td></td><td>100.0</td><td>100.0</td><td></td><td>1.02</td><td>0.05</td><td></td><td>0.08</td><td>0.01</td><td></td><td>1.00</td><td>4.00</td><td></td></tr><tr><td>PAINTER</td><td>35.0</td><td>45.0</td><td>-</td><td>-</td><td>10.0</td><td></td><td>211.69</td><td>194.67</td><td>-</td><td>-</td><td>270.03</td><td>1</td><td>2.40</td><td>16.80</td><td></td></tr></table></body></html>

Table 1: Comparative analysis. A “-” indicates that no result was obtained in our 300s time limit, either due to a timeout or an issue with the planner. The best results are in bold.

Example (cont’d). Assume all $q \geq 2 \times p$ bottles are initially capped and that the bottles in $[ 1 , p ]$ contain $< d _ { k } = 5$ litres. Then, $\Pi ^ { \prec }$ is satisfiable and a valid plan is found with one call to the SMT solver. Notice that in the pattern $( l )$ , the ending action $p r _ { i , j } ^ { - 1 }$ of the pouring actions are after the ending action $n c _ { k } ^ { - 1 }$ that caps the bottle. However, such two actions are not in mutex and our pattern time encoding does not enforce $t _ { i , j } ^ { \dashv } > t _ { k } ^ { \dashv }$ , making it possible to solve the problem with a bound $\mathbf { \bar { \boldsymbol { n } } = 1 }$ . On the other hand, if one bottle contains 5 litres, $\Pi ^ { \prec }$ is unsatisfiable because of $\epsilon$ -separation between the actions of uncapping and pouring from it, making it impossible to pour 5 times before the bottle is capped again. This problem is solved having $\prec ^ { n }$ with $n = 2$ . More complex scenarios may require $\prec ^ { n }$ with higher values for $n$ .

# Experimental Results

Table 1 presents the experimental analysis on the CUSHING domain (the only domain with required concurrency in the last International Planning Competition (IPC) with a temporal track (Coles et al. 2018)), all the domains and problems presented in (Panjkovic and Micheli 2023) (last five), and four new domains covering different types of required concurrency specified in (Cushing et al. 2007). The first new domain, POUR, is similar to the motivating example of this paper. SHAKE allows emptying a bottle by shaking it while uncapped. PACK calls for concurrently pairing two bottles together to be packed. The domain BOTTLES puts together all the actions and characteristics of the three aforementioned domains. Of these 10 domains, only POUR and BOTTLES, contain actions eligible for rolling.

The analysis compares our system $\mathrm { P A T T Y _ { T } }$ implemented by modifying the planner PATTY (Cardellini, Giunchiglia, and Maratea 2024) and using the SMT-solver Z3 v4.8.7 (De Moura and Bjørner 2008); the symbolic planners ANMLSMT (which corresponds to ANMLIONMCT(OMSAT) in (Panjkovic and Micheli 2023)) and ITSAT (Rankooh and Ghassem-Sani 2015); and the search-based planners OPTIC (Benton, Coles, and Coles 2012), LPG (Gerevini, Saetti, and Serina 2010) and TEMPORALFASTDOWNWARD (TFD) (Eyerich, Mattmu¨ller, and Ro¨ger 2012). ANMLSMT and OPTIC have been set in order to return the first valid plan they find. To use ANMLSMT, we manually converted the domains in PDDL 2.1 to the ANML language (Smith, Frank, and Cushing 2008). The experiments have been run using the same settings used in the Numeric/Agile Track of the last IPC, with 20 problems per domain and a time limit of 5 minutes. Analyses have been run on an Intel Xeon Platinum $\mathrm { 8 0 0 0 3 . 1 G H z }$ with 8 GB of RAM. In the table we show: the percentage of solved instances (Coverage); the average time to find a solution, counting the time limit when the solution could not be found (Time); the average bound at which the solutions were found, computed on the problems solved by all the symbolic planners able to solve at least one problem in the domain (Bound). The value of the bound coincides with the number of calls to the SMT solver. Each pattern $\prec$ is computed only once using the Asymptotic Relaxed Planning Graph, introduced in (Scala et al. 2016a) and already used in (Cardellini, Giunchiglia, and Maratea 2024). 1

From the table, as expected $\mathrm { P A T T Y _ { T } }$ finds a solution with a bound always lower than the ones needed by the other symbolic planners. This allows $\mathrm { P A T T Y _ { T } }$ to have the highest coverage in 9 out of 10 domains (compared to the value 4 for the second best). The Painter domain is the only one where PATT $\mathrm { Y } _ { \mathrm { T } }$ has a lower coverage than ANMLSMT. ANMLSMT is a symbolic planner exploiting the standard encoding. Although it requires a higher bound to find a valid plan also in Painter, ANMLSMT encoding has 2490 mostly Boolean variables (action and most state variables are Boolean), while our encoding has 2058 mostly numeric variables (the only Boolean variables are in $\mathcal { X }$ and $\mathcal { X } ^ { \prime }$ ). In the other domains, the ratio between the number of variables used by ANMLSMT and $\mathrm { P A T T Y _ { T } }$ is 0.16 on average, which provides an explanation of PATT $\mathrm { Y } _ { \mathrm { T } }$ ’s highest coverage and better performance on 9/10 and 6/10 domains, respectively. Overall, $\mathrm { P A T T Y _ { T } }$ is able to solve 157 out of the 200 considered problems, compared to the 98 of the second best.

# Conclusion

We extended the SPP approach proposed in (Cardellini, Giunchiglia, and Maratea 2024) to the temporal numeric setting. We proved its correctness and completeness, and showed its benefits on various domains with required concurrency. As expected, all the problems have been solved by $\mathrm { P A T T Y _ { T } }$ with a bound lower than the one needed by the other planners based on planning as satisfiability.

# Acknowledgments

Enrico Giunchiglia acknowledges the financial support from PNRR MUR Project PE0000013 FAIR “Future Artificial Intelligence Research”, funded by the European Union – NextGenerationEU, CUP J33C24000420007, and from Project PE00000014 “SEcurity and RIghts in the CyberSpace”, CUP D33C22001300002.