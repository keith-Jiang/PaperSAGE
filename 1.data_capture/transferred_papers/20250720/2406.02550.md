# Learning to grok: Emergence of in-context learning and skill composition in modular arithmetic tasks

Tianyu He a, † Darshil Doshi a Aritra Das a {tianyuh, ddoshi, aritrad}@umd.edu

Andrey Gromov b, a gromovand@meta.com

# Abstract

Large language models can solve tasks that were not present in the training set. This capability is believed to be due to in-context learning and skill composition. In this work, we study the emergence of in-context learning and skill composition in a collection of modular arithmetic tasks. Specifically, we consider a finite collection of linear modular functions $z = a x + b y$ mod $p$ labeled by the vector $( a , b ) \in \mathbb { Z } _ { p } ^ { 2 }$ . We use some of these tasks for pre-training and the rest for out-ofdistribution testing. We empirically show that a GPT-style transformer exhibits a transition from in-distribution to out-of-distribution generalization as the number of pre-training tasks increases. We find that the smallest model capable of outof-distribution generalization requires two transformer blocks, while for deeper models, the out-of-distribution generalization phase is transient, necessitating early stopping. Finally, we perform an interpretability study of the pre-trained models, revealing highly structured representations in both attention heads and MLPs; and discuss the learned algorithms. Notably, we find an algorithmic shift in deeper models, as we go from few to many in-context examples.

# 1 Introduction

Large language models (LLMs) can perform simple tasks absent from their training data. This ability is usually achieved via in-context learning [5]. More importantly, LLMs can perform an even larger variety of very complex tasks upon appropriate prompting or fine-tuning. The latter ability to perform complex tasks is usually attributed to the following mechanism. First, LLMs learn a large variety of simple tasks and, then, how to compose those skills to form very complex skills [3]. Furthermore, LLMs also exhibit “emergent capabilities” – a sudden emergence of a new complex skill as a function of scale (either model size, compute or data) [29, 9]. It is plausible that these sudden performance improvements are due to one or both of these mechanisms. For example, LLMs show grokking on algorithmic tasks [24], which results from the model learning very structured representations [18, 11, 20]. Once these representations emerge, the model abruptly learns how to perform the task.

In this work, we set out to examine skill composition both empirically and mechanistically. Inspired by the prior work that investigated emergence of in-context learning on linear regression tasks [1, 25], we introduce a finite collection of discrete modular arithmetic tasks [24] generalized to the in-context learning setting. Each task corresponds to learning a linear function $z = a x + b y$ mod $p$ over $\mathbb { Z } _ { p }$ from the examples provided in context of the autoregressive model(AM). In the bi-variate case there are $p ^ { 2 }$ such functions labeled by the vector $( a , b )$ . The main objective of this algorithmic dataset is to probe how AM utilizes the tasks it has learnt during training to solve the new tasks.

![](images/fee534684daeecc6e4b983e059b9e00b5c10ca14c1e9159a64785ba63ebebf2c.jpg)  
Figure 1: (a) The dataset. The tasks are labeled by vectors $( a , b ) \in \mathbb { Z } _ { p } ^ { 2 }$ . Each table contains examples of $a x + b y$ mod $p$ . A fraction $1 - \alpha$ of the examples is blacked out; while the remaining examples are flattened into a single “document” in the batch. Each document is organized as a collection of triples $( x , y , a x + b y )$ for $x , y$ from the training set (i.e. not blacked out in the table). Our training is similar to the traditional next-token prediction (autoregressive); with the main difference that we predict every third token, which are marked in red ( $\dot { \boldsymbol { x } }$ and $y$ are uncorrelated). Every task appears exactly the same number of times in each batch. (b) Phase diagram for a six-layer model. We find four different phases. (1) in-distribution memorization: The model only performs well on tasks $( a , b )$ and examples $( x , y )$ from the training set – it does not generalize on unseen examples or tasks. (2) in-distribution generalization: model generalizes on unseen examples $( x , y )$ but not on unseen tasks $( a , b )$ . (3) out-of-distribution memorization: model generalizes on unseen tasks $( a , b )$ but only for examples $( x , y )$ it has seen during training. (4) out-of-distribution generalization: model generalizes on unseen tasks $( a , b )$ for seen as well as unseen examples $( x , y )$ . We focus on investigating phase (4) in more detail. (c) In-context sample complexity. Accuracy of the model in phase (4) as a function of the number of few-shot examples. (d) Representations developed by one of the attention heads in the first layer. These are projections of the embedding of a pair of numbers onto the two largest principal components (PCs) of the internal representation formed after passing through the attention layer and projection matrix. (e) First $3 \mathrm { P C s }$ of embeddings separate $l o g _ { 2 7 }$ -annotated numbers into even/odd planes, with 0 sandwiched between them.

Our analysis shows that the solution found by the AM after optimization is qualitatively different from the linear regression cases studied before [1]. In those cases, due to the continuous nature of the task, AM develops an emergent first-order optimization method that minimizes an emergent quadratic loss function. Furthermore, as it was shown in [1], a single linear attention layer can solve the regression problem, while adding extra layers and non-linearities slightly modifies the gradient descent. In the modular arithmetic case, AM first learns how to solve the pre-training tasks and later (assuming enough different tasks) develops a generalizing solution by combining the solved tasks.

Our main findings as well as the structure of the algorithmic dataset are illustrated on Fig. 1. Our main findings are: (i) there are four different phases in the end of pre-training depending on the number of tasks, $n _ { \mathrm { i . d . } }$ , and number of examples per task, $\alpha$ . (ii) At inference time, there is a generalization transition in the number of few-shot examples, as the number of examples grows, the models starts to generalize. This effect is somewhat similar to the transition in sample complexity for the modular arithmetic found in [24]. (iii) model develops a striking circular representation for all of the tasks that naturally generalizes the circular representations found in the original work [24]. We further find that the deeper models are easier to optimize, but much harder to interpret. The optimization is discussed in more detail in the main text. Here we will highlight that optimization for these tasks is challenging and the AM tends to prefer the minimum that just solve a handful of tasks and memorize the training set. To avoid such minima we make sure that every batch contains equal number of tasks (meaning that no tasks is over- or under-represented in each batch). We further find that for larger models early stopping is necessary because the generalizing solution is transient.

We organize our paper as follows. Section 2 contains the literature review. In Section 3 we explain our notations and discuss the experimental details. In Section 4 we demonstrate empirically that the out-of-distribution ICL ability emerges as the number of training tasks increases. We also study the effects of model depth and task difficulty. In Section 5 we carefully examine a minimal setting, i.e. two-block transformer: we compare the representations learnt in four different phases and show that in the generalizing phase the representations are highly structured and generalize the original modular addition case of [24].

# 2 Related Works

In-Context Learning (ICL) Brown et al. [5] first demonstrated that large models performance improves substantially when a few examples of the task at hand are provided at inference time, in the prompt. Akyürek et al. [2], Ahn et al. [1], von Oswald et al. [28] showed that the AM implements emergent first-order optimization on an emergent objective function to solve linear regression tasks. Furthermore, [2] showed that larger models learn to perform Bayesian estimation. Garg et al. [10] demonstrated that transformers can learn several simple classes of functions in context. Kirsch et al. [15] presented how task diversity and model size would affect the ICL performance for unseen tasks using a mixture of modified MNIST datasets. Raventos et al. [25] investigated the relation between task diversity and out-of-distribution ICL ability on linear regression tasks. Lin and Lee [16] identified two operating modes in ICL using a mixture of linear regression tasks, where for the first several shots, the model tries to figure out the correct task vector and later uses it to predict the correct results. Boix-Adserà et al. [4] showed theoretically and experimentally that with enough pre-training data, a transformer model can perform abstract reasoning that a MLP cannot do. Guo et al. [13] showed that transformers can use lower layers to memorize and upper layers to perform ICL in a feature regression setting. It was found in [26] that ICL is a transient phase from the optimization point of view: it goes away once the model is over-trained. Hendel et al. [14], Liu et al. [17] showed that language models form in-context vectors, which can be used to steer model predictions.

Modular Arithmetic Power et al. [24] discovered Grokking, where models trained on modular arithmetic datasets have an abrupt change from random guessing to generalization on the test set way after the model memorized the training set. Gromov [11], Nanda et al. [20], Gu et al. [12] showed that for modular addition tasks, models learned to map integers to Fourier features to solve modular arithmetic tasks. Liu et al. [18] showed that grokking is related to learning highly structural features, and the grokking transition can be explained by a toy model. Zhong et al. [30] showed that there is more than one algorithm that a model can implement to solve modular addition. Doshi et al. [6] showed that corruption of the label does not prevent the models from finding a generalizing solution. Doshi et al. [7] showed that MLP and transformer models can solve a specific family of modular polynomial tasks by bijectively mapping them to modular addition tasks.

Interpretability Elhage et al. [8], Olsson et al. [22] showed that transformers can form induction heads that predict the next token in a sequence by identifying and copying patterns from earlier in the sequence. With several indirect empirical evidences, they showed that those heads might constitute the core mechanism of ICL. Nichani et al. [21] showed theoretically and empirically how disentangled transformers learn causal structures from in-context Markov chains by forming induction heads.

# 3 Preliminaries

Linear Modular Functions We consider modular arithmetic tasks of the form: $z _ { i } ^ { t } = a ^ { t } x _ { i } +$ $b ^ { t } y _ { i }$ mod $p$ . We will refer to the coefficients $( a ^ { t } , b ^ { t } ) \in \mathbb { Z } _ { p } ^ { 2 }$ as the task vector. The superscript $t \in \{ 1 , \cdots , p ^ { 2 } \}$ labels the $p ^ { 2 }$ possible tasks. We will refer to $\textstyle { \dot { ( } } x _ { i } , y _ { i } { \mathrm { ) } } \in \mathbb { Z } _ { p } ^ { 2 }$ as the input vector, which is labeled by the subscript $i \in \{ 1 , \cdots , p ^ { 2 } \}$ .

In-Context Learning with Transformers We use GPT-like transformers [5] with ReLU activation function and Rotary Positional Embedding (RoPE) [27]. The model has $d$ consecutive blocks, $H$ attention-heads, and embedding dimension $d _ { \mathrm { e m b e d } }$ . Each number is tokenized as an independent token. The pre-training is done following a slightly modified next-token prediction setup, with sequences of the form:

$$
\begin{array} { r l r l r l r l r l r l } { \pmb { s } ^ { t } = ( x _ { 1 } } & { y _ { 1 } } & & { } & { x _ { 2 } } & { y _ { 2 } } & { } & & { \cdots } & { x _ { n _ { \mathrm { c t x } } } } & { y _ { n _ { \mathrm { c t x } } } } & { } & & { } & { } & { } & { } & { } \end{array} ) \in \mathbb { Z } _ { p } ^ { 3 \times n _ { \mathrm { c t x } } } ,
$$

where $n _ { \mathrm { c t x } }$ is the maximum number of in-context examples. The model is asked to predict only the labels zt , $\{ z _ { 1 } ^ { t } , \cdots , z _ { n _ { \mathrm { c t x } } } ^ { t } \}$ . We emphasize that we do not explicitly provide the task vectors $( a ^ { t } , b ^ { t } )$ to the model (see Fig. 1) – this information is implicit in the in-context labels $\{ z _ { i } ^ { t } \}$ . In order for the model to generalize, it must determine the underlying task vector $( a ^ { t } , b ^ { t } )$ from the few-shot examples.

Generalization There are two notions of generalization in this setup. (i) In-distribution: Generalization to unseen input vectors $( x _ { i } , y _ { i } )$ , but on task vector $( a ^ { t } , b ^ { t } )$ the model has seen during pre-training. (ii) Out-of-distribution: Generalization to task vectors the model has not seen during pre-training. To clearly separate these regimes, we split the task vectors into in-distribution (i.d.) set $\mathcal { T } _ { \mathrm { i . d . } } \dot { \mathbf { \Omega } } : = \{ ( a ^ { t } , b ^ { t } ) \} _ { \mathrm { i . d . } }$ and outof-distribution (o.o.d.) set $\mathcal { T } _ { \mathrm { o . o . d . } } : = \{ ( a ^ { t } , b ^ { t } ) \} _ { \mathrm { o . o . d . } }$ . Similarly, we split the input vectors into train and test sets: $\mathcal { X } _ { \mathrm { t r a i n } } : = \bar { \{ ( x _ { i } , y _ { i } ) \} } _ { \mathrm { t r a i n } } , \mathcal { X } _ { \mathrm { t e s t } } : = \{ ( x _ { i } , y _ { i } ) \} _ { \mathrm { t e s t } }$ . This results in four distinct sets of sequences constructed from those sets; we name them Sti.rda.in, Sti.eds.t, St $S _ { \mathrm { t r a i n } } ^ { \mathrm { o . o . d } }$ and $S _ { \mathrm { t e s t } } ^ { \mathrm { o . o . d . } }$ . The set Sti.rda.in is used for pre-training, while the other three sets are used for evaluations.

<html><body><table><tr><td colspan="2">performswell</td><td colspan="3">performs poorly</td></tr><tr><td></td><td>strain</td><td>stest</td><td>strad</td><td>so.o.d. Stest</td></tr><tr><td>In-distriation</td><td></td><td></td><td></td><td></td></tr><tr><td>In-distribtion</td><td></td><td></td><td></td><td>?</td></tr><tr><td>Out-of-distribution memorization</td><td></td><td>×</td><td>√</td><td>×</td></tr><tr><td>Out-of-distribution generalization</td><td></td><td></td><td></td><td></td></tr></table></body></html>

Pre-Training Task Selection and Sequence Design We always sample the pre-training task vectors $\mathcal { T } _ { \mathrm { i . d . } }$ . in sets of 4, following the rectangular rule, shown in Figure 2(a). Additionally, each batch contains an equal representation from all the task vectors in the set $\mathcal { T } _ { \mathrm { i . d . } }$ . Moreover, all the tasks share the same sequence of inputs. For example, a batch with two different task vectors $( a ^ { t _ { 1 } } , b ^ { t _ { 1 } } ) ; ( a ^ { t _ { 2 } } , b ^ { t _ { 2 } } )$ and two distinct input sequences per task (resulting in four total sequences) is shown in Figure 2(b).

![](images/122ac62dd8afd36529a3c3e7b86f1b0579775dc866804665647f1667b5a40b00.jpg)  
Figure 2: Structured selection of pre-training tasks and sequences.

This structured approach creates a coherent signal from the sequences within each batch; ensuring that the model learns multiple task vectors with reasonable batch sizes. Alternatively, if the batches are sampled i.i.d., then the model is confused by the batch noise and cannot learn any tasks.

Detailed discussions on task selection and sequence design are presented in Appendix D.

Default Setting Unless stated explicitly, we will use $p = 2 9$ , the number of heads $H = 4$ , and embedding dimension $d _ { \mathrm { e m b e d } } = 5 1 2$ , with $n _ { \mathrm { c t x } } = 3 2$ in-context examples. All models are trained with AdamW optimizer [19] with batch size $B = 1 0 2 4$ for $2 0 0 \mathbf { k }$ steps. We have also tied the embedding layer of the model with the readout layer.

# 4 Emergence of In-Context Learning and Task Composition

In this section, we demonstrate that a transformer model with depth $d \geq 2$ can develop ICL and out-of-distribution generalization on modular arithmetic tasks. We delve deeper into the two notions of generalization (i.d. and o.o.d.), and discuss the relevant factors. We find that the model’s ability to generalize out-of-distribution is predominantly determined by the number of pretraining tasks $n _ { \mathrm { i . d . } }$ .

# 4.1 Transition driven by the number of tasks

In Figure 3(a), we show the accuracy of $d = 6$ models vs the number of training tasks $n _ { \mathrm { i . d . } }$ . and the number of few-shot examples quantified by the fraction of the total number of data points, $\alpha$ ; on sets $S _ { \mathrm { t r a i n } } ^ { \mathrm { i . d . } } , S _ { \mathrm { t e s t } } ^ { \mathrm { i . d . } } , S _ { \mathrm { t r a i n } } ^ { \mathrm { o . o . d } }$ and $\bar { S } _ { \mathrm { t e s t } } ^ { \mathrm { o . o . d . } }$ . The phase diagram in Figure 1 is constructed by merging the last shot accuracy version of these four diagrams shown in Figure 27(a) of Appendix G.

![](images/54dec4160f4fa8a02ea7b2ea8fb88204df5c5325f6147f34b30d5f000e8c99f7.jpg)  
Figure 3: Phase diagram for the depth $d = 6$ models. (a) Accuracy on all four sets used to plot the 1 phase diagram, with an early stopping applied. Notably, in the regions when models generalize to o.o.d. sets, the pre-training performance degrades; $( \mathbf { b } , \mathbf { c } )$ $\alpha = 0 . 6$ training accuracy and o.o.d. test accuracy (dotted line). For $\dot { n } _ { \mathrm { i . d . } } = 2 ^ { 8 }$ , we notice that the o.o.d. generalization ability of the model first improves then degrades as we train longer; $( \mathbf { d } , \mathbf { e } )$ $\alpha = 0 . 6$ , loss and accuracy vs context length, measured on $S _ { \mathrm { t e s t } } ^ { \mathrm { o . o . d . } }$ . at the end of training, where for $n _ { \mathrm { i . d . } } = 2 ^ { 8 }$ case the ICL ability fades away.

The ability of the model to generalize in-distribution increases with $\alpha$ , as can be seen by comparing the first two panels of Figure 3(a). This behavior is in correspondence with the original work on grokking, where the transition to generalizing solution is driven by the amount of data. Further, we observe that an increase in $n _ { \mathrm { i . d . } }$ enhances the in-context sample efficiency, i.e. the model generalizes at inference time with fewer few-shot examples. This indicates the onset of the transition from a task-memorizing solution to the one that generalizes out-of-distribution. The model switches to a new algorithmic way of solving the task and the solution is more few-shot-sample-efficient.

Shifting our focus to the last two panels of Figure 3(a), we see that when $n _ { \mathrm { i . d . } } \geq 2 5 6$ , the model can solve new tasks that were absent in the training set. Notably, there appears to be a trade-off between memorization and generalization when the model attains this o.o.d. generalization ability. As the o.o.d. performance increases, the pre-training performance simultaneously degrades. This phenomenon indicates a shift in the algorithm implemented by the model. Prior to this transition, the model primarily needed to select possible vectors from the list of memorized tasks and apply them. However, post-transition, the model adopts a more universal approach to solve the task in-context. We emphasize, that the model learns to perform ICL in both scenarios. The difference lies in the approach to generalization. When the model can only generalize in-distribution it’s task is to classify the sequence as one of the seen tasks or as unknown. Once it matches the sequence to one of the memorized task vectors, it does well for $x , y$ pairs that only appear in the test set. However, as the number of tasks vectors grows the model fails to store them all and is forced to find a method of determining the task vector algorithmically at inference time. In that case model performs equally well on seen and un-seen tasks alike. In fact, the small two-layer model we study has such a low capacity that it entirely skips the in-distribution generalization phase and immediately jumps from pure memorization to out-of-distribution generalization.

Next, to further illustrate the effect of task diversity, we plot the pre-training accuracy (set $S _ { \mathrm { t r a i n } } ^ { \mathrm { i . d . } } )$ and the o.o.d. test accuracy (set $S _ { \mathrm { t e s t } } ^ { \mathrm { o . o . d . } } )$ as a function of training steps (Figure $3 ( \boldsymbol { \mathrm { b } } , \boldsymbol { \mathrm { c } } ) )$ ; for various values of $n _ { \mathrm { i . d . } }$ . We observe a clear memorization-to-generalization transition as task diversity increases. Interestingly, for $n _ { \mathrm { i . d . } } = 2 ^ { 8 }$ , the ICL ability on $\mathbf { \bar { \it S } } _ { \mathrm { t e s t } } ^ { \mathrm { o . o . d . } }$ set exhibits non-monotonic behavior, where the o.o.d. performance rises and falls along the training process. This phenomenon is likely due to a competition between the memorizing and generalizing circuits inside the model. Note that this phenomenon is akin to the one analyzed in Singh et al. [26], albeit with a different setup.

![](images/a864509b6295ba119439c45cb3583c2bf7902b70dd52de1432bba119ae72bead.jpg)  
Figure 4: Phases of depth $d = 4$ and $d = 2$ models. With decreasing model capacity, the performance on both sets degrades. At the same time, the transient nature of ICL does not appear. $( \mathbf { a } , \mathbf { b } )$ from left to right: accuracy phase diagrams on pre-training set $S _ { \mathrm { t r a i n } } ^ { \mathrm { i . d . } }$ and on o.o.d. test set $S _ { \mathrm { t e s t } } ^ { \mathrm { o . o . d . } }$ , with early stopping; loss and accuracy vs context length on o.o.d. test set $S _ { \mathrm { t e s t } } ^ { \mathrm { o . o . d . } }$ for $\alpha = 0 . 6$ .

Further evidence supporting the two-circuit competition can be observed in panel (d) of Figure 3. The loss curves show a “monotonic $$ non-monotonic $$ monotonic” transition as the task diversity increases. With a minimal number of pre-training tasks, the model primarily engages in memorization, resulting in a monotonically increasing o.o.d. loss curve. As the number of pre-training tasks increases, the loss curve exhibits non-monotonic behavior, indicating competition between two distinct neural circuits. This transient nature of o.o.d. generalization for $\bar { n _ { \mathrm { i . d . } } } = \bar { 2 } ^ { 8 }$ is a peculiar case where memorization circuits are initially suppressed but eventually prevail. With substantial task diversity, the circuits responsible for generalization take over, culminating in a monotonic loss curve. Similar insights can be derived from examining the monotonicity of the accuracy curves in panel (e).

# 4.2 Effect of Model Size and Task Difficulty

A natural question to ask is if similar phenomena can be observed with different model sizes or task difficulties. Here we present our results with $d = 4$ and $d = 2$ in Figure 4 and leave the results for other prime $p$ values in Appendix H.

When comparing phase diagrams in Figure 3 with Figure 4, we observe that those phase diagrams across different depths are qualitatively similar, where the o.o.d. generalization only emerges with a large enough number of pre-training tasks. As model capacity decreases, performance on both the pre-training set and the o.o.d. test set degrades. This is particularly evident in the $d = 2$ case, where the pre-training accuracy falls drastically as the model gains o.o.d. generalization ability.

Interesting observations can be made by comparing loss and accuracy on the o.o.d. test set as a function of context length at the end of training. First, it is evident that as the model depth decreases, the 1-shot loss surge attributable to memorization becomes milder. Notably, for models with $n _ { \mathrm { i . d . } } = 2 ^ { 9 }$ , there is no loss surge in the 1-shot case across all three depths. Furthermore, the $d = 4$ model with $n _ { \mathrm { i . d . } } = 2 ^ { 8 }$ behaves significantly differently from the corresponding one with $d = 2$ case, where the model fails to perform ICL for the o.o.d. test set. This is also distinct from the $d = 6$ case, where the model tends heavily toward memorization due to its excessive capacity. Instead, the $d = 4$ model manages to maintain a better balance between memorization and generalization at the end of pre-training. Consequently, the model has a 1-shot loss surge followed by a notable drop in ICL loss. This suggests that $d = 4$ optimally leverages the available model capacity to facilitate effective learning dynamics for o.o.d. generalization.

![](images/4ea59a990afb8d4fc35dab53a62e6503641b7e731efeb32e77fbbfd291187610.jpg)  
Figure 5: $d = 4$ and $d = 2$ models’ performance on $\mathbf { k }$ -shot inference, on the grid of inputs $( x , y ) \ \in \ \mathbb { Z } _ { p } ^ { 2 }$ (task vector $\mathbf { \theta } = \mathbf { \eta } ( 6 , 6 ) )$ . row 1: Models’ predictions on o.o.d. task of the type $ \begin{array} { r l r l r l r l } { { \langle } x _ { 1 } } & { { } y _ { 1 } } & { } & { { } \quad } & { \dots } & { { } x _ { k } } & { { } y _ { k } } & { } & { { } } & { } & { { } \dots } \end{array}$ x y ?). row 2: Analytical plots showing predictions solely based on Modular Regression algorithm. row 3: Subtract row 2 from row 1, by using correct=1 and incorrec $_ { = 0 }$ . The red points correspond to the examples where Ratio Matching does not give the correct predictions but the model predicts correctly. The blue points are examples that the model missed despite Ratio Matching being applicable. This row tells us about the model’s ability to implement Modular Regression by combining the in-context examples. Note that $d = 4$ model readily learns to combine previous examples, while its $d = 2$ counterpart struggles due to its limited capacity.

# 5 Interpreting the Learned Algorithms

We now explain the algorithms implemented by the models to achieve o.o.d generalization. We find that the models implement two distinct algorithms depending on the depth and the number of in-context examples during inference.

Ratio Matching: If there exists $i$ s.t. $c _ { i } ( x _ { i } , y _ { i } ) = ( x , y )$ mod $p$ then $z = c _ { i } z _ { i } ^ { t }$ mod $p$ . This algorithm only works when $y / x = y _ { i } / x _ { i }$ mod $p$ holds for at least one of the in-context examples.

Modular Regression: Find $\{ c _ { 1 } , c _ { 2 } , \ldots , c _ { k } \}$ s.t. $\textstyle \sum _ { i = 1 } ^ { k } c _ { i } ( x _ { i } , y _ { i } ) = ( x , y )$ mod $p$ . Then the prediction is $\textstyle z = \sum _ { i = 1 } ^ { k } c _ { i } z _ { i }$ mod $p$ . This can be viewed as discretized circular regression over $\mathrm { G F } ( p )$ .

We find telling signatures of these algorithms upon analyzing model predictions with varying numbers of in-context examples (Figure 5). With very few in-context examples, the models implement the Ratio Matching algorithm. As a canonical example, consider the 1-shot scenario $( x _ { 1 } y _ { 1 } x y \_ y )$ . In this case, Ratio Matching will only solve the task for inputs that obey $( x , y ) = c _ { 1 } ( x _ { 1 } , y _ { 1 } )$ mod $p$ for some $c _ { 1 }$ . Indeed, this is exactly what we observe in Figure 5 for both $d = 2 , 4$ models. With many $( \sim 1 0 )$ in-context examples, $d = 2$ and $d = 4$ models implement different algorithms. The $d = 4$ model can combine the in-context examples using the Modular Regression algorithm, leading to near-perfect o.o.d. generalization. On the other hand, the $d = 2$ model still uses Ratio Matching and shows sub-optimal performance. We ascribe this to the limited capacity of the $d = 2$ models. In other words, the $d = 4$ models exhibits an algorithmic shift from Ratio Matching to Modular Regression as them number of in-context examples increases. Whereas, the $d = 2$ models shows no such shift.

To implement these algorithms, the model needs to perform linear operations over $\mathrm { G F } ( p )$ , which can be broken down into the following essential skills (in addition to copying information, which is readily implemented by attention heads).

I. Modular Map: Encode the tokens such that operations over $\mathrm { G F } ( p )$ can be easily implemented II. Multiplication: A necessary skill to rescale in-context examples in both algorithms III. Addition: A necessary skill for combining in-context examples in Modular Regression algorithm

While both $d = 2 , 4$ models learn skills I, II perfectly; the $d = 4$ model outperforms its $d = 2$ counterpart in skill III – which helps it combining the in-context examples.

In the remainder of this section, we show the special attention heads that implement skill I (Section 5.1) and MLPs that implement skills II, III (Section 5.2). We explicitly show the deterioration in this structures as pre-training task diversity $( n _ { i . d . } )$ decreases. We also elucidate the algorithmic shift in the $d = 4$ models as the number of in-context examples increases.

![](images/64bd155696bf220c0b0a3285f253f70e584adac8ac23ce525d900c9684dc497f.jpg)  
Figure 6: Models that generalize o.o.d. (left) exhibit more structured attention maps. Additionally, the top-2 principal components of the features from the corresponding heads also show more structured patterns. The features are computed for sequences with an o.o.d. task vector $( a ^ { t } , b ^ { t } ) = ( 6 , 6 )$ , loop over $( x _ { i } , y _ { i } )$ at a specific shot while the previous parts of the sequence are fixed. We annotate each PCA plot with the $( \log _ { 2 7 } x _ { i } , \log _ { 2 7 } y _ { i } )$ mod $p$ pairs. (a) The principal components form a circle of circles where the position of the outer circle is controlled by $x _ { i }$ . This pattern remains the same for different task vectors or the shot choices; (b) Only plotted pairs with even $\log _ { 2 7 } x _ { i }$ , with each $\log _ { 2 7 } x _ { i }$ circled with different colors. The PCA pattern forms a similar double circle as those in (a), with the key difference that those circles depend on task vector choices and the shot choices; $( \mathbf { c } , \mathbf { d } )$ Models without o.o.d. generalization ability. We pick heads from the first block that corresponds to the first column of (a). Clearly, the structure of attention maps and PCA patterns deteriorate as the task diversity decreases.

# 5.1 Attention Heads Implement Skill I

So far we have presented “black-box” evidence suggesting that the model is implementing the proposed algorithms (Figure 5). Now, we turn to “white-box” interpretability, to identify the components within the transformer model that are responsible for the essential skills. In Figure $6 ( \mathrm { a } , \mathrm { b } )$ , we analyze the important attention heads in the $d = 2$ model. Specifically, we compare the emergent structures in models trained with different pre-training task diversities.

In Figure 6(a), we show the attention head from layer 1 that implements skill I. In the top panel, we see that each query only pays attention to itself and the two preceding keys. This pattern likely stems from the fact that each example in the sequence contains three tokens $x _ { i } , y _ { i } , z _ { i } ^ { t }$ ; and suggests that this head is mostly focused on the information within the example.

In the bottom panel, we perform principal component analysis (PCA) on the outputs of this head. Specifically, we feed a batched $\mathbf { k }$ -shot sequence of the form $( x _ { 1 } y _ { 1 } z _ { 1 } \dots x _ { k } y _ { k } z _ { k } x y z )$ , where the first $k$ inputs are fixed and the last input $( x , y )$ is scanned over all $p ^ { 2 }$ possible pairs. We concatenate the resulting features from $x$ and $y$ , resulting in $p ^ { 2 } \times 2 d _ { \mathrm { e m b e d } }$ batch of features – and perform PCA on this matrix. We project all these $2 d _ { \mathrm { e m b e d } }$ dimensional features onto the first two principal components. Annotating the pairs $( x , y )$ with $( \log _ { 2 7 } x , \log _ { 2 7 } y ) ^ { 1 }$ , we find a “circle-ofcircles” – where circles of period 28 are arranged in a bigger circle of period 28. Number 0 is located at the center of the circles2. We observe similar circle-of-circles for concatenated features from $( x , z )$ and $( y , z )$ as well. We refer the reader to Appendix E for further details.

![](images/d680105e8d17a19b0209d9832f2f03d40f1cdca7ab09cfefa56e57952536fd34.jpg)  
Figure 7: Cosine-similarities (Equation (2)) between layer outputs $h ^ { l }$ at token $z$ position $( \cos ( h _ { z } ^ { l } ( x , y ) , h _ { z } ^ { l } ( x ^ { \prime } , y ^ { \prime } ) )$ , first row) and token $y$ position $( \dot { \cos } ( h _ { y } ^ { l } ( \dot { x } , y ) , h _ { y } ^ { l } ( x ^ { \prime } , y ^ { \prime } ) )$ , second row) reveal patterns in the models’ internal representations. For clarity, we only show selected $x$ and $x ^ { \prime }$ values, where $y$ and $y ^ { \prime }$ values range from 0 to 28 between each tick. For the $d = 4$ model, kaleidoscopic patterns in the third layer indicate the generation of all possible $y _ { i } / x _ { i }$ features for subsequent computations. The last layer shows an algorithmic shift from Ratio Matching to Modular Regression. The $d = 2$ model also shows the kaleidoscopic pattern in the first layer, while the second layer identifies the relevant $y / x$ features from the in-context examples for matching.

In Figure 6(b), we analyze the head from layer 2 that effectively “copies” in-context examples. The upper panel shows the highly structured attention map that focuses on the current as well as the preceding examples. This pattern aligns with the Ratio Matching algorithm where the model compares $( x , y )$ pairs across different in-context examples.

In the bottom panel, by conducting a PCA analysis, we again identify circles when annotating examples in the $( \log _ { 2 7 } x , \log _ { 2 7 } y )$ format. However, unlike the previously discussed pattern, the specifics of this “circle-of-circles” arrangement vary depending on the position and the choice of task vector $( a ^ { t } , b ^ { t } )$ . This variability suggests that the head in question possesses information about the specific task from the context.

We further highlight the importance of the structure we find in the above paragraphs via comparison with models, trained with lower pre-training task diversity, that do not generalize o.o.d (Figure 6 c, d). Note that as the number of pre-training tasks $n _ { \mathrm { i . d } }$ . decreases, the attention map starts to get mosaicked (top panels); and the PCA projections lose their shape (bottom panels). As a result, these models lose the ability to perform ICL on modular arithmetic out-of-distribution.

# 5.2 MLPs Implement Skill II and III

After applying Skill I, the model maps numbers onto circular feature spaces, enabling discrete modular operations such as multiplication, division, addition, and subtraction through subsequent model components. To analyze this behavior, we compute the cosine-similarity between layer $l$ (i.e. ${ { l } ^ { t h } }$ Transformer block) $k$ -shot output vectors (standardized) at token position $y$ : $h _ { y } ^ { \bar { l } } ( x _ { 1 } , y _ { 1 } , \textrm { } , \cdot \cdot \cdot , x _ { k } , y _ { k } , \textrm { } , x , y )$ .

$$
\cos ( h _ { y } ^ { l } ( x , y ) , h _ { y } ^ { l } ( x ^ { \prime } , y ^ { \prime } ) ) = \frac { h _ { y } ^ { l } ( . . . , x _ { k } , y _ { k } , z _ { k } , x , y ) \cdot h _ { y } ^ { l } ( . . . , x _ { k } , y _ { k } , z _ { k } ^ { \prime } , x ^ { \prime } , y ^ { \prime } ) } { \| h _ { y } ^ { l } ( . . . , x _ { k } , y _ { k } , z _ { k } , x , y ) \| \| h _ { y } ^ { l } ( . . . , x _ { k } , y _ { k } , z _ { k } , x ^ { \prime } , y ^ { \prime } ) \| }
$$

![](images/740a91c4bdd0d9dc9db265acc9c9cc8b143f08816affb4d8fe01b32c5cd53ec2.jpg)  
Figure 8: MLP activations (post-ReLU) wrt inputs $( x , y )$

We evaluate this similarity metric across all possible input pairs $( x , y )$ and $( x ^ { \prime } , \bar { y } ^ { \prime } )$ , resulting in a $p ^ { 2 } \times p ^ { 2 }$ matrix. We also repeat the analysis to layer output vectors at $z$ tokens $h _ { z } ^ { l } ( \cdot )$ . In line with our previous analysis, we use controlled (fixed) in-context examples $( x _ { 1 } y _ { 1 } \dots x _ { k } y _ { k } \quad )$ .

For the $\ d \quad = \quad 4$ model, the top panel of Figure 7 reveals a distinctive kaleidoscopic pattern3 of high cosinesimilarities. The pattern corresponds to input pairs $( x , y )$ that share the same ratio $y / x$ mod $p$ . In the MLP modules,

we find highly structured activations as functions of inputs $( x , y )$ (Figure 8 left). Together with our earlier analysis of Skill I, these observations suggest that the MLP layer following the attention module with a “circle-of-circles” head (layer 2, head 4 for $d = 4$ model, see Figure 13 (a)) implements division operations over $\mathrm { G F } ( p )$ . The bottom panel of Figure 7 succinctly demonstrates the algorithmic shift from Ratio Matching to Modular Regression as the number of in-context examples increases. At 2-shot, layer 4 features collapse to identical vectors except when the ratio $y / x$ matches one of the ratios $( y _ { 1 } / x _ { 1 }$ or $y _ { 2 } / x _ { 2 } \mathrm { , }$ ). At higher shots, we see a transition to a task-dependent pattern where features align for input pairs $( x , y )$ for which $a x + b y$ mod $p$ match – a signature of Modular Regression.

For $d = 2$ models, we again observe the kaleidoscopic pattern in cosine-similarities (Figure 7 topright) and structured MLP activations (Figure 8 right). However, in this case we only find signatures of Ratio Matching in the cosine similarities (Figure 7 bottom-right), as expected.

Thus, we conclude that the $d = 2$ model has scarcely acquired skill III, due to its limited capacity. On the other hand, $d = 4$ model is very good at combining equations via skill III, explaining its superior performance. For a more detailed discussion, see Appendix E.

# 6 Discussion

We have investigated the emergence of in-context learning and skill composition in autoregressive models on a novel algorithmic dataset. The dataset includes a large discrete set of modular arithmetic tasks and is specifically designed to force models to learn how to solve a variety of tasks. It consists of learning linear modular functions, where the model is expected to identify and perform a modular operation in-context. When the number of tasks is relatively small the models can only generalize in-distribution. Although such models develop ICL capabilities, they simply memorize these task vectors and use them to classify the input vectors. Once the number of training tasks becomes too large, the models transition to a qualitatively different algorithmic approach, where the task vector is determined at inference time.

Finally, we have examined the learnt representations and shown that qualitatively different circuits are formed in different phases. In the o.o.d. generalization phase, we explain the learnt algorithms and highlight an in-context algorithmic shift in deeper models.

Limitations We have limited this work to algorithmic datasets. It remains to be investigated what lessons can be translated to realistic language models, and what lessons are specific to the current setting. White-box interpretability analysis of deeper models has proved to be much more difficult than that of shallower models. Consequently, we still do not understand the role of every individual component of the network in the deeper cases.