{
    "link": "https://arxiv.org/abs/2411.04732",
    "pdf_link": "https://arxiv.org/pdf/2411.04732",
    "title": "Convolutional Differentiable Logic Gate Networks",
    "authors": [
        "Felix Petersen",
        "Hilde Kuehne",
        "Christian Borgelt",
        "Julian Welzel",
        "Stefano Ermon"
    ],
    "institutions": [
        "Stanford University"
    ],
    "publication_date": "2024-11-07",
    "venue": "Neural Information Processing Systems",
    "fields_of_study": [
        "Computer Science"
    ],
    "citation_count": 4,
    "influential_citation_count": 0,
    "paper_content": "# Convolutional Differentiable Logic Gate Networks\n\nFelix Petersen   \nStanford University   \nInftyLabs Research   \nmail@felix-petersen.de\n\nHilde Kuehne Tuebingen AI Center MIT-IBM Watson AI Lab h.kuehne@uni-tuebingen.de\n\nChristian BorgeltUniversity of Salzburgchristian@borgelt.net\n\nJulian Welzel InftyLabs Research welzel@inftylabs.com\n\nStefano Ermon Stanford University ermon@cs.stanford.edu\n\n# Abstract\n\nWith the increasing inference cost of machine learning models, there is a growing interest in models with fast and efficient inference. Recently, an approach for learning logic gate networks directly via a differentiable relaxation was proposed. Logic gate networks are faster than conventional neural network approaches because their inference only requires logic gate operators such as NAND, OR, and XOR, which are the underlying building blocks of current hardware and can be efficiently executed. We build on this idea, extending it by deep logic gate tree convolutions, logical OR pooling, and residual initializations. This allows scaling logic gate networks up by over one order of magnitude and utilizing the paradigm of convolution. On CIFAR-10, we achieve an accuracy of $8 6 . 2 9 \\%$ using only 61 million logic gates, which improves over the SOTA while being $2 9 \\times$ smaller.\n\n# 1 Introduction\n\nDeep learning has led to a variety of new applications, opportunities, and use-cases in machine vision. However, this advancement has come with considerable computational and energy costs for inference [1]. Therefore, an array of methods has been developed for efficient deep learning inference [2]–[7]. These include binary weight neural networks (BNNs) [2], a set of methods for quantizing neural network weights down to binary representations (and sometimes also binary activations); quantized low-precision neural networks [3], a superset of BNNs and sparse neural networks [4]–[6], a set of approaches for pruning neural networks and increasing sparsity. These methods have been successfully utilized for efficient vision model inference.\n\n![](images/f5324a71b95a4bffe2247dbc71e3e9fdaca9ce587c47b1ae44f0eb9eca8bcc81.jpg)  \nFigure 1: Gate count vs. accuracy plot on the CIFAR-10 data set. Our models $( { \\star } )$ are substantially above the pareto-front of the SOTA baselines. Gate counts are proportional to chip area. Our models are more efficient than the SOTA by factors of $\\geq 2 9 \\times$ . Note that the $x$ -axis (gate count) is on a log-scale.\n\nThe state-of-the-art (SOTA) method for small architectures, deep differentiable logic gate networks (LGNs) [7], approaches efficient machine learning inference from a different direction: learning an LGN (i.e., a network of logic gates such as NAND and XOR) directly via a differentiable relaxation.\n\nDifferentiable LGNs directly learn the combination of logic gates that have to be executed by the hardware. This differs from other approaches (like BNNs) that require translating an abstraction (like matrix multiplication-based neural networks) into executable logic for inference, an inductive bias that comes with a considerable computational burden. By optimizing the logic directly on the lowest possible level instead of optimizing an abstraction, differentiable LGNs lead to very efficient inference on logic gate-based hardware (e.g., CPU, GPU, FPGA, ASIC). Recently, differentiable LGNs achieved SOTA inference speeds on MNIST [7], [8]. However, a crucial limitation was the random choice of connections, preventing LGNs from learning spatial relations, as they arise in images, which limited performance to an accuracy of only $6 2 \\%$ on CIFAR-10 [7], [9]. To address this limitation, we propose to extend differentiable LGNs to convolutions. Specifically, we propose deep logic gate tree convolutions, i.e., kernels comprised of logic gate trees applied in a convolutional fashion. Using trees of logic gates, instead of individual gates, increases the expressivity of the architecture while minimizing memory accesses, improving accuracy and accelerating training as well as inference. Further, we adapt pooling operations by representing them with logical or gates (relaxed via the maximum t-conorm), improving the effectiveness of convolutions in LGNs. Additionally, we propose “residual initializations”, a novel initialization scheme for differentiable LGNs that enables scaling them up to deeper networks by providing differentiable residual connections. These advances lead to an accuracy of $8 6 . 2 9 \\%$ on CIFAR-10 using only 61 million logic gates, leading to cost reductions by $\\geq 2 9 \\times$ compared to SOTAs as displayed in Figure 1.\n\n# 2 Background\n\nOur work builds on and extends differentiable logic gate networks [7]. To recap, logic gate networks (LGNs) are networks of nodes that are binary logic gates like AND, NAND, or XOR. LGNs are also known as binary circuits or logical circuits, and are the format in which any digital hardware is implemented on the lowest pre-transistor abstraction level. The function that an LGN computes depends on the choices of logic gates that form its nodes and how these nodes are connected. Optimizing an LGN requires choosing the connections and deciding on a gate for each node. A primary chal\n\n![](images/a0a8211fda7ffdb0347ac36d10c61bab699d3632daa0a8ddae1df908483da89b.jpg)  \nFigure 2: Architecture of a randomly connected LGN. Each node corresponds to one logic gate. During training, the distribution over choices of logic gates (bottom, 16 options) is learned for each node.\n\nlenge when optimizing LGNs is that they are, by default, non-differentiable, preventing gradient descent-based training, making this problem conventionally a combinatorial problem. However, when applied to machine learning problems, solving the combinatorial problem conventionally becomes infeasible as we require millions of parameters or gates. Thus, a differentiable relaxation of randomly connected LGNs has been proposed, which allows training LGNs with gradient descent [7], overcoming the exponential difficulty of optimizing LGNs. In the remainder of this section, we cover the structure, relaxation, and training of differentiable LGNs, which we also illustrate in Figure 2.\n\nStructure LGNs follow a layered structure with each layer comprising a number of nodes, each comprising one logic gate (3 layers with 4 logic gates each in Fig. 2). As logic gates are inherently non-linear, LGNs do not require any activation functions. Further, LGNs do not have any weights nor any biases as they do not rely on matrix multiplications. Due to the binary (i.e., two-input) nature of the nodes, LGNs are necessarily sparse and cannot form fully-connected networks. The connectivity between nodes has so far been (fully) randomly selected, which works well for easier tasks but can become problematic if there is inherent structure in the data as, e.g., in images. During training, the connections remain fixed and the learning task comprises the choice of logic gate at each node.\n\nDifferentiable Relaxation To learn the choices of logic gate for each node with gradient descent requires the network to be differentiable; however, the LGN is by default not differentiable for two reasons: (i) Because a logic gate computes a discrete function of its (Boolean) inputs, it is not differentiable. (ii) Because the choice of logic gate is not a continuous parameter, but a discrete decision, it is not differentiable. Petersen et al. [7] propose to differentiably relax each logic gate to real-valued logic via probabilistic logic [10], [11]. For example, a logical and $( a _ { 1 } \\land a _ { 2 } )$ is relaxed to $a _ { 1 } \\cdot a _ { 2 }$ and a logical exclusive or $( a _ { 1 } \\oplus a _ { 2 } )$ is relaxed to $a _ { 1 } + a _ { 2 } - 2 \\cdot a _ { 1 } \\cdot a _ { 2 }$ , which corresponds to the output probability when considering two independent Bernoulli variables with coefficients $a _ { 1 } , a _ { 2 }$ . To make the choice of logic gate learnable, Petersen et al. [7] introduce a probability distribution over the 16 possible logic gates $( S )$ , which is encoded as the softmax of 16 trainable parameters. For a trainable parameter vector $\\mathbf { z } \\in \\mathbb { R } ^ { 1 6 }$ and all 16 possible logic gate operations as $g _ { 0 } , . . . , g _ { 1 5 }$ , the differentiable logic gate as the expectation over its outputs can be computed in closed-form as\n\n$$\nf _ { \\mathbf { z } } ( a _ { 1 } , a _ { 2 } ) = \\mathbb { E } _ { i \\sim S ( \\mathbf { z } ) } , A _ { 1 } \\sim \\mathcal { B } ( a _ { 1 } ) , A _ { 2 } \\sim \\mathcal { B } ( a _ { 2 } ) \\left[ g _ { i } ( A _ { 1 } , A _ { 2 } ) \\right] = \\sum _ { i = 0 } ^ { 1 5 } \\frac { \\exp ( z _ { i } ) } { \\sum _ { j } \\exp ( z _ { j } ) } \\cdot g _ { i } ( a _ { 1 } , a _ { 2 } ) .\n$$\n\nWith these two ingredients, logic gate networks become end-to-end differentiable.\n\nInitialization, Training, and Discretization Training differentiable logic gate networks corresponds to learning the parameters inducing the probability distributions over possible gates. The parameter vector $\\mathbf { z }$ for each node has so far been initialized with a standard Gaussian distribution. The connections are randomly initialized and remain fixed during training. For classification tasks, each class is associated with a set of neurons in the output layer and active neurons in each set are counted composing a class score (group sum, right part of Fig. 2). After dividing them by a temperature $\\tau$ , the class scores are used as logits in a softmax cross-entropy loss. Differentiable LGNs perform best when trained with the Adam optimizer [12]. Empirical evidence showed that the softmax distributions typically converge to concrete choices of logic gates. Thus, differentiable LGNs can be discretized to hard LGNs for deployment on hardware by selecting the logic gate with the largest probability. This discretization process incurs only a minimal loss in accuracy compared to the differentiable LGN [7].\n\nLimitations Differentiable LGNs have shown significant limitations wrt. the available architectural components. Previously, they did not provide the option to capture local spatial patterns as they were randomly connected and only operated on flattened inputs [7]. Further, they previously performed well only up to a depth of 6 layers [7]. Thus, more complex relationships between inputs cannot be modeled. Finally, while they provide SOTA performance, differentiable LGNs are very computationally expensive to train, e.g., a vanilla 5 million gate network required 90 hours on an A6000 GPU [7]. In the following, we address these limitations by introducing convolutional logic tree layers, logical or pooling, residual initializations, as well as computational considerations for scaling.\n\n# 3 Convolutional Logic Gate Networks\n\nConvolutional neural networks (CNNs) have experienced tremendous success, being a core contributor to the current machine learning ascendancy starting with their progress on the ImageNet classification challenge in 2012 [13]. Underlying CNNs is the discrete convolution of an input tensor A (e.g., an input image or hidden activations) and a linear function / kernel W, denoted as $\\mathbf { A } * \\mathbf { W }$ . CNNs are especially effective in vision tasks due to the equivariance of the convolution, which allows the network to generalize edge, texture, and shapes in different locations by sharing the parameters at all placements. However, existing differentiable LGN methods do not support convolutions.\n\nIn this work, we propose to convolve activations A with differentiable binary logic gate trees. While we could convolve A with an individual logic gate, we observe that actually convolving\n\n![](images/d5a0f020a383289c9fe85910edf24d32caa573f8e20fb7613ded3b72e5a56325.jpg)  \nFigure 3: Conventional convolutional neural networks (a) compared to convolutional logic gate networks (b). The images illustrate the first and second to last kernel placements. The nodes correspond to weighted sums (a), and binary logic gates $f _ { 1 } , f _ { 2 } , f _ { 3 }$ (b), respectively. The weights / choices of logic gates are shared between kernel placements. For visual simplicity, only a single input channel and kernel (output channel) is displayed.\n\nA with a (deep) logic gate network or tree leads to substantially better performance as it allows for greater expressivity of the model. Similar to how the inputs to each logic gate are randomly initialized and remain fixed in conventional differentiable LGNs, we randomly construct the connections in our logic gate tree kernel function. However, we need to put additional restrictions on the connections for logic gate network kernels. Specifically, we construct each logic gate network kernel as a complete binary tree of depth $d$ with logic gates as nodes and binary input activations as leaves. The output of the logic gate operation is then the input to the next higher node, etc. To capture spatial patterns, we select the inputs / leaves of the tree from the predefined receptive field of the kernel of size $s _ { h } \\times s _ { w }$ . Based on the depth of the tree, we randomly select as many inputs as necessary. For example, we could construct a binary tree of depth $d = 2$ , which means that we need to randomly select ${ \\dot { 2 } } ^ { d } = 4$ inputs from our receptive field, e.g., of size $6 4 \\times 3 \\times 3$ , which corresponds to 64 input channels with a kernel size of $3 \\times 3$ . This tree structure allows to capture fixed spatial patterns and correlations beyond pair-wise binary inputs. Further, it extends the concept of spacial equivariance to LGNs as such trees can be used as kernel filters, capturing general patterns in different locations. Using trees of logic gates instead of individual logic gates also has the advantage of reducing memory accesses and improving training and inference efficiency. We remark that, as we apply convolution, the parameterization of each node is shared between all placements of the kernel (which contrasts convolution from mere local connectivity.) In Figure 3, we illustrate the difference between conventional CNN models and convolutional logic gate networks.\n\nDuring training, the network learns which logic gate operation to choose at each node. Thus, each logic tree kernel is parameterized via the choices of each of the $2 ^ { d } - 1$ logic gates, which are learnable. For a logic kernel of depth 2, we call these logic gates $f _ { 1 } , f _ { 2 } , f _ { 3 }$ (or more formally $f _ { \\mathbf { z } _ { 1 } } , f _ { \\mathbf { z } _ { 2 } } , f _ { \\mathbf { z } _ { 3 } }$ for parameter vectors $\\mathbf { z } _ { 1 } , \\mathbf { z } _ { 2 } , \\mathbf { z } _ { 3 }$ corresponding to Equation 1). Given input activations $a _ { 1 } , a _ { 2 } , a _ { 3 } , a _ { 4 }$ , the kernel is expressed as a binary tree of these logic gates:\n\n$$\nf _ { 3 } \\left( f _ { 1 } ( a _ { 1 } , a _ { 2 } ) , f _ { 2 } ( a _ { 3 } , a _ { 4 } ) \\right) .\n$$\n\nFor an input $\\mathbf { A }$ of shape $m \\times h \\times w$ ( $m$ input channels; height; width) and connection index tensors $\\mathbf { C } _ { M } , \\mathbf { C } _ { H } , \\mathbf { C } _ { W } ^ { \\mathrm { ~ 1 ~ } }$ , each of shape $n \\times 4$ ( $n$ tree kernels / channels; 4 inputs per tree), the output is\n\n$$\n\\begin{array} { r l r } & { } & { { \\bf A } ^ { \\prime } [ k , i , j ] = f _ { 3 } ^ { k } \\left( f _ { 1 } ^ { k } \\left( { \\bf A } \\left[ { \\bf C } _ { M } [ k , 1 ] , { \\bf C } _ { H } [ k , 1 ] + i , { \\bf C } _ { W } [ k , 1 ] + j \\right] , { \\bf A } \\left[ { \\bf C } _ { M } [ k , 2 ] , { \\bf C } _ { H } [ k , 2 ] + i , { \\bf C } _ { W } [ k , 2 ] + j \\right] \\right) , \\right. } \\\\ & { } & { \\left. f _ { 2 } ^ { k } \\left( { \\bf A } \\left[ { \\bf C } _ { M } [ k , 3 ] , { \\bf C } _ { H } [ k , 3 ] + i , { \\bf C } _ { W } [ k , 3 ] + j \\right] , { \\bf A } \\left[ { \\bf C } _ { M } [ k , 4 ] , { \\bf C } _ { H } [ k , 4 ] + i , { \\bf C } _ { W } [ k , 4 ] + j \\right] \\right) \\right) } \\end{array}\n$$\n\nfor $k \\in \\{ 1 , . . . , n \\}$ where $n$ is the number of tree kernels, $i \\in \\{ 1 , . . . , ( h - s _ { h } + 1 ) \\}$ , and $j \\in$ $\\{ 1 , . . . , ( w - s _ { w } + 1 ) \\}$ where $s _ { h } \\times s _ { w }$ is the receptive field size. Note that, in Equation 3, for each output channel $k$ the logic gates $f _ { 1 } ^ { k } , f _ { 2 } ^ { k } , f _ { 3 } ^ { k }$ (or their relaxed form) are chosen and parameterized independently. Per convolution, all placements (indexed via $i , j )$ of one kernel share their parameters.\n\nAfter introducing convolutional LGNs, in the remainder of the section, we introduce our additional components, training strategies, and our architecture.\n\n# 3.1 Logical Or Pooling\n\nIn CNNs, max-pooling is a crucial component selecting the largest possible activation over a predefined receptive field, e.g., for $2 \\times$ 2, $\\operatorname* { m a x } ( a _ { i , j } , a _ { i , j + 1 } , a _ { i + 1 , j } , a _ { i + 1 , j + 1 } )$ [13]. To adopt this for logic, we propose to use the disjunction of the binary activations $a _ { i , j } \\vee a _ { i , j + 1 } \\vee$ $a _ { i + 1 , j } \\vee a _ { i + 1 , j + 1 }$ via the logical $o r$ . Instead of using a probabilistic relaxation of the logical $o r$ , we can use the maximum t-conorm relaxation of the logical or $\\operatorname { \\mathbb { \\rho } } _ { \\operatorname* { m a x } } ( a , b ) = \\operatorname* { m a x } ( a , b ) )$ . By setting the stride of the pooling operation to the size of its receptive field, this has a range of crucial computational advantages: (i) it is faster to\n\n![](images/f90f2c0cf2c6a5a02b19e347dfb886283a004595c090421d12369f957a13a623.jpg)  \nFigure 4: Plot of the density of activations for the second convolutional block of an or-pooling based convolutional LGN. It shows that training implicitly enforces that the outputs of the block have the activation level of a no-pooling network (i.e., with pure stride).\n\ncompute than probabilistic relaxation; (ii) we only need to store the maximum activation and index;   \n(iii) we only need to backpropagate through the maximum activations during training.\n\nIntuitively, using many logical ors could lead to the outputs of the activations becoming predominantly 1. However, we find that, during training, this is not an issue as using or pooling causes an automatic reduction of pre-pooling activations, resolving this potential concern. This phenomenon is shown in Figure 4. Here, the average activation of a convolutional block of a logic network with $2 \\times 2$ strided or pooling is illustrated. For a random network without pooling, we expect and observe an average activation of $50 \\%$ (dash-dotted). We observe that the post or pooling activations (solid line) for the initialized models is $6 6 . 5 \\%$ , which follows expectation. The pre or pooling activations (dashed) are initialized at $50 \\%$ , also following expectations. With training, the post or pooling activations (solid) rapidly converge to the average activations of a network without pooling, preventing any problematic saturation of activations. We do not introduce any explicit regularization enforcing this behavior, but instead found this to be an emerging behavior of training.\n\n# 3.2 Residual Initialization\n\nThe parameters $\\textbf { z }$ of existing differentiable LGNs were initialized as random draws from a Gaussian distribution. Unfortunately, after applying softmax, this leads to rather “washed out” probability distributions over choices of logic gates. Accordingly, the expected activations, as computed via Equation 1, are also washed out, quickly converging towards 0.5 in deeper networks. This also leads to vanishing gradients in existing differentiable LGNs: With Gaussian initialization, during backpropagation, the gradient norm decays at each logic gate by a factor between 0.1 and 0.2 for an initialized network, exponentially slowing training for deeper networks.\n\nIn CNNs, a technique for preventing vanishing gradients and preventing loss of information in deep networks are residual connections. Residual connections conventionally add the input to a block to the output of this block [14]. However, when operating in logic, we cannot perform such additions.\n\nTo prevent the loss of information through washed out activations and reduce vanishing gradients with a joint strategy, we propose residual initializations. For this, we initialize each logic gate not randomly but instead to be primarily a feedforwarding logic gate. Here, we choose $\\cdot _ { A } ,$ as a canonical choice and choosing $\" B \"$ would be equivalent. In our experiments, we found that initializing the probability for the logic gate choice $\\cdot _ { A } ,$ to around $9 0 \\%$ and setting all other gates to $0 . 6 7 \\%$ works well. This corresponds to setting the parameter $z _ { 3 } = 5$ and all other $z _ { i } = 0$ for $i \\neq 3$ in accordance to Eq. 1. We illustrate an example of residual initializations compared to the existing Gaussian\n\ninitializations in Figure 7.\n\nResidual initializations prevent the loss of information as well as vanishing gradients in deeper networks. During training, whenever a residual connection is not required, the model learns\n\n![](images/5c55e643f8d8884dc0576423c03a186c0d38136901d35ade3505aec8c8d86079.jpg)  \nFigure 5: Gaussian initialization (a) [7] vs. our residual initialization (b).\n\nto replace the feedforward logic gate choice by an actual operation. Thus, residual initializations are effectively a differentiable form of residual connections that does not require any hard-wiring. This also means that this form of residuals does not require additional logic gates for residuals. Residual initializations enable, for the first time, efficient and effective training of LGNs beyond 6 layers.\n\n# 3.3 Computational Training Considerations\n\nUsing trees and pooling allows for substantially improved computational training efficiency and memory requirement reductions. This is because it allows intermediate activations to be used only by the current logic gate tree and because we only need to backpropagate through the maximum activations during or pooling. For example, using learnable trees with a depth of 2 and or pooling with a kernel size and stride of $2 \\times 2$ corresponds to a logic gate tree of depth $2 + 2 = 4$ (2 levels are learnable $+ 2$ from pooling) with 16 inputs and only a single output. For training, it is most efficient to discard all intermediate values and only store the output and information of which path through the pooling was selected, and during backward to recompute only this path, thereby reducing memory accesses. The reason for this is that training speed is limited by memory bandwidth and scalability is limited by GPU memory. On average, this strategy reduces memory accesses by $6 8 \\%$ and reduces the memory footprint by $90 \\%$ during training. For using LGNs in hardware designs, trees and pooling improve the locality of operations and routing, which also leads to more efficient chip layouts.\n\nThe residual initializations provide a bias towards the feedforward logic gate in trained LGNs. As feedforward gates only require a wire and no transistors, this further reduces the necessary transistor count for hardware implementations of the LGNs, reducing the required chip area.\n\nWe developed efficient fully-fused low-level CUDA kernels, which, for the first time, enable training of convolutional LGNs. The speed of our convolutional layer is up to $2 0 0 \\times$ faster per logic gate than existing randomly connected LGN implementations [7]. We will make the code publicly available by including it into the difflogic library at github.com/Felix-Petersen/difflogic.\n\n# 3.4 LogicTreeNet Architecture\n\nIn the following, we discuss the design of our convolutional logic gate tree network architectures (LogicTreeNet) for CIFAR-10, which we illustrate in Figure 6. We follow the pattern of conventional convolutional architectures and design the architecture by applying convolutional blocks with pooling at the end of each block. Each block reduces the size by a factor of $2 \\times 2$ and we apply blocks until we reach a size of $2 \\times 2$ , increasing the number of channels in each stage. Following this, we apply two randomly connected layers and a group sum as our classification head. This architecture has an overall logical depth of 23 layers, including 4 convolutional blocks (Conv) with tree depths of $d = 3$ , 4 or pooling layers (or-Pool), and 3 randomly connected layers (Rand). 15 of these layers are trainable (Conv blocks and Rand), and the pooling layers remain fixed. The architecture is defined in terms of a hyperparameter $\\mathbf { k }$ , which controls the width of the overall network; we consider $\\mathtt { k } \\in \\{ \\mathtt { S } \\to 3 2 , \\mathtt { M } \\to 2 5 6 , \\mathtt { B } \\to 5 1 2$ , $\\mathrm { ~ L ~ }  \\ 1 0 2 4$ , $\\mathrm { ~ G ~ }  \\ 2 0 4 8 \\}$ . In Appendix A.1, we describe LogicTreeNet layer-by-layer and include a LogicTreeNet for MNIST.\n\nAn additional architecture choice is the connectivity for the inputs to a convolutional tree. While we rely on random choices for the inputs, we restrict the choices of channels $( \\mathbf { C } _ { M } )$ such that each tree observes only 2 (rather than up to 8) input channels. This has the two advantages of enforcing spatial comparisons of values within one channel and is more efficient in hardware circuit designs. When creating hardware designs, for larger models, routing could become a problem due to congestion when connections between channels follow an arbitrary order. Thus, we restrict the connections between channels to ensure\n\n![](images/f4653ad8558400e82ebdf2efac16548362c78a36368af0399c443ed8147c0b82.jpg)  \nFigure 6: LogicTreeNet architecture. The logical architectures of the layers / blocks are illustrated on a per neuron basis. Circles indicate a logic gate that can be learned while the logical ors remain fixed. During training, for the trainable nodes, we use probabilistic relaxations of logic gates, which we parameterize via a softmax distribution over operators (Eq. 1/3). For the fixed logical ors, we use the continuous maximum t-conorm relaxation.\n\nproper routing: we split the model into $\\mathbf { { k } } / 8$ groups, ensuring no cross-connections between the channels of each group. This restriction as well as similar hardware specific routing restrictions can be implemented without affecting the accuracy due to the sparsity of the logic gate network model.\n\n# 3.5 Input Processing\n\nFor our smaller CIFAR-10 models (S, M), we use 2 bit precision inputs, and encode them using 3 thresholds as in [7]. For our larger CIFAR-10 models (B, L, G), we use 5 bit precision inputs, and process them with low-level feature detectors, in particular, we use edge and curvature detector kernels with thresholds, converting them into binary encodings, which are converted into LGNs and not learned. We note that the gates for the input preprocessing are included in each of the gate counts.\n\n# 4 Related Work\n\nBeyond differentiable LGNs [7], [15] (covered in Section 2), the related work comprises truth table networks [16], [17], binary and quantized neural networks [2], [3], and sparse neural networks [4].\n\nLookup / Truth Table Networks Lookup table networks (aka. truth table networks) are networks comprised of lookup tables (LUTs) or equivalently (potentially complex) logic gates with $n$ inputs.\n\nThere are different approaches for learning or constructing lookup table networks. Chatterjee [16] constructs truth table networks by “memorizing” training data in an explorative work to consider relations between memorization and generalization. Wang et al. [18], [19] replace the multiplication in BNNs by lookup tables (LUTNet). Benamira et al. [17] transform Heaviside step function activated CNNs into lookup tables by expressing the binary activation of each neuron via a lookup table that implicitly encodes the weight matrix (TTNet). This allows obtaining the binary activation of a neuron by “looking up” a value from the truth table at a location encoded via the binary inputs of the layer. Benamira et al. [17] use this as an intermediate representation to then convert the truth tables into LGNs via CNF/DNF (conjunctive / disjunctive normal form) conversion. The resulting LGNs allow for efficient and effective formal verification. These resulting LGNs differ from the LGNs considered in this work because they are derived from a conventional CNN and not directly learned, thereby having the inductive bias of the neural network architecture (matmul) and its computational overhead, which is similar to BNNs converted into LGNs. We remark that, while TTNets are LGNs, TTNets are not differentiable LGNs as there is no differentiable representation of LGNs involved. Recently, Bacellar et al. [20] extended differentiable LGNs to learning logic gates with more than two inputs.\n\nBinary and Quantized Low-Precision Networks BNNs and quantized neural networks reduce the precision of the weight matrices of a neural network. For example, BNNs typically use the weights $- 1$ and $+ 1$ , but variations are possible. For quantized neural networks, a popular choice is 8-bit and other options (such as 4-bit [21]) are covered in the literature. This leads to substantially reduced storage requirements of neural networks at the cost of some accuracy. Instead of naïvely quantizing weights, these approaches typically involve, e.g., quantization-aware fine-tuning [3]. In addition, for some methods, BNNs and quantized neural networks also reduce the precision of the computations and activations, leading to speedups during inference [2], [3]. These approaches typically start with a conventional pre-trained neural network and then convert it into a low-precision representation. BNNs are among the fastest approaches for efficient inference [2].\n\nWhile BNNs (with binary activations, e.g., XNOR-Net [22]) are converted into LGNs for inference on hardware (e.g., on FPGAs [23]), the resulting architectures are fundamentally different from directly trained logic gate networks. BNNs have weight matrices and require multiply-accumulate (MAC) operations to express matrix multiplications. Asymptotically, each MAC requires 8 logic gates while at the same time (with only 2 possible states of the weight) this leads to a smaller expressivity compared to a single learned logic gate (with 16 possible states). We include a technical discussion in the appendix. While it is disadvantageous for inference, for training, BNNs have the advantage of operating on a higher abstraction level, simplifying training and allowing for translation between conventional neural networks and BNNs. We remark that BNNs with binary input activations and binary weight quantization frequently do not use binary output activations [24], which means that only the multiplications within a matrix multiplication are binary, while the remainder of the respective architectures can require floating precision. In contrast to BNNs, differentiable LGNs are not parameterized via weight matrices but instead via the choices of logic gates at each node [7].\n\nSparse Neural Networks Sparse neural networks are networks that are not densely connected but instead have only selected connections between layers [4], [25], [26]. Conceptually, this means multiplying a weight matrix with a binary mask, setting a selection of weights to 0. Sparse nets can be utilized for efficient inference as the sparsity greatly reduces the number of floating-point operations that have to be executed. For an overview of sparse neural networks, we refer to Hoefler et al. [4].\n\nDue to the binary (i.e., two-input) nature of logic gates, logic gate networks are intrinsically sparse. Thus, LGNs can be seen as sparse networks; however, sparse neural networks are typically not LGNs and typically operate on real values instead of Boolean values. As differentiable LGNs use randomly initialized and fixed connections, it is perhaps important to mention that choosing randomly initialized and fixed connections has been shown to also work well for conventional sparse neural networks [5].\n\n# 5 Experiments\n\n# 5.1 CIFAR-10\n\nWe train five sizes of LogicTreeNets on the CIFAR-10 data set [9] using the AdamW optimizer [12], [33] with a batch size of 128 at a learning rate of 0.02. Additional training details and hyperparameters are in Appendix A.2. We report our main results in Table 1 and Figure 1. Our primary evaluation is with respect to the number of logic gates (bin. ops), which corresponds to the cost in hardware implementations and is proportional to transistor count chip area for ASICs or occupancy on FPGAs.\n\nComparing our model (M) with $3 . 0 8 { \\bf M }$ gates to the large TTNet model [17], we can observe that, while the accuracies are similar, our model requires only $1 . 6 \\%$ of the number of logic gates. Increasing the model size, our model (B) matches the accuracy of FINN [23], while requiring only $1 6 \\mathbf { M }$ gates compared to $9 0 1 ~ \\mathrm { { M } }$ gates, a $5 6 \\times$ reduction. Considering an even larger variant of our model (L) with $2 8 . 9 \\mathrm { M }$ gates, we achieve $8 4 . 9 9 \\%$ . The smallest baseline model that achieves comparable accuracy $( 8 4 . 9 5 \\% )$ is LUTNet [19], which requires $4 4 . 6 \\times$ as many logic gates. Finally, considering our largest model (G) with $6 1 \\textbf { M }$ logic\n\nTable 1: Main results for the CIFAR-10 experiments. Our LogicTreeNet models reduce the required numbers of logic gates by factors of $\\geq 2 9 \\times$ compared to the state-ofthe-art models. Our models are scaled to match accuracies.   \n\n<html><body><table><tr><td>Method</td><td>Acc.</td><td># Gates</td></tr><tr><td>DiffLogic Net (medium) [7] DiffLogic Net (largest) [7]</td><td>57.39% 62.14%</td><td>0.51M 5.12 M 0.57 M</td></tr><tr><td>Conv. TTNet (small) [17] Conv. TTNet (large) [17] FINN CNV [23] LUTNet [19] XNOR-Net [22] (NIN) [27]</td><td>50.10% 70.75% 80.10% 84.95% 86.28%</td><td>189M 901M 1290M 1780 M</td></tr><tr><td>RebNet (2 residuals) [28] BinaryNet[29] Zhao et al. [30] FBNA CNV[31] Hirtzlin et al. [32] LogicTreeNet-S</td><td>85.94% 88.60% 88.54% 88.61% 91． % 60.38%</td><td>2830M 4090M 4940M 5540M 87400M 0.40 M</td></tr><tr><td>LogicTreeNet-M LogicTreeNet-B LogicTreeNet-L LogicTreeNet-G</td><td>71.01% 80.17% 84.99% 86.29%</td><td>3.08M 16.0 M 28.9 M 61.0 M</td></tr></table></body></html>\n\ngates, we achieve $8 6 . 2 9 \\%$ test accuracy. We match the accuracy of the Network-in-Network [27] XNOR-Net [22], while this baseline requires $2 9 \\times$ as many gates. Indeed, all networks in the literature below 4 billion gates perform worse than our 61 million gate network.\n\nAfter covering the performance of the trained models, we demonstrate their applicability in hardware designs on a Xilinx FPGA as a proof-of-concept. On CIFAR-10 we limit the hardware development up to the base model (B) due to labor cost. In Table 2, we report the results. We can observe a very favorable FPGA timing trade-off compared to previous works. Indeed, using our model (B) we achieve $8 0 . 1 7 \\%$ accuracy, matching the accuracy of the FINN accelerator, but decreasing inference time from $4 5 . 6 ~ \\mu \\mathrm { s }$ to $2 4 ~ \\mathrm { n s }$ . In other words, our model achieves 41.6 million FPS, whereas the previously fastest FPGA model achieved 22 thousand FPS (even among all models with $\\geq 7 0 \\%$ ). Herein, the limitation preventing us from reaching around 500 million FPS is the transfer speed onto the FPGA. Here, the difference between the smaller models (S & M) and the larger model (B) is that (S & M) receive the input at 2 bit precision whereas (B) receives the input at 5 bit precision. We want to remark that substantially accelerated speeds or reduced power consumption could be achieved by manufacturing custom hardware such as ASICs; however, this lies out of the scope of this work and is an interesting future research direction.\n\nTable 2: Timing results for CIFAR-10. The time is per image on an FPGA. We use a Xilinx VU13P FPGA. Our times are bottleneck by the data transfer onto the FPGA. ‘A’ indicates the use of an ASIC.   \n\n<html><body><table><tr><td>Method</td><td>Acc.</td><td>FPGA t.</td></tr><tr><td>FINN CNV [23]</td><td>80.10%</td><td>45.6 μs</td></tr><tr><td>RebNet(1residual) [28]</td><td>80.59%</td><td>167 μs</td></tr><tr><td>RebNet(2 residuals) [28] Zhao et al. [30]</td><td>85.94%</td><td>333 μs</td></tr><tr><td>FBNACNV[31]</td><td>88.54% 88.61%</td><td>5.94 ms 1.92 ms</td></tr><tr><td>FracBNN[34]</td><td>89.10%</td><td>356 μs</td></tr><tr><td>TrueNorth[35]</td><td>83.41%</td><td>A: 801μs</td></tr><tr><td>LogicTreeNet-S</td><td>60.38%</td><td>9 ns</td></tr><tr><td>LogicTreeNet-M</td><td>71.01%</td><td>9 ns</td></tr><tr><td>LogicTreeNet-B</td><td>80.17%</td><td>24 ns</td></tr></table></body></html>\n\nWe remark that all accuracies reported in the main paper are from discretized LGNs, and all gate counts maintain the full convolutional character (no location-based simplifications, e.g., at zeropadding). In Appendix A.4, we include a plot comparing the differentiable training mode accuracy to the discretized inference mode accuracy. Further, we refer to Figure 1 for a comparison of LogicTreeNet compared to the pareto-front of the state-of-the-art.\n\n# 5.2 MNIST\n\nWe continue our evaluation on MNIST [8]. Here, we use a slightly smaller model architecture with only 3 (instead of 4) convolutional blocks due to the input size of $2 8 \\times 2 8$ . Each convolutional block has a depth of 3 and, to maintain valid shapes, we use no padding in the first convolutional block. Each block increases the number of channels by a factor of 3. This network architecture is described in greater detail in Appendix A.1.2.\n\nWe display the results for MNIST in Table 3. Here, our models achieves a range of new SOTAs: compared to FINN [23], we can observe that our small model already improves the accuracy while simultaneously decreasing the model size by a factor of $3 6 \\times$ , and reducing inference time by a factor of 160. Our medium\n\nTable 3: Results of the MNIST experiment. We use a Xilinx XC7Z045 FPGA, the same device as FINN CNV. All other baselines utilize equivalent or more powerful FPGAs.   \n\n<html><body><table><tr><td>Method</td><td>Acc.</td><td># Gates</td><td>FPGA t.</td></tr><tr><td>DiffLogic Net (small) [7] DiffLogic Net (largest)[7] DWN[20]</td><td>97.69% 98.47% 98.77% 97.23%</td><td>48K 384K 46K</td><td>45 ns</td></tr><tr><td>TTNet (small) [17] TTNet [17] LUTNet[19] FINN CNV [23] FINN FCN[23] LowBitNN[36]</td><td>98.02% 98.01% 98.40% 98.86% 99.2 %</td><td>360K 5.28M 258M</td><td>5 ns 641 ns 152 μs</td></tr><tr><td>FPGA-NHAP[37] LogicTreeNet-S</td><td>97.81% 98.46%</td><td>147 K</td><td>4.9 ms 4 ns</td></tr><tr><td>LogicTreeNet-M LogicTreeNet-L</td><td>99.23% 99.35%</td><td>566 K 1.27 M</td><td>5 ns</td></tr></table></body></html>\n\nmodel, with $9 9 . 2 3 \\%$ test accuracy improves over all BNNs in the literature. When comparing to LowBitNN [36], a non-binary model, our medium model reduces the inference time by a factor of $3 0 0 0 0 \\times$ while still improving accuracy, increasing throughput from $6 6 0 0 \\mathrm { F P S }$ to 200 000 FPS.\n\nWithin the, “one-classification-per-cycle” regime, comparing to LUTNet [19], we decrease the error from $1 . 9 9 \\%$ to $0 . 7 7 \\%$ , and we note that the larger FPGA that LUTNet uses should enable placing LogicTreeNet-L $( 0 . 6 5 \\%$ error) multiple times, enabling multiple classifications per cycle.\n\nConcluding, our MNIST models are both the most efficient models in the $\\geq 9 8 \\%$ regime and at the same time also the highest accuracy models with an accuracy of up to $9 9 . 3 5 \\%$ .\n\nVariances For small models like the small (S) model for MNIST, which has only 16 kernels in the first layer, variance due to the fixed connectivity can become a significant concern. Thus, for the small models we train multiple models simultaneously, and use a validation set of $1 0 0 0 0$ images that we hold-out from the training set (not the test set), and based on which we select the final models. We present the variations before this selection between individual model in Table 4. We can see that with increasing model size, the variance decreases.\n\nTable 4: Variances between individual models on MNIST.   \n\n<html><body><table><tr><td>Model</td><td>Individual accs.</td></tr><tr><td>S</td><td>98.21% ±0.31%</td></tr><tr><td>M</td><td>99.13% ±0.11%</td></tr><tr><td>L</td><td>99.29% ±0.06%</td></tr></table></body></html>\n\n# 5.3 Ablation Study\n\nTo demonstrate the importance of the provided architectural choices, we provide an ablation study in Table 5. Here, we observe that using trees, residual initializations, as well as or pooling are integral to the performance of convolutional LGNs. We also provide an ablation wrt. model depth.\n\nTable 5: Ablation study on CIFAR-10 wrt. architectural choices.   \n\n<html><body><table><tr><td></td><td></td><td>se#</td><td>sIo#</td><td>[0od-10</td><td></td><td></td><td>sendur</td></tr><tr><td>Method LogicTreeNet-L</td><td>Accuracy 84.99%</td><td>15</td><td>23</td><td></td><td>?</td><td>?</td><td>?</td></tr><tr><td>Conv. d: 1,1,1,1</td><td>80.98%</td><td>7</td><td>15</td><td>√</td><td></td><td></td><td></td></tr><tr><td>Conv. d: 1,1,2,2</td><td>82.68%</td><td>9</td><td>17</td><td></td><td></td><td></td><td></td></tr><tr><td>Conv. d: 2,2,2,2</td><td>83.32%</td><td>11</td><td>19</td><td></td><td></td><td></td><td></td></tr><tr><td>Conv. d: 2,2,3,3</td><td>84.13%</td><td>13</td><td>21</td><td>?</td><td></td><td></td><td></td></tr><tr><td>No or pooling</td><td>81.45%</td><td>15</td><td>15</td><td>×</td><td></td><td></td><td></td></tr><tr><td>Gaussian init.</td><td>76.18%</td><td>15</td><td>23</td><td></td><td>×</td><td></td><td></td></tr><tr><td>No weight decay</td><td>83.94%</td><td>15</td><td>23</td><td></td><td></td><td>×</td><td></td></tr><tr><td>8 input channels</td><td>83.53%</td><td>15</td><td>23</td><td>?</td><td></td><td></td><td>×</td></tr></table></body></html>\n\nStarting with the model depth ablation, in Table 5, we can observe that the performance improves with increasing model depth. We observe that decreasing the model depth is detrimental to performance. We note that shallower\n\nmodels do not directly correspond to reductions in gate counts because, for deeper models, the rates of trivial gate choices like $\\dot { \\cdot } A ^ { \\cdot }$ that are removed during logic synthesis is significantly higher.\n\nNext, we consider the omission of or pooling. We can observe that the accuracy drops by $3 . 5 \\%$ when removing or pooling, demonstrating its importance. Setting weight decay to 0 causes a small reduction in accuracy by $1 \\%$ . Allowing each tree to use 8 channels as the input, rather than just 2, reduces the accuracy $( 1 . 4 \\% )$ because it is better to enforce the ability to perform comparisons within one channel at different $x , y$ locations in the kernel. However, the more important effect of using only 2 input channels is the resulting improved routing in hardware design layouts.\n\n90% 80%   \nA 70%   \nt 60% Residual init. Gaussian init. 50% 0 100 200 300 400 500 600 700 Epochs\n\nFinally, we ablate the proposed residual initializations. We can observe in the table that the accuracy drops by almost $9 \\%$ without residual initializations. This means the that the Gaussian initialization are almost unusable for such deep networks. In Figure 7, we display the test accuracy during training and observe that, without our residual initializations, training does not converge and is quite unstable.\n\nWe further ablate the effect of residual initialization on the distribution of gates in Figure 8. Here, we can observe that residual initializations not only stabilize training, but also lead to the favorable inductive bias of many gates being the $\\cdot _ { A } \\cdot$ , which is automatically reduced during logic simplification.\n\nGaussian Initialization 0.20 Residual Initialization 0.8   \n0 0.15 0 0.6   \n1 1 0.10 0.4   \n2 2   \n3 0.05 3 0.2 0 A8 B A B B B A B B 1 0.00 0 B B A B B B B B 2 AB 1 0.0 A A A 1A A A A\n\n# 6 Conclusion\n\nIn this paper, we introduced convolutional differentiable logic gate networks with logic gate tree kernels, integrating a range of concepts from machine vision into differentiable logic gate networks. In particular, we introduced residual initializations, which not only reduces loss of information in deeper networks, but also prevents vanishing gradients, enabling training of deeper LGNs than previously possible. Further, we introduced logical or pooling, which, combined with logic tree kernels, substantially improved training efficiency. Our proposed CIFAR-10 architecture, LogicTreeNet, decreases model sizes by factors of $\\geq 2 9 \\times$ compared to the SOTA while improving accuracy. Further, our inference stack demonstrates that convolutional LGNs can be efficiently executed on hardware. For example, on MNIST, our model improves accuracy while achieving $1 6 0 \\times$ faster inference speed, and on CIFAR-10, our model improves inference speed by $1 9 0 0 \\times$ over the state-of-the-art. An interesting direction for future research is applying convolutional differentiable logic gate networks to computer vision tasks with continuous decisions like object localization. We hope that our results motivate the community to adopt convolutional differentiable LGNs, especially for embedded and real-time applications where inference cost and speed matter most.",
    "summary": "{\n    \"core_summary\": \"### 核心概要\\n\\n**问题定义**\\n深度学习在机器视觉领域的发展带来了新的应用和机遇，但推理过程伴随着巨大的计算和能量成本。现有的可微分逻辑门网络（LGNs）在处理图像时存在局限性，随机连接方式使其难以学习空间关系，且网络深度受限，训练成本高，在CIFAR - 10数据集上的准确率仅为62%。解决这些问题对于实现高效的机器学习推理至关重要，随着机器学习模型推理成本的增加，开发快速高效推理的模型具有重要的学术和工业价值。\\n\\n**方法概述**\\n论文提出了卷积可微分逻辑门网络，引入了深度逻辑门树卷积、逻辑或池化和残差初始化等技术，以扩展可微分LGNs至卷积，从而提高模型性能和训练效率。同时，针对不同规模的CIFAR - 10模型采用不同的输入处理方式，小模型用2位精度输入并以3个阈值编码，大模型用5位精度输入并经低 - 级特征探测器处理。\\n\\n**主要贡献与效果**\\n- 提出深度逻辑门树卷积，允许卷积激活与可微分二进制逻辑门树进行卷积，提高了模型的表达能力，在CIFAR - 10数据集上，使用仅6100万个逻辑门实现了86.29%的准确率，相较于SOTA模型，模型规模缩小了29倍以上。\\n- 引入逻辑或池化，通过最大t - 余模松弛逻辑或，提高了卷积在LGNs中的有效性，减少了计算量和内存访问，使训练速度更快，还能自动减少预池化激活，避免激活饱和问题。\\n- 提出残差初始化方案，解决了现有可微分LGNs中梯度消失和信息丢失的问题，使训练更深的网络成为可能，在MNIST数据集上，模型提高了准确率，同时推理速度比现有技术快160倍。在CIFAR - 10数据集上，LogicTreeNet - B模型在FPGA上推理时间从FINN的45.6μs降至24ns，达到41.6百万FPS。\",\n    \"algorithm_details\": \"### 算法/方案详解\\n\\n**核心思想**\\n该方法的核心思想是将卷积神经网络的思想引入到可微分逻辑门网络中，通过使用逻辑门树作为卷积核，提高模型的表达能力，同时利用逻辑或池化和残差初始化来提高训练和推理效率。逻辑门树卷积允许模型学习空间模式，逻辑或池化通过最大t - 合取范数松弛逻辑或操作，减少计算量和内存占用，残差初始化通过设置特定的逻辑门选择概率，防止信息丢失和梯度消失。逻辑门树可以捕捉固定的空间模式和相关性，逻辑或池化减少了计算和内存需求，残差初始化防止了信息丢失和梯度消失。此外，对输入处理采用不同策略以适配不同规模模型。\\n\\n**创新点**\\n先前的可微分LGNs存在随机连接、无法学习空间关系、深度受限和训练成本高的问题。与先前的工作相比，本文的方法进行了以下创新：引入了深度逻辑门树卷积，使模型能够学习空间模式；提出了逻辑或池化，提高了计算效率；引入了残差初始化，解决了深度网络中的信息丢失和梯度消失问题；针对不同规模CIFAR - 10模型采用不同输入处理方式。\\n\\n**具体实现步骤**\\n1. **构建逻辑门树卷积核**：将逻辑门树作为卷积核，随机构建连接，并对连接施加额外限制，使其成为深度为d的完全二叉树，叶子节点为二进制输入激活。从预定义的感受野中选择输入，例如构建深度为d的完整二叉树逻辑门树，随机选择$2^d$个输入。在训练过程中，网络学习每个节点的逻辑门操作。每个逻辑树核由$2^d - 1$个可学习的逻辑门参数化。\\n2. **逻辑或池化**：使用最大t - 余模松弛逻辑或，设置池化操作的步长等于其感受野大小，以提高计算效率和减少内存需求。通过最大t - 合取范数松弛逻辑或操作，减少计算量和内存占用。训练时能自动减少预池化激活，避免激活饱和。\\n3. **残差初始化**：将逻辑门的参数$\\mathbf{z}$初始化为使逻辑门选择为前馈逻辑门的概率约为90%，其他逻辑门概率为0.67%，对应设置$z_3 = 5$，其他$z_i = 0$（$i \\neq 3$），防止信息丢失和梯度消失。\\n4. **输入处理**：对于较小的CIFAR - 10模型（S, M），使用2位精度输入，并用3个阈值编码；对于较大的CIFAR - 10模型（B, L, G），使用5位精度输入，经边缘和曲率探测器等低 - 级特征探测器处理，转换为二进制编码。\\n5. **训练模型**：使用AdamW优化器，设置批量大小为128，学习率为0.02，训练LogicTreeNet模型。\\n\\n关键公式：\\n- 逻辑门的可微分松弛：如逻辑与 $( a _ { 1 } \\land a _ { 2 } )$ 松弛为 $a _ { 1 } \\cdot a _ { 2 }$ ，逻辑异或 $( a _ { 1 } \\oplus a _ { 2 } )$ 松弛为 $a _ { 1 } + a _ { 2 } - 2 \\cdot a _ { 1 } \\cdot a _ { 2 }$ 。\\n- 可微分逻辑门的计算：$f _ { \\mathbf { z } } ( a _ { 1 } , a _ { 2 } ) = \\sum _ { i = 0 } ^ { 1 5 } \\frac { \\exp ( z _ { i } ) } { \\sum _ { j } \\exp ( z _ { j } ) } \\cdot g _ { i } ( a _ { 1 } , a _ { 2 } )$ 。\\n- 逻辑树卷积核的输出计算：$\\mathbf { A } ^ { \\prime } [ k , i , j ]$ 的计算公式（论文中的公式3）。\\n\\n**案例解析**\\n在逻辑或池化部分，论文给出了一个关于卷积块激活密度的案例。对于一个采用$2×2$步长或池化的逻辑网络卷积块，随机无池化网络平均激活预期为50%，初始化模型的或池化后激活为66.5%，或池化前激活初始化为50%。训练时，或池化后激活迅速收敛到无池化网络的平均激活，避免了激活饱和问题。\",\n    \"comparative_analysis\": \"### 对比实验分析\\n\\n**基线模型**\\n在CIFAR - 10数据集上的基线模型包括TTNet、FINN、LUTNet、XNOR - Net、RebNet、BinaryNet、Zhao et al.、FBNA CNV、Hirtzlin et al.等；在MNIST数据集上的基线模型包括TTNet、LUTNet、FINN、LowBitNN、DWN、FPGA - NHAP等。\\n\\n**性能对比**\\n*   **在 [准确率/Accuracy] 指标上**：在CIFAR - 10数据集上，LogicTreeNet - G模型取得了86.29%的准确率，与XNOR - Net相当，但所需的逻辑门数量仅为其1/29；LogicTreeNet - L模型达到了84.99%的准确率，而最小达到可比准确率的基线模型LUTNet所需逻辑门数量是其44.6倍；LogicTreeNet - B模型准确率为80.17%，与FINN相当，但逻辑门数量仅为其1/56。在MNIST数据集上，LogicTreeNet - L模型达到了99.35%的准确率，高于FINN CNV的98.86%；LogicTreeNet - M模型达到了99.23%的准确率，优于所有文献中的二值神经网络。\\n*   **在 [逻辑门数量/Logic Gates] 指标上**：在CIFAR - 10数据集上，LogicTreeNet - M模型仅有308万个逻辑门，而大的TTNet模型需要1.89亿个逻辑门，LogicTreeNet - M所需逻辑门数量仅为其1.6%。在MNIST数据集上，LogicTreeNet - S模型逻辑门数量为14.7万个，远低于TTNet的36万个。\\n*   **在 [推理时间/Inference Time] 指标上**：在CIFAR - 10数据集上，LogicTreeNet - B模型在FPGA上的推理时间为24ns，而FINN加速器为45.6μs，LogicTreeNet - B的推理时间显著降低，达到41.6百万FPS，而先前最快的FPGA模型仅22千FPS。在MNIST数据集上，LogicTreeNet - S模型推理时间为4ns，远低于FINN CNV的152μs；LogicTreeNet - M模型与LowBitNN相比，推理时间降低了30000倍，同时提高了准确率。\",\n    \"keywords\": \"### 关键词\\n\\n- 卷积可微分逻辑门网络 (Convolutional Differentiable Logic Gate Networks, CDLGN)\\n- 逻辑门树卷积 (Logic Gate Tree Convolution, LGTC)\\n- 逻辑或池化 (Logical Or Pooling, LOP)\\n- 残差初始化 (Residual Initialization, RI)\\n- 机器学习推理 (Machine Learning Inference, MLI)\\n- 图像分类 (Image Classification, IC)\\n- CIFAR - 10 (CIFAR - 10, N/A)\\n- MNIST (MNIST, N/A)\"\n}"
}