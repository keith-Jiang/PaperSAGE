{
    "link": "https://arxiv.org/abs/2408.09591",
    "pdf_link": "https://arxiv.org/pdf/2408.09591",
    "title": "Pre-assignment problem for unique minimum vertex cover on bounded clique-width graphs",
    "authors": [
        "Shinwoo An",
        "Yeonsu Chang",
        "Kyungjin Cho",
        "O.-joung Kwon",
        "Myounghwan Lee",
        "Eunjin Oh",
        "Hyeonjun Shin"
    ],
    "publication_date": "2024-08-18",
    "venue": "AAAI Conference on Artificial Intelligence",
    "fields_of_study": [
        "Computer Science"
    ],
    "citation_count": 1,
    "influential_citation_count": 0,
    "paper_content": "# Pre-Assignment Problem for Unique Minimum Vertex Cover on Bounded Clique-Width Graphs\n\nShinwoo $\\mathbf { A } \\mathbf { n } ^ { 1 }$ , Yeonsu Chang2, Kyungjin Cho1, O-joung Kwon2,3\\*, Myounghwan Lee2, Eunjin $\\mathbf { O h } ^ { 1 }$ Hyeonjun Shin1\n\n1 Department of Computer Science and Engineering, POSTECH, Pohang, South Korea 2 Department of Mathematics, Hanyang University, Seoul, South Korea 3 Discrete Mathematics Group, Institute for Basic Science (IBS), Daejeon, South Korea shinwooan $@$ postech.ac.kr, yeonsu $@$ hanyang.ac.kr, kyungjincho $@$ postech.ac.kr, {ojoungkwon, sycuel}@hanyang.ac.kr, {eunjin.oh, tlsguswns119} $@$ postech.ac.kr\n\n# Abstract\n\nHoriyama et al. (AAAI 2024) considered the problem of generating instances with a unique minimum vertex cover under certain conditions. The PRE-ASSIGNMENT FOR UNIQUIFICATION OF MINIMUM VERTEX COVER problem (shortly PAU-VC) is the problem, for given a graph $G$ , to find a minimum set $S$ of vertices in $G$ such that there is a unique minimum vertex cover of $G$ containing $S$ . We show that PAU-VC is fixed-parameter tractable parameterized by clique-width, which improves an exponential algorithm for trees given by Horiyama et al. Among natural graph classes with unbounded clique-width, we show that the problem can be solved in polynomial time on split graphs and unit interval graphs.\n\n# Introduction\n\nDesigning AI algorithms to tackle NP-hard graph problems has become a prominent trend in the field of artificial intelligence. The inherent complexity of NP-complete problems presents a significant challenge, making them an ideal testbed for AI-driven approaches that aim to push the boundaries of what can be achieved in terms of efficiency and scalability. To evaluate the performance of those AI algorithms, it is essential to have robust benchmark datasets. Such datasets provide a controlled environment where the strengths and weaknesses of different algorithms can be systematically analyzed. As constructing a benchmark dataset is a critical aspect of AI research, several well-known benchmark datasets were presented such as TSPLIB, UCI, SATLIB, and DIMACS for various NP-hard combinatorial problems (Reinelt 1991; Asuncion, Newman et al. 2007; Hoos and Stützle 2000).\n\nHowever, it seems hard to use them to evaluate the performances of AI algorithms for the uniqueness version of combinatorial problems where a solution is unique. In several problems, the presence of a unique solution can lead to more efficient algorithms (Thomason 1978; Gabow, Kaplan, and Tarjan 1999). Also, algorithms for the unique SAT problem are used as subroutines for its search version (Scheder and Steinberger 2017; Hertli 2014a). Due to these reasons, the uniqueness version also has been extensively studied from both theory and practice (Calabro et al. 2008; Hertli 2014b).\n\nTherefore, generating graphs with a unique solution offers a valuable addition to benchmark datasets, enabling a more thorough evaluation of AI-driven solvers for the uniqueness version of combinatorial problems.\n\nOne natural approach for generating graphs with a unique solution is to make use of graphs in well-known benchmark datasets. More specifically, we choose a graph $G$ in a wellknown benchmark dataset, and pre-assign a part of $G$ so that only one solution is consistent with this assignment. This pre-assignment for uniquification has been studied for classic NP-hard problems such as the coloring and clique problems (Harary, Slany, and Verbitsky 2007), the dominating set problem and its variants (Chartrand et al. 1997; Bozeman et al. 2019; Ferrero et al. 2018) and the vertex cover problem (Horiyama et al. 2024). Also, several pencil/video puzzles such as SUDOKU and Picross 3D have been studied in the context of the pre-assignment for uniquification (Demaine et al. 2018; Kimura, Kamehashi, and Fujito 2018; Tjusila et al. 2024).\n\nIn this paper, we focus on the PRE-ASSIGNMENT FOR UNIQUIFICATION OF MINIMUM VERTEX COVER (PAUVC) problem introduced by (Horiyama et al. 2024). A set $S$ of vertices in a graph $G$ is called a vertex cover of $G$ if $S$ meets all edges of $G$ . The goal of this problem is to compute a minimum-cardinality vertex cover of a given graph. In the unique vertex cover problem, it is assured that an input graph has a unique minimum vertex cover. The formal definition of PAU-VC is the following.\n\nPAU-VC   \nInput : A graph $G$   \nQuestion : Find a minimum set $S \\subseteq V ( G )$ such that there is a unique minimum vertex cover of $G$ containing $S$ .\n\nNotice that one can use an algorithm for PAU-VC to generate a graph with a unique solution for the vertex cover problem. Consider an arbitrary graph $G$ (possibly from a known benchmark dataset), and compute an optimal solution $S$ for PAU-VC on $G$ . Since there is a unique minimum vertex cover of $G$ containing $S$ , $G - S$ has a unique minimum vertex cover as well, where $G - S$ is the graph obtained from $G$ by removing all vertices of $S$ and their incident edges.\n\nAlthough the pre-assignment for uniquification of the dominating set problem and its variants has been studied extensively, little is known about PAU-VC, except for (Horiyama et al. 2024). More specifically, (Horiyama et al. 2024) proved that PAU-VC is $\\bar { \\Sigma _ { 2 } ^ { P } }$ -complete on general graphs, and NPcomplete on bipartite graphs. On the positive side, they provided an algorithm that runs in time $\\mathcal { O } ( 2 . 1 9 9 6 ^ { n } )$ for general graphs, an algorithm that runs in time $\\mathcal { O } ( 1 . 9 1 8 1 ^ { n } )$ for bipartite graphs, and an algorithm that runs in time $\\mathcal { O } ( 1 . 4 1 4 3 ^ { n } )$ for trees, where $n$ denotes the number of vertices.\n\nAs PAU-VC is $\\Sigma _ { 2 } ^ { P }$ -complete and NP-complete for general graphs and bipartite graphs, respectively, it is unlikely to admit polynomial-time algorithms for either general or bipartite graphs. However, the time complexity for trees remains an open question. In fact, (Horiyama et al. 2024) also mentioned this explicitly: “Many readers might consider that PAUVC for trees is likely solvable in polynomial time. On the other hand, not a few problems are intractable (e.g., NODE KAYLES) in general, but the time complexity for trees still remains open, and only exponential-time algorithms are known. In the case of PAU-VC, no polynomial-time algorithm for trees is currently known.”\n\nOur results. In this paper, we resolve this open problem by presenting a polynomial-time algorithm for PAU-VC on trees, which significantly improves the exponential-time algorithm by Horiyama et al. Moreover, we showed that it can be extended to classes of bounded clique-width. Clique-width is a graph parameter that measures the complexity of constructing a graph using a set of specific operations, including the creation of new vertices, disjoint union of graphs, relabeling of vertex labels, and connecting vertices based on their labels. Trees have clique-width at most 3 (Courcelle and Olariu 2000) and complete graphs have clique-width at most 2. A precise definition will be given in the clique-width section.\n\nMore precisely, we prove the following theorem. We say a problem is fixed-parameter tractable with parameter $k$ if it can be solved in time $f ( k ) n ^ { \\mathcal { O } ( 1 ) }$ , where $n$ denotes the input size and $f ( \\cdot )$ is a computable function.\n\n# Theorem 1. PAU-VC is fixed-parameter tractable parameterized by clique-width.\n\nOne may ask whether we can further obtain polynomialtime algorithms for PAU-VC on natural classes of graphs of unbounded clique-width. We investigate two such classes. Split graphs are graphs that can be partitioned into an independent set and a clique. Unit interval graphs are intersection graphs of intervals of the same length on the real line. It is known that split graphs have unbounded cliquewidth (Makowsky and Rotics 1999) and unit interval graphs have unbounded clique-width (Golumbic and Rotics 2000). Split graphs and unit interval graphs are well-known graph classes that have been widely studied (Corneil et al. 1995; Hell, Shamir, and Sharan 2001; Bertossi 1984). We prove that PAU-VC can be solved in linear time on both classes.\n\nTheorem 2. PAU-VC can be solved in linear time on unit interval graphs and split graphs.\n\nNote that the class of split graphs and the class of unit interval graphs are well-known subclasses of the class of chordal graphs. It would be interesting to determine whether PAUVC can be solved in polynomial time on chordal graphs.\n\nProofs of statements marked with $^ { 6 6 } ( * ) ^ { 3 }$ are deferred to the appendix.\n\nBrief introduction on clique-width. The notion of cliquewidth is closely related to the concept of tree-width. Treewidth is a well-studied graph parameter which measures how close a graph is to being a tree (Robertson and Seymour 2004). (Courcelle 1990) showed that every problem expressible in $\\mathbf { M S O } _ { 2 }$ -logic is fixed-parameter tractable when parameterized by the tree-width of a graph. However, classes of bounded tree-width must be sparse. To address this limitation, (Courcelle and Olariu 2000) introduced clique-width to extend properties of classes of bounded tree-width to dense graph classes, such as the class of complete graphs.\n\nEvery class of bounded tree-width has bounded cliquewidth (Courcelle and Olariu 2000; Corneil and Rotics 2005), but there are classes of bounded clique-width and unbounded tree-width, such as the class of complete graphs or complete bipartite graphs. (Courcelle, Makowsky, and Rotics 2000) showed that every problem expressible in $\\mathbf { M S O } _ { 1 }$ -logic is fixed-parameter tractable when parameterized by the cliquewidth of a graph. It is not difficult to see that PAU-VC cannot be expressible in $\\mathbf { M S O } _ { 1 }$ -logic, as we cannot represent the property that a set is a unique minimum vertex cover. So, the algorithmic meta theorem by Courcelle, Makowsky, and Rotics cannot be adapted for PAU-VC. The parameterized complexity of problems cannot be expressible by $\\mathbf { M S O } _ { 1 }$ - logic, such as HAMILTONAIN CYCLE and Graph Coloring, have been studied (Kobler and Rotics 2003; Fomin et al. 2010, 2014, 2019; Bergougnoux, Kanté, and Kwon 2020).\n\n# Preliminary\n\nFor every positive integer $n$ , let $[ n ]$ denote the set of positive integers at most $n$ . All graphs in this paper are simple and finite. For a graph $G$ we denote by $V ( G )$ and $E ( G )$ the vertex set and edge set of $G$ , respectively. For graphs $G$ and $H$ , let $G \\cup H$ be the graph with vertex set $V ( G ) \\cup V ( H )$ and edge set $E ( G ) \\cup E ( H )$ .\n\nLet $G$ be a graph. For a vertex $v$ of a graph $G$ , let $N _ { G } ( v )$ denote the set of neighbors of $v$ in $G$ . For $X \\subseteq V ( G )$ , let $G [ X ]$ denote the subgraph of $G$ induced by $X$ . We denote by $G - X$ the graph $G [ V ( G ) \\backslash X ]$ , and for a single vertex $x \\in V ( G )$ , we use the shorthand $\\mathbf { \\epsilon } \\cdot \\boldsymbol { G } - \\boldsymbol { x } ^ { \\prime }$ for $\\mathbf { \\hat { G } } - \\{ x \\} ^ { , }$ For two sets $X , Y \\subseteq V ( G )$ , let $G [ X , Y ]$ be the graph $X \\cup$ $Y , \\{ x y \\in E ( G ) : x \\in X , y \\in Y \\}$ ).\n\nA set $X \\subseteq V ( G )$ is a clique if any two vertices of $X$ are adjacent in $G$ , and it is an independent set if any two vertices of $X$ are not adjacent in $G$ .\n\n# Trees\n\nBefore diving into our main theorems, we present an idea for having a simpler polynomial time algorithm for PAU-VC on trees. Recall that this significantly improves the best-known algorithm for this problem (Horiyama et al. 2024), which runs in exponential time. Let $G$ be a tree. We choose an arbitrary vertex as the root of $G$ . For each node $v \\in V ( G )$ , we use $G _ { v }$ to denote the subtree of $G$ rooted at $v$ .\n\nFor each vertex $v$ , there are two types of vertex covers of $G _ { v }$ ; one is a vertex cover of $G _ { v }$ containing $v$ and the other is a vertex cover of $G _ { v }$ not containing $v$ . We want to find a set $S$ which forces the number of minimum vertex covers of each type to satisfy a certain condition. This naturally suggests the following definition. For a function $\\beta : \\{ 0 , 1 \\} \\stackrel { \\cdot } {  } \\{ \\bar { 0 , } 1 , 2 \\}$ , a set $S \\subseteq { \\bar { V } } ( G _ { v } )$ is a $\\beta$ -set in $G _ { v }$ if the following hold:\n\n• If $\\beta ( 0 ) \\in \\{ 0 , 1 \\}$ , then there is exactly $\\beta ( 0 )$ many minimum vertex covers of $G _ { v }$ not containing $v$ and containing $S$ .   \n• If $\\beta ( 0 ) = 2$ , then there are at least two minimum vertex covers of $G _ { v }$ not containing $v$ and containing $S$ .   \n• If $\\beta ( 1 ) \\in \\{ 0 , 1 \\}$ , then there is exactly $\\beta ( 1 )$ many minimum vertex covers of $G _ { v }$ containing $v$ and containing $S$ .   \n• If $\\beta ( 1 ) = 2$ , then there are at least two minimum vertex covers of $G _ { v }$ containing $\\boldsymbol { v }$ and containing $S$ .\n\nWe will recursively compute a minimum $\\beta$ -set in $G _ { v }$ for every possible function $\\beta$ and every vertex $v \\in V$ , if one exists.\n\nIt is not difficult to observe that if we have a minimum $\\beta$ - set of $G _ { r } = G$ for every possible function $\\beta$ , then we can find an optimal solution of PAU-VC. That would be a minimum set among minimum $\\beta$ -sets of $G _ { r }$ for which $\\beta ( 0 ) + \\beta ( 1 ) = 1 .$\n\nTherefore, it suffices to recursively compute a minimum $\\beta$ -set of $G _ { v }$ for every vertex $v \\in V$ . The idea is straightforward. We need to propagate the information to children of $v$ . Assume $\\beta : \\{ 0 , \\bar { 1 } \\} \\stackrel { - } {  } \\{ 0 , 1 , 2 \\}$ is a given function. For example, if $\\beta ( 0 ) = 1$ , then the $\\beta$ -set in $G _ { v }$ should force a unique minimum vertex cover of $G _ { v }$ not containing $v$ . Then for each child $w$ of $v$ , we have to determine a set forcing a unique minimum vertex cover of $G _ { w }$ that contains $w$ . This suggests how to split $\\beta$ into functions $\\beta _ { w }$ for each child $w$ , and we can find the corresponding $\\beta$ -set by taking the union of $\\beta _ { w }$ -sets for children $w$ of $v$ .\n\nThis idea is generalized into graphs of bounded cliquewidth in the next section. We will provide the dynamic programming algorithm and prove the correctness.\n\n# Graphs of Bounded Clique-width\n\nIn this section, we prove Theorem 1. Before we describe our strategy, we provide a formal definition of the clique-width and introduce some necessary notations. Let $k$ be a positive integer. A $k$ -labeled graph is a pair $( G , \\mathrm { l a b } _ { G } )$ of a graph $G$ and a function $\\operatorname { l a b } _ { G } : V ( G ) \\ { \\overset { } { \\to } } \\ [ k ]$ , called the labeling function. We denote by $\\mathrm { l a b } _ { G } ^ { - 1 } ( i )$ the set of vertices in $G$ with label $i$ .\n\n# Definitions of Clique-Width and NLC-Width\n\nWe first define the clique-width of graphs. For a $k$ -labeled graph $( G , \\mathrm { l a b } _ { G } )$ and $i , j \\in [ k ]$ with $i \\neq j$ , let $\\eta _ { i , j } ( G , \\mathrm { l a b } _ { G } )$ be the $k$ -labeled graph obtained from $( G , \\mathrm { l a b } _ { G } )$ by adding an edge between every vertex of label $i$ and every vertex of label $j$ , and let $\\rho _ { i \\to j } ( G , \\operatorname { l a b } _ { G } )$ be the $k$ -labeled graph obtained from $\\left( G , \\mathrm { l a b } _ { G } \\right)$ by relabeling every vertex of $i$ to $j$ . For two vertex-disjoint $k$ -labeled graphs $( G , \\mathrm { l a b } _ { G } )$ and $\\left( H , \\mathrm { l a b } _ { H } \\right)$ , let $( G , \\mathrm { l a b } _ { G } ) \\oplus ( H , \\mathrm { l a b } _ { H } )$ be the disjoint union of them.\n\nThe class $\\mathrm { C W } _ { k }$ of $k$ -labeled graphs is recursively defined as follows. (1) The single vertex graph $i ( x )$ , with a vertex $x$ labeled with $i \\in [ k ]$ , is in $\\mathrm { C W } _ { k }$ . (2) Let $( G , \\mathrm { l a b } _ { G } )$ and $\\left( H , \\mathrm { l a b } _ { H } \\right)$ be two vertex-disjoint $k$ -labeled graphs in $\\mathrm { C W } _ { k }$ . Then $( G , \\mathrm { l a b } _ { G } ) \\oplus ( H , \\mathrm { l a b } _ { H } ) \\in \\mathrm { C W } _ { k }$ . (3) Let $( G , \\operatorname { l a b } _ { G } ) \\in$ $\\mathrm { C W } _ { k }$ and $i , j \\in [ k ]$ with $i \\neq j$ . Then $\\eta _ { i , j } ( G , \\mathrm { l a b } _ { G } ) ~ \\in$ $\\mathrm { C W } _ { k }$ . (4) Let $( G , \\bar { \\mathrm { l a b } } _ { G } ) ~ \\in ~ \\mathrm { C W } _ { k }$ and $i , j ~ \\in ~ [ k ]$ . Then $\\rho _ { i \\to j } ( G , \\mathrm { l a b } _ { G } ) \\in \\mathrm { C W } _ { k }$ . A clique-width $k$ -expression is a finite term built with the four operations above and using at most $k$ labels. The clique-width of a graph, denoted by $\\operatorname { c w } ( G )$ , is the minimum $k$ such that $( G , \\mathrm { l a b } _ { G } ) \\in \\mathrm { C W } _ { k }$ for some labeling $\\operatorname { l a b } _ { G }$ .\n\n![](images/9edea296496f7b29cfda6d72aa1e4b64b787859a63ffa55f47d6040de70c2869.jpg)  \nFigure 1: Illustration of a clique-width 3-expression of $P _ { 4 }$\n\nFor example,\n\n$$\n\\eta _ { 2 , 3 } { \\Big ( } \\eta _ { 1 , 2 } ( 1 ( a ) \\oplus 2 ( b ) ) \\oplus \\eta _ { 1 , 3 } ( 3 ( c ) \\oplus 1 ( d ) ) ) { \\Big ) }\n$$\n\nis a clique-width 3-expression of a path $P _ { 4 }$ on 4 vertices. See Figure 1. Thus, $P _ { 4 }$ has clique-width at most 3.\n\nNow, we define the NLC-width of graphs introduced by (Wanke 1994). (Johansson 1998) showed that every graph of clique-width at most $k$ has NLC-width at most $k$ , and one can in polynomial time transform an expression for clique-width to an expression for NLC-width. For two vertexdisjoint $k$ -labeled graphs $( G , \\mathrm { l a b } _ { G } )$ and $\\left( H , \\mathrm { l a b } _ { H } \\right)$ and a set $M \\subseteq [ k ] ^ { 2 }$ of label pairs, we define $( G , \\mathrm { l a b } _ { G } ) \\ \\times _ { M }$ $( H , \\mathrm { l a b } _ { H } ) \\mathrel { \\mathop : } = \\mathsf { \\bar { ( } } ( V ^ { \\prime } , E ^ { \\prime } ) , \\mathrm { l a b } ^ { \\prime } )$ where\n\n• $V ^ { \\prime } = V ( G ) \\cup V ( H ) .$ ,   \n$\\begin{array} { r c l } { \\bullet \\ { \\cdot } } & { { \\cal E } ^ { \\prime } ~ = ~ { \\cal E } ( G ) ~ \\cup ~ { \\cal E } ( H ) ~ \\cup ~ \\{ u v ~ : } ~ u ~ \\in ~ V ( G ) , v ~ \\in  \\\\ { ~ } & { } & { V ( H ) , ( \\mathrm { l a b } _ { G } ( u ) , \\mathrm { l a b } _ { H } ( v ) ) \\in { \\cal M } \\} , } \\\\ { ~ } & { } & { \\bullet \\ \\mathrm { l a b } ^ { \\prime } ( u ) = \\mathrm { l a b } _ { G } ( u ) \\ \\mathrm { i f } ~ u \\in V ( G ) \\ \\mathrm { a n d } \\ \\mathrm { l a b } ^ { \\prime } ( u ) = \\mathrm { l a b } _ { H } ( u ) } \\end{array}$ otherwise.\n\nIn other words, $( G , \\mathrm { l a b } _ { G } ) \\times _ { M } ( H , \\mathrm { l a b } _ { H } )$ is obtained from the disjoint union of $\\left( G , \\mathrm { l a b } _ { G } \\right)$ and $\\left( H , \\mathrm { l a b } _ { H } \\right)$ by, for every $( i , j ) \\in M$ , adding all edges between vertices of label $i$ in $G$ and vertices of label $j$ in $H$ . For a $k$ -labeled graph $( G , \\mathrm { l a b } _ { G } )$ and a function $R : [ k ] \\to [ k ]$ , let $\\rho _ { R } ( G , \\mathrm { l a b } _ { G } ) = ( G , \\mathrm { l a b } ^ { \\prime } )$ where $\\mathrm { l a b ^ { \\prime } } ( u ) = R ( \\bar { \\mathrm { l a b } } _ { G } ( \\bar { u } ) ) \\bar $ for all $u \\in V ( G )$ .\n\nThe class $\\mathrm { N L C } _ { k }$ of $k$ -labeled graphs is recursively defined as follows. (1) The single vertex graph $i ( x )$ , with a vertex $x$ labeled with $\\textit { i } \\in \\ [ k ]$ , is in $\\mathrm { N L C } _ { k }$ . (2) Let $( G , \\mathrm { l a b } _ { G } ) \\in \\mathrm { N L C } _ { k }$ and $R : [ k ] \\to [ k ]$ be a function. Then $\\rho _ { R } ( G , \\mathrm { l a b } ) \\in \\mathrm { N L C } _ { k }$ . (3) Let $( G , \\operatorname { l a b } _ { G } )$ and $\\left( H , \\mathrm { l a b } _ { H } \\right)$ be\n\ntwo vertex-disjoint labeled graphs in $\\mathrm { N L C } _ { k }$ , and $M \\subseteq [ k ] ^ { 2 }$ .   \nThen $( G , \\mathrm { l a b } _ { G } ) \\times _ { M } ( H , \\mathrm { l a b } _ { H } ) \\bar { \\in } \\mathrm { N L C } _ { k }$ .\n\nAn NLC-width $k$ -expression is a finite term built with the three operations above and using at most $k$ labels. The NLCwidth of a graph $G$ , denoted by $\\operatorname { n l c w } ( G )$ , is the minimum $k$ such that $( \\bar { G } , \\bar { \\mathrm { l a b } } _ { G } ) \\in \\mathrm { N L C } _ { k }$ for some labeling $\\operatorname { l a b } _ { G }$ .\n\nTheorem 3 ((Johansson 1998)). Let $k$ be a positive integer. Every graph of clique-width at most $k$ has NLC-width at most $k$ , and one can in polynomial time transform a clique-width $k$ -expression to an NLC-width $k$ -expression.\n\nWe remark about algorithms to find a clique-width expression when it is not given. (Fellows et al. 2006) proved that computing clique-width is NP-hard. (Oum and Seymour 2006) first obtained an approximation algorithm that computes a clique-width $( 2 ^ { 3 k + 2 ^ { 2 } } - 1 )$ -expression of a given graph $G$ of clique-width at most $k$ , which runs in time $\\mathcal { \\bar { O } } ( \\bar { 8 } ^ { k } n ^ { 9 } \\log n )$ . $( \\mathrm { O u m } 2 0 0 9 )$ later improved this by providing two algorithms; one is an algorithm that computes a cliquewidth $\\bar { ( 8 ^ { k } - 1 ) }$ -expression in time $\\mathcal { O } ( g ( k ) \\cdot \\overline { { n ^ { 3 } } } )$ for some function $g$ , and the other one is an algorithm that computes a clique-width $( 2 ^ { 3 k + 2 } - 1 )$ -expression in time $O ( 8 ^ { k } n ^ { \\mathbf { \\bar { 4 } } } )$ . We may use one of these algorithms to produce a clique-width expression, when it is not given as input.\n\n# FPT Algorithm Parameterized by Clique-Width\n\nNow we are ready to prove Theorem 1. Let $\\left( H , \\mathrm { l a b } _ { H } \\right)$ be a $k$ -labeled graph. For a set $X$ of vertices in $H$ , we denote by $\\mathrm { f u l l } _ { H } ( X )$ the set of integers $i \\in [ k ]$ where $\\operatorname { l a b } _ { H } ^ { - 1 } ( i ) \\subseteq \\dot { X }$ . For $I \\subseteq [ k ]$ , a set $T \\subseteq V ( H )$ is a minimum vertex cover of $H$ with respect to $I$ if it is a minimum set among all vertex covers $X$ of $H$ with $\\mathrm { f u l l } _ { H } ( X ) = I$ . Note that $T$ is not necessarily a minimum vertex cover of $H$ . Let $\\mu _ { H } ( I )$ be the size of a minimum vertex cover of $H$ with respect to $I$ .\n\nAssume that $( F , \\mathrm { l a b } _ { F } ) = ( G , \\mathrm { l a b } _ { G } ) \\times _ { M } ( H , \\mathrm { l a b } _ { H } )$ for some $k$ -labeled graphs $\\left( G , \\mathrm { l a b } _ { G } \\right)$ , $\\left( H , \\mathrm { l a b } _ { H } \\right)$ , and $M \\subseteq [ k ] ^ { 2 }$ . Observe that for every $( i , j ) \\in M$ , every vertex cover of $F$ either contains all vertices of $\\mathrm { l a b } _ { G } ^ { - 1 } ( i )$ or contains all vertices of $\\operatorname { l a b } _ { H } ^ { - 1 } ( j )$ . Thus, in each side, it is necessary to consider vertex covers that fully contain vertex sets of certain labels. This is the reason why we define minimum vertex covers with respect to $I \\subseteq [ k ]$ .\n\nNow, to find sets ${ \\dot { S } } \\subseteq V ( F )$ that force to have a unique minimum vertex cover, in each of $G$ and $H$ , we need to know whether a set forces to have a unique minimum vertex cover with respect to some $I \\subseteq [ k ]$ . For each $I \\subseteq [ k ]$ , we need to distinguish three statuses: (1) $S$ does not force any minimum vertex cover with respect to $I$ , (2) $S$ forces a unique minimum vertex cover with respect to $I$ , or (3) $S$ forces at least two minimum vertex covers with respect to $I$ . This property will be captured by the notion of characteristic, defined below.\n\nA function $\\beta : 2 ^ { [ k ] } \\to \\{ 0 , 1 , 2 \\}$ is the characteristic of a set $S \\subseteq V ( H )$ in $H$ if for every ${ \\bar { \\boldsymbol { J } } } \\subseteq [ k ]$ ,\n\n• if $\\beta ( J ) \\in \\{ 0 , 1 \\}$ , then there is exactly $\\beta ( J )$ many minimum vertex covers of $H$ with respect to $J$ and containing $S$ , and • if $\\beta ( J ) = 2$ , then there are at least two minimum vertex covers of $H$ with respect to $J$ and containing $S$ .\n\nSuch a set $S \\subseteq V ( H )$ is called a $\\beta$ -set in $H$ . Let $\\Pi ( H )$ be the collection of functions $\\beta : 2 ^ { [ k ] }  \\{ 0 , 1 , 2 \\}$ such that there is a $\\beta$ -set in $H$ .\n\nIn the following lemma, we explain how we can solve PAU-VC on a $k$ -labeled graph $H$ if we know the set $\\Pi ( H )$ and the function $\\mu _ { H }$ and a collection of minimum $\\beta$ -sets for each $\\beta \\in \\Pi ( H )$ .\n\nLemma 1. Let $k$ be a positive integer. Given a $k$ -labeled graph $( G , \\operatorname { l a b } _ { G } )$ with $\\Pi ( G )$ , $\\mu _ { G }$ and a collection of minimum $\\beta$ -sets for each $\\beta \\in \\Pi ( G )$ , one can solve PAU-VC for $G$ in time $\\mathcal { O } ( 3 ^ { 2 ^ { k } } | V ( G ) | )$ .\n\nProof. Let $\\mu \\ : = \\ : \\mathrm { m i n } _ { I \\subseteq [ k ] } \\mu _ { G } ( I )$ , and ${ \\Gamma } ~ = ~ \\{ J ~ \\subseteq ~ [ k ] ~ :$ $\\mu _ { G } ( J ) = \\mu \\}$ . Then $\\mu$ is the size of a minimum vertex cover of $G$ . We say that a function $\\beta : 2 ^ { [ k ] } \\to \\{ 0 , 1 , 2 \\}$ is valid if $\\sum _ { J \\in \\Gamma } \\beta ( J ) \\dot { = } 1$ . A $\\beta$ -set with a valid function $\\beta$ in $\\Pi ( G )$ is a set forcing a unique minimum vertex set in $G$ . Thus, the minimum $\\beta$ -set with a valid function $\\beta$ in $\\Pi ( G )$ is a required solution for PAU-VC. □\n\nBy Lemma 1, it is sufficient to compute $\\Pi ( H )$ and $\\mu _ { H }$ and a collection of minimum $\\beta$ -sets. We will compute them in a bottom-up way, along a given NLC-width $k$ -expression.\n\nIn the next lemma, we describe how to merge information for $( G , \\mathrm { l a b } _ { G } )$ and $\\left( H , \\mathrm { l a b } _ { H } \\right)$ to obtain information for $( G , \\mathrm { l a b } _ { G } ) \\times _ { M } ( H , \\mathrm { l a b } _ { H } )$ .\n\nLemma 2. Let k be a positive integer, and let $( G , \\mathrm { l a b } _ { G } )$ and $\\left( H , \\operatorname { l a b } _ { H } \\right)$ be vertex-disjoint $k$ -labeled non-empty graphs. Let $\\dot { M } \\subseteq [ k ] ^ { 2 }$ and let $( F , \\mathrm { l a b } _ { F } ) = ( G , \\mathrm { l a b } _ { G } ) \\times _ { \\bar { M } } ( \\bar { H } , \\mathrm { l a b } _ { H } )$ .\n\nGiven $\\Pi ( G ) , \\Pi ( H )$ and $\\mu _ { G } , \\mu _ { H }$ and a collection $\\mathcal { T } _ { G }$ of minimum $\\beta$ -sets for $\\beta \\in \\Pi ( G )$ and a collection $\\scriptstyle { \\mathcal { T } } _ { H }$ of minimum $\\beta$ -sets for $\\beta \\in \\Pi ( H )$ , one can compute $\\Pi ( F ) , \\mu _ { F }$ and a collection $\\mathcal { T } _ { F }$ of minimum $\\beta$ -sets for $\\beta \\in \\Pi ( F )$ in time $O ( 2 7 ^ { 2 ^ { k } } \\cdot | V ( G ) | ) .$ .\n\nProof. We construct an auxiliary bipartite graph $Q$ with bipartition $( \\{ a _ { i } : i \\in [ k ] \\} , \\{ b _ { i } : i \\in [ \\bar { k } ] \\} )$ such that $a _ { i }$ is adjacent to $b _ { j }$ if and only if $( i , j ) \\in M$ . Let $A = \\{ a _ { i } : i \\in [ \\bar { k } ] \\}$ , $B = \\{ b _ { i } : i \\in [ k ] \\}$ , and let $\\dot { g } ( a _ { i } ) = g ( b _ { i } ) = i$ for all $i \\in [ k ]$ . Let $\\mathcal { Z }$ be the collection of all vertex covers of $Q$ . Note that the number of all vertex covers of $Q$ is at most $2 ^ { 2 k }$ .\n\nWe first compute $\\mu _ { F } ( I )$ for each $I \\subseteq [ k ]$ , which is the size of a minimum vertex cover of $F$ with respect to $I$ . Note that for any $( i , j ) \\in M$ , every vertex cover of $F$ contains either all vertices of $\\operatorname { l a b } _ { G } ^ { - 1 } ( i )$ or all vertices of $\\operatorname { l a b } _ { H } ^ { - 1 } ( j )$ . We guess a vertex cover of $Q$ corresponding to parts whose all vertices are contained in a vertex cover of $F$ .\n\nWe construct a function $\\mu ^ { * }$ as below.\n\n• Let $I \\subseteq [ k ]$ . For each $Z \\in { \\mathcal { Z } }$ with $( g ( Z \\cap A ) \\cap g ( Z \\cap B ) ) \\backslash$ $I = \\emptyset$ , let $\\dot { I } _ { G } = I \\cup g ( Z \\cap A )$ and $I _ { H } = I \\cup g ( Z \\cap B )$ , and let $\\alpha ( Z ) : = \\mu _ { G } ( I _ { G } ) + \\mu _ { H } ( I _ { H } )$ . • We define $\\mu ^ { * } ( I )$ as the minimum such $\\alpha ( Z )$ over all $Z \\in { \\mathcal { Z } }$ with $( g ( Z \\cap A ) \\cap g ( Z \\cap B ) ) \\setminus I = \\emptyset$ . Note that such a set $Z$ exists as $A$ is such a vertex cover.\n\nClaim 1 $( * )$ . The above procedure correctly computes $\\mu _ { F }$ , that is, $\\mu ^ { * } ( I ) = \\mu _ { F } ( I )$ for every $I \\subseteq [ k ]$ .\n\nSince the number of vertex covers of $Q$ is at most $2 ^ { 2 k }$ , for each $I \\subseteq [ k ]$ , we can determine $\\mu ^ { * } ( I )$ in time $O ( 4 ^ { k } )$ . So, we can output $\\mu ^ { * }$ in time $\\mathcal { O } ( 4 ^ { k } )$ .\n\nNow, we compute $\\Pi ( F )$ and $\\scriptstyle { \\mathcal { T } } _ { F }$ . We construct sets $\\Pi ^ { * }$ and $\\boldsymbol { \\mathcal { T } ^ { * } }$ and will show that $\\dot { \\Pi } ^ { * } = \\Pi ( F )$ and $\\boldsymbol { \\mathcal { T } ^ { * } }$ is a collection of minimum $\\beta$ -sets for $\\beta \\in \\Pi ( F )$ . For a function $\\beta : 2 ^ { [ k ] } \\to$ $\\{ 0 , 1 , 2 \\}$ , we need to determine whether there is a $\\beta$ -set in $F$ . Let $\\beta : { \\dot { 2 } } ^ { [ k ] } \\to \\{ 0 , 1 , 2 \\}$ be a function.\n\n1. Let $I \\subseteq [ k ]$ . We say that a pair $\\left( { { I _ { G } } , { I _ { H } } } \\right)$ of subsets of $[ k ]$ is a split of $I$ with respect to $M$ if • $I _ { G } \\cap I _ { H } = I$ , and • for every $( i , j ) \\in M$ , $i \\in I _ { G }$ or $j \\in I _ { H }$ . A split $\\left( I _ { G } , I _ { H } \\right)$ of $I$ is proper if $\\mu _ { G } ( I _ { G } ) + \\mu _ { H } ( I _ { H } ) =$ $\\mu _ { F } ( I )$ .   \n2. A pair $( \\beta _ { G } , \\beta _ { H } )$ of functions $\\beta _ { G } , \\beta _ { H } : 2 ^ { [ k ] } \\to \\{ 0 , 1 , 2 \\}$ is legitimate for $\\beta$ if for all subsets $I \\subseteq [ k ]$ , we have\n\n$$\n\\beta ( I ) = \\operatorname* { m i n } \\left( 2 , \\sum _ { { ( I _ { G } , I _ { H } ) \\colon } \\atop { \\mathrm { p r o p e r ~ s p l i t ~ o f } I } } \\left( \\beta _ { G } ( I _ { G } ) \\times \\beta _ { H } ( I _ { H } ) \\right) \\right) .\n$$\n\n3. Assume there is a legitimate pair $( \\beta _ { G } , \\beta _ { H } )$ for $\\beta$ where $\\beta _ { G } \\in \\Pi ( G )$ and $\\beta _ { H } \\in \\Pi ( H )$ and $S _ { G }$ is a minimum $\\beta _ { G }$ - set in $\\mathcal { T } _ { G }$ and $S _ { H }$ is a minimum $\\beta _ { H }$ -set in $\\scriptstyle { \\mathcal { T } } _ { H }$ . Then we add $\\beta$ to $\\Pi ^ { * }$ and add $S _ { G } \\cup S _ { H }$ to $\\mathcal { T } ^ { * }$ . Otherwise, we do not add.\n\nClaim 2 $( * )$ . The above procedure correctly computes $\\Pi ( F )$ , that is, $\\Pi ^ { * } = \\Pi ( F )$ . Also, $\\boldsymbol { \\mathcal { T } ^ { * } }$ is a collection of $\\beta$ -sets for $\\beta \\in \\Pi ( F )$ .\n\nObserve that the number of possible functions $\\beta : 2 ^ { [ k ] } \\to$ $\\{ 0 , 1 , 2 \\}$ is at most $3 ^ { 2 ^ { k } }$ . Let $\\beta$ be such a function. For each $I \\subseteq [ k ]$ , there are at most $3 ^ { k - | I | } \\leq 3 ^ { k }$ splits of $I$ with respect to $M$ . Thus, for a fixed pair $( \\beta _ { G } , \\beta _ { H } )$ of functions, one can test whether $( \\beta _ { G } , \\beta _ { H } )$ is legitimate for $\\beta$ in time $O ( 2 ^ { k } \\cdot 3 ^ { k } )$ . Thus, we can determine $\\Pi ^ { * }$ and $\\boldsymbol { \\mathcal { T } ^ { * } }$ in time $O ( 3 ^ { 3 \\cdot 2 ^ { k } } \\cdot 2 ^ { k } \\cdot 3 ^ { k } \\cdot$ $| V ( G ) | ) = \\mathcal { O } ( 2 7 ^ { 2 ^ { k } } | V ( G ) | )$ . This concludes the proof. □\n\nLemma 3 $( * )$ . Let $k$ be a positive integer, and let $( G , \\mathrm { l a b } _ { G } )$ be a $k$ -labeled graph. Let $R : [ k ] \\to [ k ]$ be a function and let $( F , \\mathrm { l a b } _ { F } ) = \\bar { \\rho _ { R } ( G , \\mathrm { l a b } _ { G } ) }$ .\n\nGiven $\\Pi ( G )$ , $\\mu _ { G }$ , and a collection $\\mathcal { T } _ { G }$ of minimum $\\beta$ -sets for $\\beta \\in \\Pi ( G )$ , one can compute $\\Pi ( F )$ , $\\mu _ { F }$ and a collection $\\mathcal { T } _ { F }$ of minimum $\\beta$ -sets for $\\beta \\in \\Pi ( F )$ in time ${ \\mathcal { O } } ( 9 ^ { 2 ^ { k } } \\cdot | V ( G ) | )$ .\n\nNow, we are ready to prove Theorem 1.\n\nProof. (Proof of Theorem 1) Using an algorithm by (Oum 2009), we can compute a clique-width $( 2 ^ { 3 t + 2 } - 1 )$ -expression of a graph of clique-width $t$ in time $\\mathcal { O } ( 8 ^ { t } | V ( \\tilde { G } ) | ^ { \\bar { 4 } } )$ as explained in the preliminary section. In the rest, we discuss how to obtain an algorithm if a clique-width expression is given.\n\nLet $G$ be a graph and assume that its clique-width $k$ - expression is given. By Theorem 3, we can transform it into an NLC-width $k$ -expression $\\phi$ in polynomial time.\n\nWe design a bottom-up dynamic programming along the NLC-width $k$ -expression. At each $k$ -labeled graph $( F , \\mathrm { l a b } _ { F } )$ arising in $\\phi$ , we compute sets $\\Pi ( F )$ , $\\mu _ { F }$ , and a collection $\\mathcal { T } _ { F }$ of minimum $\\beta$ -sets for $\\beta \\in \\Pi ( { \\dot { F } } )$ as follows.\n\n1. Assume $( F , \\operatorname { l a b } _ { F } ) = i ( x )$ , that is, $F$ is a graph on a vertex $x$ with label $i$ . • Observe that $\\mu _ { F } ( \\{ i \\} ) = 1$ because $\\{ x \\}$ is the unique minimum vertex cover of $F$ with respect to $\\{ x \\}$ . Also, $\\mu _ { F } ( \\emptyset ) = 1$ because $\\varnothing$ is the unique minimum vertex cover of $F$ with respect to $\\varnothing$ . For other subsets $I$ of $[ k ]$ $, \\mu _ { F } ( I ) = 0$ , as there is no vertex cover of $F$ with respect to $I$ . • Note that the empty set has the characteristic $\\beta _ { 0 }$ where $\\beta _ { 0 } ( J ) = 1$ for $J = \\{ i \\}$ or $\\varnothing$ , and $\\beta _ { 0 } ( J ) = 0$ otherwise. The set $\\{ x \\}$ has characteristic $\\beta _ { 1 }$ where $\\beta _ { 1 } ( J ) = 1$ for $J =  { \\left\\{ i \\right\\} }$ , and $\\beta _ { 1 } ( J ) = 0$ otherwise. Let $\\Pi ( F ) =$ $\\{ \\beta _ { 0 } , \\beta _ { 1 } \\}$ . We store the empty set as a minimum $\\beta _ { 0 }$ -set, and $\\{ x \\}$ as a minimum $\\beta _ { 1 }$ -set. • These can be computed in time ${ \\mathcal { O } } ( k )$ .   \n2. Assume that $( F , \\mathrm { l a b } _ { F } ) = \\rho _ { R } ( F _ { 1 } , \\mathrm { l a b } _ { 1 } )$ for some function $R : [ k ] \\ \\to \\ [ k ]$ . By Lemma 3, we can in time $\\mathcal { O } ( 9 ^ { 2 ^ { k } } \\cdot | V ( G ) | )$ compute $\\Pi ( F )$ , $\\mu _ { F }$ , and a collection $\\mathcal { T } _ { F }$ of minimum $\\beta$ -sets for $\\beta \\in \\Pi ( F )$ .   \n3. Assume that $( F , \\mathrm { l a b } _ { F } ) ~ = ~ ( F _ { 1 } , \\mathrm { l a b } _ { 1 } ) { } ~ \\times _ { M } { } ~ ( F _ { 2 } , \\mathrm { l a b } _ { 2 } )$ for some $M \\subseteq [ k ] ^ { 2 }$ . By Lemma 2, we can in time $\\mathcal { O } ( 2 7 ^ { 2 ^ { k } } \\cdot | V ( F ) | )$ compute $\\Pi ( F ) , \\mu _ { F }$ , and a collection $\\mathcal { T } _ { F }$ of minimum $\\beta$ -sets for $\\beta \\in \\Pi ( F )$ .\n\nAt the end, by Lemma 1, we can solve PAU-VC in time $\\mathcal { O } ( 3 ^ { 2 ^ { k } } | V ( G ) | )$ . Note that there are at most $\\mathcal { O } ( k ^ { 2 } | V ( G ) | )$ operations in the NLC-width $k$ -expression. Thus, in total, we can solve PAU-VC in time $\\mathcal { O } ( 2 7 ^ { 2 ^ { k } } | V ( G ) | ^ { 2 } )$ . □\n\n# Unit Interval Graphs\n\nIn this section, we give a linear time algorithm of PAU-VC for a unit interval graph $G$ . A unit interval graph $G$ is a graph that has a set $\\boldsymbol { \\mathcal { T } }$ of intervals of length one on the real line so that $G$ is an intersection graph of $\\boldsymbol { \\mathcal { T } }$ , refer to Figure 2.\n\nTheorem 4. PAU-VC can be solved in linear time for a unit interval graph.\n\nProof. Let $G$ be a given unit interval graph. We can find a set $\\boldsymbol { \\mathcal { T } }$ of unit intervals representing $G$ in linear time (Corneil et al. 1995). Furthermore, the obtained $\\boldsymbol { \\mathcal { T } }$ is sorted by the left end points. For clarity, we refer to the intervals in $\\boldsymbol { \\mathcal { T } }$ as the vertices of $G$ . By perturbing if necessary, we may assume that all intervals are pairwise distinct.\n\nFirst, we find a maximum independent set $\\{ \\tilde { I } _ { 1 } , \\dots , \\tilde { I } _ { m } \\}$ of $G$ as follows: $\\tilde { I } _ { 1 }$ is the leftmost interval in $\\boldsymbol { \\mathcal { T } }$ and $\\tilde { I } _ { i + 1 }$ is the leftmost interval in $\\boldsymbol { \\mathcal { T } }$ disjoint to $\\tilde { I } _ { j }$ for all $j \\in [ i ]$ . It is easy to see that the obtained set is a maximum independent set of $G$ . Then, for each ${ \\tilde { I } } _ { i }$ , let $\\mathcal { T } _ { i }$ be the set of intervals in $\\boldsymbol { \\mathcal { T } }$ that start after ${ \\tilde { I } } _ { i }$ and intersect with ${ \\tilde { I } } _ { i }$ , along with ${ \\tilde { I } } _ { i }$ itself. Then $\\{ \\mathcal { T } _ { 1 } , \\ldots , \\mathcal { T } _ { m } \\}$ gives a partition of $\\boldsymbol { \\mathcal { T } }$ , and each $\\mathcal { T } _ { i }$ forms a clique in $G$ . Note that if two intervals $I \\in \\mathcal { I } _ { i }$ and $J \\in \\mathcal { I } _ { j }$ are intersecting, then $| i - j | \\le 1$ since every interval has a unit length.\n\n![](images/c694e545c53556733fafaeaf59ed5a211d4016117fd3d475024db0394277c0de.jpg)  \nFigure 2: Illustration of the algorithm for a unit interval graph $G$ . Figures (a) and (b) represent the unit interval graph $G$ and its representation, respectively. The algorithm returns $\\{ I _ { 1 , 1 } , I _ { 2 , 2 } \\}$ as an optimal solution of PAU-VC of $G$ , where $\\{ I _ { 1 , 1 } , I _ { 2 , 2 } \\} = S [ 3 , 3 ]$ as $S [ 1 , 2 ] = \\{ I _ { 1 , 1 } \\} , A _ { 1 , 2 , 3 } = \\{ I _ { 2 , 2 } \\}$ , and $A _ { 2 , 3 , 3 } = \\varnothing$ . Precisely, $S [ 3 , 3 ] = S [ 1 , 2 ] \\cup A _ { 1 , 2 , 3 } \\cup A _ { 2 , 3 , 3 } .$ .\n\nClaim 3. Every minimum vertex cover of $G$ excludes exactly one vertex in $\\mathcal { T } _ { i }$ for each $i \\in [ m ]$ .\n\nProof. It is well known that the complement of a maximum independent set is a minimum vertex cover, and vice versa. Since $m$ is the size of the maximum independent set of $G$ , every minimum vertex cover should exclude $m$ vertices. Note that each $\\mathcal { T } _ { i }$ forms a clique in $G$ , it cannot exclude more than one vertex from the same $\\mathcal { T } _ { i }$ . Thus, exactly one vertex for each $\\mathcal { T } _ { i }$ is excluded. $\\diamondsuit$\n\nNow we describe a dynamic programming to solve PAUVC for $G$ .\n\nLet $i \\in [ m ]$ and $j \\in [ | \\mathcal { T } _ { i } | ]$ . Let $I _ { i , j }$ be the $j$ th leftmost interval in $\\mathcal { T } _ { i }$ , and let $G _ { i , j }$ be the subgraph of $G$ induced by the intervals starting before $I _ { i , j }$ along with $I _ { i , j }$ .\n\nFor $j \\in [ | \\mathcal { I } _ { 1 } | ]$ , let $A _ { 1 , j } : = \\{ I _ { 1 , i } : i < j \\}$ . For $ 2 \\leq i \\leq$ $m - 1$ and $a \\in [ | \\mathcal { I } _ { i } | ]$ and $b \\in [ | \\mathcal { T } _ { i + 1 } | ]$ , let\n\n$$\n\\begin{array} { r l } & { A _ { i , a , b } : = \\{ I _ { i , x } : a < x \\mathrm { ~ a n d ~ } I _ { i , x } \\cap I _ { i + 1 , b } = \\emptyset \\} } \\\\ & { \\qquad \\cup \\{ I _ { i + 1 , y } : y < b \\mathrm { ~ a n d ~ } I _ { i + 1 , y } \\cap I _ { i , a } = \\emptyset \\} , } \\end{array}\n$$\n\nIntuitively, $A _ { 1 , j }$ and $A _ { i , a , b }$ are sets of vertices that have to be included in a set forcing a unique minimum vertex cover $S$ when we want that $I _ { i , a }$ and $I _ { i + 1 , b }$ are not in $S$ .\n\nNow, for each $I _ { i , j } \\in \\mathcal { I }$ , we denote $S [ i , j ]$ as the smallest vertex set in $G _ { i , j }$ that forces the unique minimum vertex cover in $G _ { i , j }$ and the vertex cover excludes $I _ { i , j }$ .\n\nWe compute $S [ i , j ]$ in a lexicographic order. As the base case, we set $S [ 1 , j ] : = A _ { 1 , j }$ for each $\\bar { j } \\in [ | \\mathcal { I } _ { 1 } | ]$ . By assuming that every $S [ i , j ^ { \\prime } ]$ has been computed for $j ^ { \\prime } \\in [ | \\mathcal { T } _ { i } | ]$ , we set $S [ i + 1 , j ]$ as the smallest vertex set among\n\n$$\nS [ i , j ^ { \\prime } ] \\cup A _ { i , j ^ { \\prime } , j }\n$$\n\nwhere $I _ { i , j ^ { \\prime } } \\in \\mathcal { T } _ { i }$ is disjoint from $I _ { i + 1 , j }$ . Note that $S [ i { + } 1 , j ]$ is well-defined, because $I _ { i , 1 } = \\tilde { I } _ { i }$ is disjoint from $I _ { i + 1 , 1 } = \\tilde { I } _ { i + 1 }$ along with Ii+1,j .\n\n1C,1laim 4. For evIe2,r1y $i \\in [ m ]$ and $j ~ \\in ~ [ | \\mathcal { T } _ { i } | ] , ~ S [ i , j ]$ is a smallest vertex set in $G _ { i , j }$ that forces a unique minimum verIt1e,2x cover in $G _ { i , j }$ Ia2n,2d the vertex covIe3r,2excludes $I _ { i , j }$ .\n\nProof. We prove this by induction on $i + j$ . First, assume that $i = 1$ 1.,3Then $G _ { 1 , j }$ is a c2,o4mplete graph. Thus, there is only one vertex cover excluding $I _ { 1 , j }$ , namely $V ( G _ { 1 , j } ) \\backslash$ $\\{ I _ { 1 , j } \\}$ . If we do not preassign a vertex of $V ( G _ { 1 , j } ) \\backslash \\{ I _ { 1 , j } \\}$ , we may take $I _ { i , j }$ instead of this vertex, to make another minimum vertex cover of $G _ { 1 , j }$ . Thus, $S [ 1 , j ]$ should be exactly $V ( G _ { 1 , j } ) \\backslash \\{ I _ { 1 , j } \\}$ .\n\nSuppose that $i \\geq 2$ . Let $T$ be a minimum vertex set in $G _ { i , j }$ that forces a unique minimum vertex cover in $G _ { i , j }$ and the vertex cover excludes $I _ { i , j }$ . We will show that $T$ is of the form $S [ i - 1 , j ^ { \\prime } ] \\cup A _ { i - 1 , j ^ { \\prime } , j }$ in the definition. Let $U$ be the unique vertex cover in $G _ { i , j }$ containing $T$ , and let $W = V ( G _ { i , j } ) \\backslash U$ . Observe that $W$ contains exactly one vertex from each of $\\mathcal { T } _ { 1 } , \\ldots , \\mathcal { T } _ { i }$ . Let $j _ { 1 } , \\dotsc , j _ { i - 1 }$ be integers such that $W = \\{ I _ { 1 , j _ { 1 } } , I _ { 2 , j _ { 2 } } , \\dotsc , I _ { i - 1 , j _ { i - 1 } } , I _ { i , j } \\}$ .\n\nWe claim that\n\n$$\nA ^ { * } : = A _ { 1 , j _ { 1 } } \\cup \\left( \\bigcup _ { x \\in [ i - 1 ] } A _ { x , j _ { x } , j _ { x + 1 } } \\right) \\subseteq T .\n$$\n\nSuppose for contradiction that this is not true. First assume that $A _ { 1 , j _ { 1 } }$ contains a vertex $I$ that is not in $T$ . Then $( U \\backslash$ $\\{ I \\} ) \\cup \\{ I _ { 1 , j _ { 1 } } \\}$ is also a minimum vertex cover of $G _ { i , j }$ containing $T$ , a contradiction.\n\nWe assume that for some $x \\in [ i - 1 ]$ , $A _ { x , j _ { x } , j _ { x + 1 } }$ contains a vertex $I$ that is not in $T$ . If\n\n$$\nI \\in \\{ I _ { x , z } : j _ { x } < z \\mathrm { ~ a n d ~ } I _ { x , z } \\cap I _ { x + 1 , j _ { x + 1 } } = \\emptyset \\} ,\n$$\n\nthen $( U \\setminus \\{ I \\} ) \\cup \\{ I _ { x , j _ { x } } \\}$ is a minimum vertex cover of $G _ { i , j }$ , a contradiction. Otherwise, if\n\n$$\nI \\in \\{ I _ { x + 1 , z } : z < j _ { x + 1 } \\mathrm { ~ a n d ~ } I _ { x + 1 , z } \\cap I _ { x , j _ { x } } = \\emptyset \\} ,\n$$\n\nthen $( U \\setminus \\{ I \\} ) \\cup \\{ I _ { x + 1 , j _ { x + 1 } } \\}$ is a minimum vertex cover of $G _ { i , j }$ , a contradiction. Therefore, $A ^ { * } \\subseteq T$ .\n\nNow, we verify that $A ^ { * }$ already forces that $U$ is a unique minimum vertex cover containing $A ^ { * }$ . Suppose there is another minimum vertex cover $U ^ { \\prime }$ containing $A ^ { * }$ . As $U ^ { \\prime } \\neq$ $U , U ^ { \\prime }$ does not contain a vertex of $U \\backslash A ^ { * }$ . Then $G _ { i , j } - U ^ { \\prime }$ cannot contain an independent set of size $i$ , a contradiction. By our construction, $T$ is $S [ i - 1 , j ^ { \\prime } ] \\cup A _ { i - 1 , j ^ { \\prime } , j }$ for some $j ^ { \\prime }$ where $I _ { i - 1 , j ^ { \\prime } } \\in \\mathcal { T } _ { i - 1 }$ disjoint from $I _ { i , j }$ . On the other hand, we compute $S [ i , j ]$ as a smallest vertex set among all possible $S [ i - 1 , j ^ { \\prime } ] \\cup A _ { i - 1 , j ^ { \\prime } , j }$ . Thus, $S [ i , j ]$ is a smallest vertex set in $G _ { i , j }$ that forces a unique minimum vertex cover in $G _ { i , j }$ and the vertex cover excludes $I _ { i , j }$ . $\\diamondsuit$\n\nFurthermore, the smallest vertex set among\n\n$$\nS [ m , j ] \\cup \\{ I _ { m , k } \\in \\mathcal { I } _ { m } : j < k \\}\n$$\n\nfor $j \\in [ | \\mathcal { T } _ { m } | ]$ is an optimal solution of PAU-VC for $G$ .\n\nThis algorithm returns a solution in polynomial time. In the following, we slightly modify it as a linear time algorithm.\n\nLinear time algorithm. We compute the interval set $\\boldsymbol { \\mathcal { T } }$ corresponds to the given unit interval graph $G$ , and its decomposition $\\mathcal { T } _ { 1 } , \\ldots , \\mathcal { T } _ { m }$ as described above. It takes a linear time. To obtain a linear time algorithm for PAU-VC, we compute and store the size $s [ i + 1 , j ]$ of the set $S [ i + 1 , j ]$ for each $( i + 1 , j )$ with $i \\in [ m - 1 ]$ and $j \\in [ | \\mathcal { T } _ { i + 1 } | ]$ instead of explicitly constructing the set $S [ i + 1 , j ]$ . Since the set $S [ i + 1 , j ]$ is the union of disjoint sets $S [ i , j ^ { \\prime } ]$ and $A _ { i , j ^ { \\prime } , j }$ , we can compute $s [ i + 1 , j ]$ without explicitly constructing $S [ i , j ]$ . Furthermore, we also store the index $j ^ { \\prime } \\in [ | \\mathcal { T } _ { i } | ]$ at the pair $( i + 1 , j )$ so that $S [ i + 1 , j ] = S [ i , j ^ { \\prime } ] \\cup A _ { i , j ^ { \\prime } , j }$ . We can compute all values of $s [ \\cdot , \\cdot ]$ in $\\mathcal { O } ( | \\mathcal { T } | )$ time.\n\n# Claim 5. We can compute all $s [ \\cdot , \\cdot ] i n \\mathcal { O } ( | \\mathcal { I } | )$ time.\n\nProof. We set $s [ 1 , j ] = j - 1$ by the definition. For an index $i \\in [ m - 1 ]$ , we assume that every $s [ i , \\cdot ]$ is computed already, and describe how to compute all $s [ i + 1 , \\cdot ]$ in $\\mathcal { O } ( | \\mathcal { T } _ { i } \\cup \\mathcal { T } _ { i + 1 } | )$ time which directly implies the claim. For this, we first compute an index $k ( j ) \\in [ | \\mathcal { T } _ { i } | ]$ for each $j \\in$ $\\big [ \\big | \\mathscr { T } _ { i + 1 } \\big | \\big ]$ so that the interval $I _ { i , k ( j ) }$ is the rightmost interval in $\\mathcal { T } _ { i }$ disjoint from $I _ { i + 1 , j }$ . Since $\\mathcal { \\bar { T } } _ { i }$ and ${ \\mathcal { T } } _ { i + 1 }$ are sorted, the indices $k ( j )$ ’s are monotonic increasing. Furthermore, we can compute all $k ( j )$ ’s in $\\mathcal { O } ( | \\mathcal { T } _ { i } \\cup \\mathcal { T } _ { i + 1 } \\bar { | } )$ time. For clarity, we set $k ( 0 ) = 0$ in the following. Note that $I _ { i , j ^ { \\prime } } \\cap I _ { i + 1 , j } =$ $\\varnothing$ if and only if $j ^ { \\prime } \\leq k ( j )$ for $j \\in [ | \\mathcal { T } _ { | i + 1 } ]$ .\n\nRecall that $s [ i + 1 , j ]$ is the smallest value among $s [ i , j ^ { \\prime } ] +$ $| A _ { i , j ^ { \\prime } , j } |$ with $j ^ { \\prime } \\le k ( j )$ . Furthermore, if $j ^ { \\prime } \\leq k ( j - 1 )$ , then $A _ { i , j ^ { \\prime } , j }$ is same with\n\n$$\nA _ { i , j ^ { \\prime } , j - 1 } \\cup \\{ I _ { i , x } : k ( j - 1 ) < x \\leq k ( j ) \\} \\cup \\{ I _ { i + 1 , j - 1 } \\} .\n$$\n\nIf an index $j ^ { \\prime } \\leq k ( j )$ gives the smallest set $S [ i , j ^ { \\prime } ] \\cup A _ { i , j ^ { \\prime } , j }$ , then either $j ^ { \\prime } > k ( j - 1 )$ or it gives a smallest set among $S [ i , j ^ { \\prime } ] \\cup A _ { i , j ^ { \\prime } , j - 1 }$ . Thus, we can compute the size $s [ i + 1 , j ]$ of $S [ i + 1 , j ]$ by comparing $k ( j ) - \\bar { k } ( j - 1 ) + \\mathrm { i }$ values. Totally, computing all $s [ i + 1 , \\cdot ]$ requires ${ \\mathcal { O } } ( | { \\mathcal { T } } _ { i } \\cup { \\mathcal { T } } _ { i + 1 } | )$ time, and thus, computing all $s [ \\cdot , \\cdot ]$ takes $\\mathcal { O } ( | \\mathcal { T } | )$ time. $\\diamondsuit$\n\nAfter we compute every $s [ \\cdot , \\cdot ]$ , we find out the index $j ^ { \\ast } \\in$ $\\left[ \\left. \\mathcal { I } _ { m } \\right. \\right]$ minimizing the value $\\dot { s } [ \\dot { m } , j ^ { * } ] + | \\mathcal { T } _ { m } | - j ^ { * }$ . Then we define $j _ { m } = j ^ { * }$ and $j _ { i }$ as the index with $\\begin{array} { r l r } { S [ i + 1 , j _ { i + 1 } ] = } \\end{array}$ $S [ i , j _ { i } ] \\cup A _ { i , j _ { i } , j _ { i + 1 } }$ for $i \\in [ m - 1 ]$ . By the definition of the sets $S [ \\cdot , \\cdot ]$ , the following set is same with $S [ m , j ^ { * } ] \\cup \\{ I _ { m , k } \\in$ ${ \\mathcal { T } } _ { m } : { \\dot { j } } _ { m } \\not < k \\}$ that is an optimal solution of PAU-VC\n\n$$\nA _ { 1 , j _ { 1 } } \\cup \\left( \\bigcup _ { i \\in [ m - 1 ] } A _ { i , j _ { i } , j _ { i + 1 } } \\right) \\cup \\{ I _ { m , k } \\in \\mathbb { Z } _ { m } : j _ { m } < k \\} .\n$$\n\nIn conclusion, our algorithm returns a solution of PAU-VC for $G$ in linear time, and thus, Theorem 4 holds. □\n\n# Split Graphs\n\nIn this section, we describe a linear time algorithm for split graphs. A split graph $G$ is a graph in which there exist disjoint subsets $A$ $4 , B \\subseteq V ( G )$ such that $V ( G ) = A \\cup B ,$ ， $A$ is a clique and $B$ is an independent set.\n\nTheorem 5. PAU-VC can be solved in linear time for a split graph.\n\nProof. Let $G$ be a given split graph, of which the vertex set consists of a clique $A$ and an independent set $B$ . Observe that a minimum vertex set excludes at most one vertex from $A$ , and furthermore, $A$ is a vertex cover of $G$ . We claim that we can safely remove all vertices in $A$ from $G$ which has at least two adjacent vertices in $B$ and also remove isolated vertices.\n\nClaim 6 $( * )$ . If $v \\in A$ has at least two adjacent vertices in $B$ , then every minimum vertex cover of $G$ includes $v$ .\n\nIn the following, suppose that every vertex in $A$ has at most one adjacent vertex in $B$ and there is no isolated vertex. Let $A _ { 0 }$ be the set of vertices in $A$ which has no adjacent vertex in $B$ . We first consider the case that $A _ { 0 }$ is not empty. In such a case, a minimum vertex cover of $G$ has size $| A | - 1$ , furthermore, $A \\backslash \\{ v \\}$ is a minimum vertex cover of $G$ for every vertex $v \\in A _ { 0 }$ . Thus, $A _ { 0 } \\setminus \\{ v \\}$ is an optimal solution of PAU-VC for an arbitrary vertex $v \\in A _ { 0 }$ .\n\nIn the following, we consider the other case that $A _ { 0 } = \\varnothing$ . In this case, the size of a minimum vertex cover of $G$ is $| A |$ .\n\nFor each $a \\in A$ , let $\\boldsymbol { v } _ { a }$ be the vertex of $A$ that is adjacent to $a$ . Observe that for each $a \\in A$ , $( A \\setminus \\{ a \\} ) \\cup \\{ v _ { a } \\}$ is also a minimum vertex cover. We find a vertex $b ^ { * } \\in B$ minimizing $N _ { G } ( b ^ { * } )$ , and return $( N _ { G } ( b ^ { * } ) \\setminus \\{ v \\} ) \\cup \\{ b ^ { * } \\}$ as a solution of PAU-VC, where $\\boldsymbol { v }$ is an arbitrary vertex in $N _ { G } ( b ^ { * } )$ .\n\n$\\mathbf { C l a i m 7 } \\left( * \\right)$ . Let $b ^ { * } \\in B$ such that $| N _ { G } ( b ^ { * } ) |$ is minimum, and let $v \\in N _ { G } ( B ^ { * } )$ . Then $( N _ { G } ( b ^ { * } ) \\setminus \\{ v \\} ) \\cup \\{ b ^ { * } \\}$ is a solution of PAU-VC.\n\nIn conclusion, we can find a solution of PAU-VC of a split graph $G$ by checking all neighbors for each vertex in $B$ . Thus, it takes $\\mathcal { O } ( | V ( G ) | )$ time, because every vertex in $A$ has at most one neighbor in $B$ . □\n\n# Conclusion\n\nIn this paper, our main contributions are three-fold: a fixedparameter tractable algorithm for PAU-VC parameterized by clique-width, and linear-time algorithms for unit interval graphs and split graphs. In particular, the first algorithm improves the best-known algorithm for PAU-VC on trees significantly. We believe that these algorithms can be used to generate benchmark datasets for evaluating the performances of AI algorithms on the unique vertex cover problem.\n\nThere are still lots of open problems in this topic. Can we design polynomial-time algorithms for interval graphs, chordal graphs, or perfect graphs? It is known that these graph classes admit polynomial-time algorithms for the minimum vertex cover problem (Grötschel, Lovász, and Schrijver 1981). Can we reduce the dependency on clique-width to be single-exponential, or can we show that our algorithm is optimal? Recall that our algorithm runs in time double exponential in the clique-width of a graph. Although the running time seems large, it is still possible that our algorithms are optimal; there are several problems with lower bounds that are double exponential in the tree-width or clique-width (Marx and Mitsou 2016; Golovach et al. 2018; Foucaud et al. 2024; Bliznets and Hecher 2024). Last but not least, can we design approximation algorithms for PAU-VC on general graphs or bipartite graphs?\n\n# Acknowledgments\n\nY. Chang, O. Kwon, and M. Lee are supported by the National Research Foundation of Korea (NRF) grant funded by the Ministry of Science and ICT (No. NRF2021K2A9A2A11101617 and No. RS-2023-00211670). O. Kwon is also supported by the National Research Foundation of Korea (NRF) grant funded by Institute for Basic Science (IBS-R029-C1).   \nS. An, K. Cho, E. Oh, and H. Shin are supported by Institute of Information Communications Technology Planning Evaluation (IITP) grant funded by the Korea government (MSIT) (No.RS-2024-00440239) and the National Research Foundation of Korea (NRF) grant funded by the Korea government (MSIT) (No.RS-2024-00358505). K. Cho is also supported by the National Research Foundation of Korea (NRF) grant funded by the Korea government (MSIT) (No.RS-2024-00410835).",
    "institutions": [
        "POSTECH",
        "Hanyang University",
        "Institute for Basic Science (IBS)"
    ],
    "summary": "{\n  \"core_summary\": \"### 核心概要\\n\\n**问题定义**\\n论文旨在解决PRE - ASSIGNMENT FOR UNIQUIFICATION OF MINIMUM VERTEX COVER（PAU - VC）问题，即对于给定图 $G$，找到一个最小顶点集 $S$，使得 $G$ 存在唯一包含 $S$ 的最小顶点覆盖。该问题的重要性在于目前缺乏用于评估人工智能驱动的组合问题唯一性版本求解器性能的合适基准数据集，而解决PAU - VC问题可生成具有唯一解的图，用于完善基准数据集，从而更全面地评估求解器的性能。\\n\\n**方法概述**\\n论文提出了以团宽度为参数的固定参数可处理（FPT）算法，通过动态规划求解PAU - VC问题，同时针对单位区间图和分裂图设计了线性时间算法。\\n\\n**主要贡献与效果**\\n- 证明PAU - VC问题以团宽度为参数是固定参数可处理的，改进了Horiyama等人针对树的指数时间算法（$\\mathcal{O}(1.4143^n)$），新算法在树结构上达到多项式时间复杂度，显著降低了时间复杂度。\\n- 为单位区间图和分裂图设计了线性时间算法来解决PAU - VC问题，而先前工作未给出这两类图的有效算法，本文算法显著提升了这两类图上该问题的求解效率。\",\n  \"algorithm_details\": \"### 算法/方案详解\\n\\n**核心思想**\\n- 对于树结构，通过选择根节点，定义 $\\beta$ - 集，递归计算每个节点的最小 $\\beta$ - 集，使得每个类型的最小顶点覆盖数量满足特定条件，从而找到PAU - VC的最优解。\\n- 对于有界团宽度的图，通过定义团宽度和NLC - 宽度，利用动态规划算法，沿着NLC - 宽度表达式自底向上计算相关信息，以解决PAU - VC问题。\\n- 对于单位区间图，先找到最大独立集，将图划分为多个团，利用动态规划计算每个子图中强制唯一最小顶点覆盖的最小顶点集，最后得到PAU - VC的最优解。\\n- 对于分裂图，根据图的结构特点，移除不必要的顶点，分情况讨论得到PAU - VC的最优解。这种方法的有效性在于利用了不同图结构的特性，将复杂的问题分解为可递归或动态规划解决的子问题。\\n\\n**创新点**\\n先前的研究中，除了Horiyama等人的工作外，对PAU - VC问题了解甚少。本文创新之处在于：\\n- 首次证明了PAU - VC问题是关于团宽度的固定参数可处理问题，改进了树结构上的指数时间算法。\\n- 针对单位区间图和分裂图这两类无界团宽度的自然图类，设计了线性时间算法，而之前未对这些图类上的PAU - VC问题进行深入研究。\\n\\n**具体实现步骤**\\n1. **树结构算法**：\\n    - 选择任意顶点作为树的根节点，对于每个节点 $v$，用 $G_v$ 表示以 $v$ 为根的子树。\\n    - 定义 $\\beta$ - 集，递归计算每个节点 $v$ 对于每个可能的函数 $\\beta$ 的最小 $\\beta$ - 集。\\n    - 找到所有最小 $\\beta$ - 集中满足 $\\beta(0) + \\beta(1) = 1$ 的最小集，即为PAU - VC的最优解。\\n2. **有界团宽度图的算法**：\\n    - 若图的团宽度 $k$ - 表达式已知，将其转换为NLC - 宽度 $k$ - 表达式 $\\phi$；若未给出则使用相关算法生成。\\n    - 沿着 $\\phi$ 进行自底向上的动态规划：\\n        - 对于单顶点图 $i(x)$，计算 $\\mu_F$ 和 $\\Pi(F)$。\\n        - 对于 $(F, \\mathrm{lab}_F) = \\rho_R(F_1, \\mathrm{lab}_1)$，根据Lemma 3计算 $\\Pi(F)$、$\\mu_F$ 和最小 $\\beta$ - 集。\\n        - 对于 $(F, \\mathrm{lab}_F) = (F_1, \\mathrm{lab}_1) \\times_M (F_2, \\mathrm{lab}_2)$，根据Lemma 2计算 $\\Pi(F)$、$\\mu_F$ 和最小 $\\beta$ - 集。\\n    - 最后根据Lemma 1求解PAU - VC问题。\\n3. **单位区间图算法**：\\n    - 找到表示单位区间图 $G$ 的单位区间集 $\\mathcal{T}$，并按左端点排序。\\n    - 找到最大独立集 $\\{ \\tilde{I}_1, \\dots, \\tilde{I}_m \\}$，将 $\\mathcal{T}$ 划分为 $\\{ \\mathcal{T}_1, \\ldots, \\mathcal{T}_m \\}$，每个 $\\mathcal{T}_i$ 形成一个团。\\n    - 定义 $A_{1,j}$ 和 $A_{i,a,b}$，按字典序计算 $S[i, j]$。\\n    - 为实现线性时间算法，计算并存储 $s[i + 1, j]$ 的大小和对应的索引 $j'$。\\n    - 找到最小顶点集 $S[m, j] \\cup \\{ I_{m,k} \\in \\mathcal{T}_m : j < k \\}$ 作为PAU - VC的最优解。\\n4. **分裂图算法**：\\n    - 对于给定的分裂图 $G$，其顶点集由团 $A$ 和独立集 $B$ 组成。\\n    - 移除 $A$ 中至少有两个相邻顶点在 $B$ 中的顶点和孤立顶点。\\n    - 若 $A_0$ （$A$ 中无相邻顶点在 $B$ 中的顶点集）非空，$A_0 \\setminus \\{ v \\}$ 为最优解。\\n    - 若 $A_0$ 为空，找到 $B$ 中使 $|N_G(b^*)|$ 最小的顶点 $b^*$，$(N_G(b^*) \\setminus \\{ v \\}) \\cup \\{ b^* \\}$ 为最优解。\\n\\n**案例解析**\\n在单位区间图算法中，给出了一个单位区间图 $G$ 的示例，如图2所示。算法返回 $\\{ I_{1,1}, I_{2,2} \\}$ 作为PAU - VC的最优解，其中 $\\{ I_{1,1}, I_{2,2} \\} = S[3, 3]$，$S[3, 3] = S[1, 2] \\cup A_{1,2,3} \\cup A_{2,3,3}$，$S[1, 2] = \\{ I_{1,1} \\}$，$A_{1,2,3} = \\{ I_{2,2} \\}$，$A_{2,3,3} = \\varnothing$。\",\n  \"comparative_analysis\": \"### 对比实验分析\\n\\n**基线模型**\\n论文中的基线模型为Horiyama等人在2024年提出的算法，该算法为一般图提供了运行时间为 $\\mathcal{O}(2.1996^n)$ 的算法，为二分图提供了运行时间为 $\\mathcal{O}(1.9181^n)$ 的算法，为树提供了运行时间为 $\\mathcal{O}(1.4143^n)$ 的算法，其中 $n$ 表示顶点数。\\n\\n**性能对比**\\n*   **在 [时间复杂度/Time Complexity] 指标上：** 本文提出的以团宽度为参数的固定参数可处理算法解决了PAU - VC问题在树结构上时间复杂度的开放问题，针对树结构的算法达到了多项式时间复杂度，显著优于Horiyama等人的指数时间算法（$\\mathcal{O}(1.4143^n)$），大幅降低了时间复杂度。此外，本文针对单位区间图和分裂图设计的线性时间算法，在这两类图上的时间复杂度远低于基线模型在一般图和二分图上的指数时间复杂度，而先前工作未给出这两类图的有效算法，本文算法在这两类图上的求解效率远高于基线模型。\",\n  \"keywords\": \"### 关键词\\n\\n- 最小顶点覆盖唯一化预分配问题 (Pre - Assignment for Uniquification of Minimum Vertex Cover Problem, PAU - VC)\\n- 团宽度 (Clique - width, cw)\\n- NLC宽度 (NLC - width, nlcw)\\n- 固定参数可处理算法 (Fixed - Parameter Tractable Algorithm, FPT)\\n- 单位区间图 (Unit Interval Graph, N/A)\\n- 分裂图 (Split Graph, N/A)\"\n}"
}