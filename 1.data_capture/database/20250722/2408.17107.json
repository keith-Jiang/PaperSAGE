{
    "link": "https://arxiv.org/abs/2408.17107",
    "pdf_link": "https://arxiv.org/pdf/2408.17107",
    "title": "How Many Lines to Paint the City: Exact Edge-Cover in Temporal Graphs",
    "authors": [
        "Argyrios Deligkas",
        "Michelle Doring",
        "E. Eiben",
        "Tiger-Lily Goldsmith",
        "George Skretas",
        "Georg Tennigkeit"
    ],
    "publication_date": "2024-08-30",
    "venue": "AAAI Conference on Artificial Intelligence",
    "fields_of_study": [
        "Computer Science"
    ],
    "citation_count": 0,
    "influential_citation_count": 0,
    "paper_content": "# How Many Lines to Paint the City: Exact Edge-Cover in Temporal Graphs\n\nArgyrios Deligkas1, Michelle D¨oring2, Eduard Eiben1, Tiger-Lily Goldsmith1, George Skretas2 Georg Tennigkeit2\n\n1Royal Holloway, University of London, Egham, United Kingdom 2Hasso Plattner Institute, University of Potsdam, Potsdam, Germany argyrios.deligkas@rhul.ac.uk, michelle.doering $@$ hpi.de, eduard.eiben $@$ rhul.ac.uk, tigerlily.goldsmith $@$ gmail.com, georgios.skretas $@$ hpi.de, georg.tennigkeit $@$ hpi.de\n\n# Abstract\n\nLogistics and transportation networks require a large amount of resources to realise necessary connections between locations and minimizing these resources is a vital aspect of planning research. Since such networks have dynamic connections that are only available at specific times, intricate models are needed to portray them accurately. In this paper, we study the problem of minimizing the number of resources needed to realise a dynamic network, using the temporal graphs model. In a temporal graph, edges appear at specific points in time. Given a temporal graph and a natural number $k$ , we ask whether we can cover every temporal edge exactly once using at most $k$ temporal journeys; in a temporal journey consecutive edges have to adhere to the order of time. We conduct a thorough investigation of the complexity of the problem with respect to four dimensions: (a) whether the type of the temporal journey is a walk, a trail, or a path; (b) whether the chronological order of edges in the journey is strict or non-strict; (c) whether the temporal graph is directed or undirected; (d) whether the start and end points of each journey are given. We almost completely resolve the complexity of these problems and provide dichotomies for each of them with respect to $k$ .\n\nExtended version — https://arxiv.org/abs/2408.17107\n\n# 1 Introduction\n\nNetworks are designed to enable the transportation of various “entities”, ranging from people and physical goods to data and information. Achieving efficient transportation requires the deployment of vehicles and connections, which most often are of limited quantity. Consequently, optimizing the use of these resources is a natural challenge in network planning and design. Take, for example, a train company that decided on optimal train connections to meet public demand. Next, the company has to decide on the number of trains to be deployed on a daily schedule to realize these connections effectively in order to maximize profit. This highlights the critical issue of how to allocate limited resources efficiently to meet operational goals while balancing cost and demand.\n\nThis issue is even more apparent in networks operated by multiple companies. In such scenarios, each company independently sets its own connection times between the depots based on various and individual criteria like public service needs, profits, and resource restrictions. Their main objective is to optimally ensure their connections at the designated time. However, such decentralized planning often leads to suboptimal use of resources. This issue has been identified by the Supply Chain Management and Logistics industries, which have observed that “while logistics improvements may be difficult for each individual customer, they can be realized with collaborative operation among multiple customers”1.\n\nTo illustrate, consider a scenario where company X wants to operate a line from A to B at 08:00, and from B to A at 20:00 and each connection takes one hour. Company Y wants to operate a line from B to C at 09:00, and from C to B at 17:00, also taking one hour each. Independently, both companies require one vehicle each to operate their respective lines. However, if they collaborated, they could share a vehicle for both lines with a single journey: A to B at 08:00, B to C at 09:00, C to B at 17:00, and B to A at 20:00.\n\n![](images/ab15332e8c285355c28ac632f232a2c5cddece983471522dd2562e94688e31b1.jpg)\n\nOptimizing network resources is important across various fields, each presenting unique complexities. This poses a dilemma: should we create a specific model for each scenario, or develop a generalized, possibly simplified model to study many scenarios at once? Applied research typically chooses the former, tailoring models to individual applications, while theoretical sciences favor the latter, aiming for generalized models with broad applicability.\n\nIn this paper, we follow the second route and provide a general model that is simple both, yet realistic enough to represent multiple scenarios. We want to study the problem of finding the minimum number of resources needed to realise the connections of a network. To account for the time-specific connections of the networks, we use temporal graphs (Kempe, Kleinberg, and Kumar 2002; Michail 2016). A temporal graph consists of a set of vertices, a set of edges and a labeling function indicating at which time steps each edge is available. A trip through a temporal graph, has to respect these time constraints.\n\nTable 1: Overview of our results. All parameterized results are with respect to parameter $k$ . The entry paraNP-hard indicates that NP-hardness holds even for constant $k$ , implying that no XP or FPT algorithm exists unless ${ \\mathsf { P } } = { \\mathsf { N P } }$ . The entry $\\mathtt { P } ^ { \\star }$ denotes the existence of a polynomial-time algorithm for special cases.   \n\n<html><body><table><tr><td>Complexity</td><td></td><td>Paths</td><td>Trails</td><td>Walks</td><td>Walks with fixed terminals</td></tr><tr><td rowspan=\"2\">directed edges</td><td> strict</td><td rowspan=\"4\">NP-c (k ≥ 3) (Thm. 4.1), paraNP-hard</td><td rowspan=\"4\">NP-c (k ≥ 3) (Cor. 4.3), paraNP-hard</td><td>P (Thm. 5.2)</td><td>P (Thm. 5.2)</td></tr><tr><td> non-strict</td><td>NP-c (Thm. 5.3), W[2]-hard, XP (Prop. 5.1)</td><td>P (Thm. 6.1)</td></tr><tr><td>strict undirected edges</td><td>XP (Prop. 5.1)</td><td> NP-c (Thm. 5.4), FPT open,</td><td>P* (Cor. 6.4)</td></tr><tr><td> non-strict</td><td>NP-c (Thm. 5.4), FPT open, XP (Prop. 5.1)</td><td></td><td>P (Thm. 6.3)</td></tr></table></body></html>\n\n# 1.1 Our Contribution\n\nOur contribution is twofold: (a) formalize the planning problem highlighted in the example above as an optimization problem on temporal graphs; (b) provide the landscape of its computational complexity for a rich variety of settings.\n\nThe Exact Edge-Cover. We study the following problem.\n\n“Given a temporal graph and a natural number $k$ , can we cover every temporal edge of the graph, exactly once, with at most $k$ temporal journeys?”\n\nMotivated by the variety of real-life scenarios our model can capture, we perform a thorough study with respect to four dimensions. First, the type of journey, which can be a temporal path, trail, or walk. This distinction is important as, for example, trains usually should not revisit a station in a single trip, which can only be modeled by a temporal path. Second, the temporal nature of the journey, which can be strict, or non-strict. In a strict journey, at most one temporal edge can be used per time step, while non-strict journeys can use multiple edges instantly. Third, the type of the graph, which can be either directed or undirected. Physical networks are usually directed, whereas information networks allow for bidirected connections. Fourth, having fixed or unfixed terminals for the journeys, i.e., whether the starting and ending points of the journeys are given or not. This captures that depots might be available only at specific locations in the network. A summary of our technical results is depicted at Table 1.\n\nOur Technical Results. The first part of our technical results focuses on the case where the terminals are not fixed. As a warm-up, we observe that when $k = 1$ , the problem resembles Eulerian journeys, and provide a linear time algorithm for all our settings. We extend our positive results to $k = 2$ , where we show that almost all versions of our problem can be reduced to a 2-SAT problem, enabling a polynomial-time solution. However, this approach fails for non-strict trails, in which the problem is NP-complete.\n\nFor $k \\geq 3$ , positive results become scarce. In Section 4, we study paths and trails, proving intractability for all versions of the problem for any constant $k$ . Furthermore, we show that no version can admit an $\\alpha$ -approximation for any constant $\\alpha$ unless ${ \\tt P } = { \\tt N P }$ . On the other hand, walks (Section 5) offer some positive results. We observe that when the number of walks $k$ is constant, all versions of our problem can be solved efficiently. For arbitrary $k$ , we additionally derive an efficient algorithm for the case of strict walks on directed graphs. Unfortunately, we complement the above by showing that every other version is NP-complete.\n\nThe second part of our technical results (Section 6) focuses on fixed terminals. Here, we are given a multiset of start points and a multiset of end points, where the multiplicity of a start (or end) point indicates the number of journeys that must start (or end) at that point. We begin by observing for paths and trails our hardness reductions hold even with fixed terminals. For walks, the situation is different. We provide a dynamic program for non-strict walks on directed graphs. On undirected graphs, the problem resembles a circulation flow. To capture the temporal aspect of the flow, we require a complex construction, making this the most technically involved result of the paper. The resulting algorithm solves the problem for non-strict walks. For strict walks, the algorithm works only when the labels at each vertex are distinct. Additionally, we provide a dynamic program for graphs where there are exactly $k$ or 0 edges per time step.\n\n# 1.2 Related Work\n\nThe minimum number of resources needed to realize a network has been studied in various contexts. For example, the minimum fleet size problem asks for the minimum number of vehicles needed to cover every trip in a network. Unlike our model, this problem is studied only on directed networks that can be modeled to contain no cycles and aims to cover every node rather than every edge (Vazifeh et al. 2018). Another example is the rolling stock problem, which asks for the minimum number of wagons needed to meet the passenger demand of a train network (Alfieri et al. 2006). Here, the train lines are given with a capacity demand on each connection that needs to be met. In contrast, our model is given individual connections (each with unit capacity) and aims to find the optimal train lines.\n\nThe study of edge covering problems on static graphs was initiated by Erdo¨s, Goodman, and Po´sa (1966) and La´szlo´ (1968). This led to an extensive line of work studying the minimum number of gadgets needed to cover the edges of a graph. The usual gadgets considered are cliques, cycles and paths. As far as paths are concerned, most research focuses on existential upper bounds. Chung (1980) conjectured that a graph can be covered with at most $\\textstyle { \\left\\lceil { \\frac { n } { 2 } } \\right\\rceil }$ paths, which was settled by Fan (2002). For an extensive overview of the covering problem on static graphs, we refer to (Schwartz 2022).\n\nFor temporal graphs, there has been a lot of research on reachability problems adjacent to ours (Zschoche 2023; Bilo\\` et al. 2022; Bilo\\` et al. 2022; Enright, Meeks, and Skerman 2021; Bentert et al. 2020; Bui-Xuan, Ferreira, and Jarry 2003; Deligkas et al. 2023). The most prominent one is the temporal exploration problem, where the goal is to compute an earliest-arrival walk visiting every vertex of the graph. It was introduced by Erlebach, Hoffmann, and Kammer (2021) and has been extensively studied since (Arrighi et al. 2023; Erlebach and Spooner 2023; Adamson et al. 2022).\n\nRecently, Bumpus and Meeks (2022), and Marino and Silva (2022) introduced an edge variant of this problem, where the goal is to decide whether the static edges of a temporal graph can be covered by an Eulerian circuit or trail. The main difference between their work and ours is that we want to cover every temporal edge, whereas they focus on covering every static edge. Additionally, they consider covering the edges with one trail, while we study an arbitrary number and different types of journeys. We highlight that no result can be transferred between the two models.\n\n# 2 Preliminaries\n\nFor $\\textbf { \\textit { n } } \\in \\textbf { \\textit { N } }$ , we denote $[ n ] \\ : = \\ \\{ 1 , 2 , . . . , n \\}$ . A temporal graph $\\mathcal { G } : = \\langle G , \\mathcal { E } \\rangle$ is defined by an underlying static graph $\\textit { G } = \\ : ( V , E )$ and a sequence of edge-sets $\\varepsilon \\ =$ $( E _ { 1 } , E _ { 2 } , \\dots , E _ { t _ { \\operatorname* { m a x } } } )$ with $E = E _ { 1 } \\cup E _ { 2 } \\cup \\cdot \\cdot \\cdot \\cup E _ { t _ { m a x } }$ . We refer to $E$ as the set of static edges of $\\mathcal { G }$ and to $\\mathcal { E }$ as the set of temporal edges. The lifetime of $\\mathcal { G }$ is $t _ { \\mathrm { m a x } }$ . An edge $\\textit { e } \\in \\textit { E }$ has label $i$ if $\\textit { e } \\in \\textit { E } _ { i }$ . We denote directed edges with $( ( u , v ) , t )$ and undirected edges with $( \\{ u , v \\} , t )$ . The edgestream representation $E _ { S }$ of $\\mathcal { G }$ is an ordered list of all temporal edges, sorted by increasing time label. By a snapshot $G _ { t }$ of $\\mathcal { G }$ we refer to the subgraph $( V , E _ { t } )$ containing only the edges available at time $t \\in [ t _ { \\operatorname* { m a x } } ]$ . The temporal degree $\\delta ( v )$ of a vertex $\\boldsymbol { v }$ denotes the number of temporal edges adjacent to $v$ . On directed graphs, we further define $\\delta ^ { i \\bar { n } } ( v )$ and $\\delta ^ { o u t } ( v )$ as the number of incoming and outgoing temporal edges of $v$ , respectively.\n\nTemporal Journeys. A temporal journey $J$ in $\\begin{array} { r l } { \\mathcal { G } } & { { } = } \\end{array}$ $\\langle ( V , \\bar { E } ) , \\mathcal { E } \\rangle$ is a sequence of adjacent temporal edges that respect time, connecting a start- with an end-terminal. Formally, if $J = \\left( \\left( e _ { 1 } , t _ { 1 } \\right) , \\ldots , \\left( e _ { \\ell } , t _ { \\ell } \\right) \\right)$ is a temporal journey, then for every $i \\in [ \\ell - 1 ]$ holds that: $e _ { i } \\in E _ { t _ { i } }$ ; $e _ { i }$ is adjacent to $e _ { i + 1 }$ ; and $t _ { i } \\leq t _ { i + 1 }$ . If we require that $t _ { i } < t _ { i + 1 }$ for all $i \\in [ \\ell - 1 ]$ , we call the journey strict, otherwise we call it non-strict. For a temporal journey $J$ , we denote by $J [ t _ { 1 } , t _ { 2 } ]$ the sub-journey between $t _ { 1 }$ and $t _ { 2 }$ , i.e., the sub-sequence of temporal edges $( e _ { i } , t _ { i } )$ of $J$ , such that $t _ { i } ~ \\in ~ [ t _ { 1 } , t _ { 2 } ]$ . If the temporal graph is directed, then we have directed journeys, otherwise, we have undirected journeys. We focus on three types of temporal journeys:\n\n• temporal walks, with no extra constraints;   \n• temporal trails, where no static edge is visited more than once by the journey;   \n• temporal paths, where no vertex is visited more than once by the journey.\n\nParameterized complexity. We refer to the standard books for a basic overview of parameterized complexity theory (Cygan et al. 2015; Downey and Fellows 2013). At a high level, parameterized complexity studies the complexity of a problem with respect to its input size, $n$ , and the size of a parameter $k$ . A problem is fixed parameter tractable by $k$ , if it can be solved in time $f ( k ) \\cdot \\mathtt { p o l y } ( n )$ , where $f$ is a computable function. Showing that a problem is $\\mathsf { W } [ 2 ]$ -hard rules out the existence of a fixed-parameter algorithm under the well-established assumption that $\\mathsf { w } [ 2 ] \\ne \\mathsf { F P T }$ .\n\n# 3 Exact Edge-Cover\n\nExact edge-covers by paths in static graphs have been studied by Donald (1980); Pyber (1991, 1996), where this structure is called an edge-disjoint path cover. We define the temporal generalization on different types of journeys.\n\nDefinition 3.1 (Temporal Exact Edge-Cover by Temporal Journeys). Let $\\mathcal { G } = \\langle ( V , E ) , \\mathcal { E } \\rangle$ be a temporal graph and $\\Phi \\in \\{ p a t h$ , walk, trail . A collection $\\mathcal { I } = \\{ J _ { 1 } , \\ldots , J _ { k } \\}$ of journeys of type $\\Phi$ , is called $a$ temporal exact edge-cover (eec) by $\\Phi$ for $\\mathcal { G }$ if for all temporal edges $\\boldsymbol { \\mathscr { e } } _ { \\mathbf { \\theta } } \\in \\mathcal { E }$ there is exactly one $J _ { i } \\in \\mathcal { I }$ with $e \\in J _ { i }$ .\n\nWe study the problem of finding temporal exact edgecovers of size $k$ by the (non-)strict version of each journey type in (un)directed temporal graphs. For $\\Phi \\in \\mathsf { \\Gamma }$ $\\{ \\mathrm { P A T H , T R A I L , W A L K } \\}$ , we define (N)S-TΦEEC as follows.\n\n# (NON-) STRICT TEMPORAL Φ EXACT EDGE-COVER\n\nInput: A temporal graph $\\mathcal { G }$ and $k \\in \\mathbb { N }$ . Question: Does there exist a temporal exact edgecover of (non-)strict $\\Phi$ for $\\mathcal { G }$ of size $\\boldsymbol { k ? }$\n\nChecking whether a given collection of journeys is an exact edge-cover can be done in polynomial time by verifying that each temporal edge appears exactly once and that all journeys are of type $\\Phi$ . Thus, (N)S-T $\\Phi$ EEC is in the class NP.\n\n# 3.1 One Journey – Extending Eulerian Journeys\n\nIf $k = 1$ , all versions of this problem can be solved in polynomial time. While our algorithm follows the same strategy for every journey type, the approach needs to differentiate depending on whether the journeys are strict or not.\n\nProposition 3.2 $( { \\star } )$ . For $\\Phi \\in \\{ \\mathrm { P A T H }$ , TRAIL, WALK , we can solve 1-(N)S-T $\\Phi$ EEC in polynomial time on both directed and undirected graphs.\n\nFor strict journeys, we attach the edges in temporal order and check whether this forms the desired journey. For nonstrict journeys, we additionally observe that a set of edges appearing at the same time has to form an Eulerian journey which can be found in polynomial time (Fleischner 1990).\n\n![](images/986c3d9d8d6999264761da66732b2169ba1895206baea25c2c2c035d335a9b32.jpg)  \nFigure 1: Illustration of the construction for the NP-hardness reduction in Thm. 4.1 for $k = 3$ . The two edges from $\\boldsymbol { v } ^ { h + 1 }$ to $c _ { 1 }$ connecting the assignment-gadget on the top and satisfaction-gadget on the bottom are drawn as two separate edges. With this, every drawn edge has exactly one time label increasing with the direction of the edges.\n\n# 3.2 Two Journeys – 2-SAT Approach\n\nWhile 2-(N)S-TPATHEEC, 2-S-TTRAILEEC and 2-(N)STWALKEEC are solvable in polynomial time for both directed and undirected graphs, we show that 2-NSTTRAILEEC is NP-hard on directed and undirected graphs.\n\nTowards the positive results, we utilize a polynomial-time algorithm for 2-SAT.\n\nIntuitively, as paths cannot revisit vertices we know that on directed temporal graphs every vertex can have at most two incoming and two outgoing edges, each covered by exactly one path. Now, if the temporal edges incident to a vertex are alternatingly incoming and outgoing [in-out-inout], we have to match the first in-edge with the first outedge. However, when both incoming edges appear before the outgoing edges [in-in-out-out], we can choose which in is matched with which out. This can be formalised via a 2-SAT formula with one variable for each vertex with in-in-out-out edge appearance and one clause for each vertex with in-out-in-out edge appearance. Setting a variable to True corresponds to the first path taking the earliest out-edge at that vertex and setting it to False corresponds to the first path taking the latest out-edge.\n\nTheorem 3.3 $( \\star )$ . 2-(N)S-TPATHEEC, 2-S-TTRAILEEC and 2-(N)S-TWALKEEC can be solved in polynomial time on directed and undirected temporal graphs.\n\nTo show hardness for non-strict trails, we adjust the proof of Marino and Silva (2022, Theorem 10). They show that EULERIAN TRAIL – finding a single temporal trail visiting all static edges of a temporal graph – is NP-hard.\n\nTheorem 3.4 $( { \\star } )$ . 2-NS-TTRAILEEC is NP-complete on both directed and undirected temporal graphs.\n\nHaving completely resolved our problem for one and two journeys, we now move on to the computational complexity of the general problem with $k$ at least 3. As we will see, for larger $k$ there is a divergence in the complexity of the problem for the three journey types, which, interestingly, is notably different from the behavior observed for $k = 2$ .\n\n# 4 Paths and Trails – Computational and Approximation Hardness for $k \\geq 3$\n\nWe prove that all versions of our problem are hard for both paths and trails, starting with intractability for paths, then augmenting the construction to get a strong inapproximability bound, and finally extending the results to trails.\n\nTheorem 4.1 $( { \\star } )$ . (N)S-TPATHEEC is NP-complete on directed and undirected temporal graphs, for every $k \\geq 3$ .\n\nProof sketch. All four constructions — (non-)strict paths on (un)directed graphs — follow the same idea, inspired by the SAT reduction in Klobas et al. (2023, Theorem 2). We outline the case of non-strict paths in directed graphs, which is the most concise construction, requiring just two time steps.\n\nWe reduce from $\\mathrm { N A E } ( k ) \\mathrm { S A } ^ { \\prime }$ T, which is known to be NPcomplete (Schaefer 1978). The input is a formula $\\varphi$ over $\\ell$ variables in conjunctive normal form where each clause contains exactly $k$ literals. The goal is to check whether the formula is satisfiable such that each clause has at least one literal that is True and one that is False.\n\nWe construct a temporal graph $\\mathcal { G }$ with an exact edge-cover of size $k$ if and only if $\\varphi$ is satisfiable; otherwise, the cover will require size $k + 1$ . See Figure 1 for an illustration.\n\nFor each variable $X _ { i }$ , we construct a variable-gadget with vertices $\\{ v ^ { i } , v ^ { i + 1 } \\} \\cup \\{ T _ { j } ^ { i } , F _ { j } ^ { i } \\colon j \\ \\in \\ [ \\ell ] \\}$ and edges $\\mathcal { E } _ { T } ^ { x _ { i } } =$ { $( v ^ { i } , T _ { 1 } ^ { i } , 1 ) \\} \\cup \\{ ( T _ { j } ^ { i } , T _ { j + 1 } ^ { i } , 1 ) \\colon j \\in [ \\ell - 1 ] \\} \\cup \\{ ( T _ { \\ell } ^ { i } , v ^ { i + 1 } , 1 ) \\}$ an $\\begin{array} { r } { \\begin{array} { l } { \\texttt { d } \\mathcal { E } _ { F } ^ { x _ { i } } \\ = \\ \\{ ( v ^ { i } , \\dot { F } _ { 1 } ^ { i } , 1 ) \\} \\cup \\{ ( F _ { j } ^ { i } , F _ { j + 1 } ^ { i } , 1 ) \\colon j \\ \\in \\ [ \\ell - 1 ] \\} } \\end{array} } \\end{array}$ $\\cup \\ \\{ ( F _ { \\ell } ^ { i } , v ^ { i + 1 } , 1 ) \\}$ . All variable-gadgets together form the assignment-gadget.\n\nLet $C _ { i }$ be a clause containing $k$ literals. For each literal $L _ { \\alpha }$ in $C _ { i }$ , let $X _ { \\alpha }$ be the corresponding variable. We construct a clause-gadget with vertices $\\{ c _ { i } , \\bar { c } _ { i + 1 } \\}$ and edges $\\{ ( c _ { i } , F _ { i } ^ { \\alpha } , 2 ) , ( F _ { i } ^ { \\alpha } , c _ { i + 1 } , 2 ) \\}$ for every positive literal $L _ { \\alpha } \\equiv X _ { \\alpha }$ and edges $\\{ ( \\stackrel { . } { c _ { i } } , T _ { i } ^ { \\stackrel { . } { \\alpha } } , 2 ) , ( T _ { i } ^ { \\alpha } , \\stackrel { . } { c _ { i + 1 } } , 2 ) \\}$ for every negative literal $L _ { \\alpha } \\equiv \\overline { { { X _ { \\alpha } } } }$ . All clause-gadgets together form the satisfaction-gadget. Lastly, we connect the assignment-gadget and the satisfaction-gadget by adding $\\{ ( v ^ { \\tilde { h } + 1 } , c _ { 1 } , \\breve { 1 } ) , ( v ^ { h + 1 } , c _ { 1 } , 2 ) \\}$ .\n\nIntuitively, the assignment-gadget is constructed out of two paths and the satisfaction-gadget is constructed out of $k$ paths. If $\\varphi$ is satisfiable and the two paths in the assignmentgadget are chosen correctly, then they will be extendable to cover two of the $k$ paths of the satisfaction-gadget. The remaining paths can be covered for free. If $\\varphi$ is not satisfiable, we will need to create an additional path no matter how the two paths in the assignment-gadget are chosen. □\n\nHardness of Approximation. Further extending this construction, we show that there cannot be a polynomial time algorithm that computes a constant $\\alpha$ -approximation of (N)STPATHEEC for $k \\geq 3$ , unless ${ \\mathsf { P } } = { \\mathsf { N P } }$ .\n\nWe do so by connecting a sufficient number of copies of the constructed $\\mathcal { G }$ via edges from the end-vertices of the $j ^ { \\mathrm { t h } }$ copy $v _ { j , i } ^ { \\mathrm { e n d } }$ to the start-vertices of the $j + 1 ^ { \\mathrm { t h } }$ copy vjsta+rt1,i, as illustrated in Figure 2 for NAE(3)SAT. Each copy increases the number of paths – necessary to cover all edges if $\\varphi$ is unsatisfiable – by one. If the number of copies is large enough, we would be able to correctly decide whether the $\\mathrm { \\tilde { N A E } } ( \\boldsymbol { \\bar { k } } ) \\mathrm { S A T }$ formula $\\varphi$ is satisfiable given an $\\alpha$ -approximation of (N)S-TPATHEEC.\n\nTheorem $4 . 2 \\ ( \\star )$ . For all $\\alpha > 1$ , there is no polynomial time $\\alpha$ -approximation algorithm for (N)S-TPATHEEC on directed and undirected temporal graphs unless ${ \\tt P } = { \\tt N P }$ .\n\nG1 。 2 Gc\n\nExtending Paths to Trails. It is straightforward to adjust both constructions such that covering clause-edges forces revisiting edges instead of revisiting vertices in the variablegadget. This implies the following.\n\nCorollary 4.3. (N)S-TTRAILEEC are NP-complete on directed and undirected temporal graphs. Corollary 4.4. For all $\\alpha > 1$ , there is no polynomial time $\\alpha$ -approximation algorithm for (N)S-TTRAILEEC on directed and undirected temporal graphs, unless ${ \\tt P } = { \\tt N P }$ .\n\n# 5 Walks – One Polynomial-Time Algorithm and Three Hardness Reductions for $k \\geq 3$\n\nWhen constructing exact edge-covers using temporal walks, we find a striking contrast to paths and trails: the problem remains polynomial-time solvable for any constant $k$ .\n\nProposition 5.1 $( { \\star } )$ . (N)S-TWALKEEC can be computed in time $\\mathcal { O } ( n ^ { \\mathcal { O } ( k ) } )$ which is polynomial for any constant $k$ .\n\nThis is due to the nature of temporal walks in exact edgecovers: they are time-respecting, connected journeys that cover each temporal edge exactly once. For a constant number $k$ , we can brute-force the start-terminals and, at each time step, keep track of all possible positions of the $k$ walks – there are at most $n ^ { k }$ such positions.\n\nFor an arbitrary size of the eec, the computational complexity varies depending on the variant of the problem. For strict walks on directed graphs, we can optimize the approach from Prop. 5.1, while the problem becomes NPcomplete for non-strict walks on directed graphs and for both strict and non-strict walks on undirected graphs.\n\n# 5.1 Strict Walks in Directed Graphs – Two Polynomial Time Approaches\n\nFor strict walks on directed graphs, the graph transformation introduced by Wu et al. (2014) forms a directed acyclic graph. We can adjust it so that a temporal walk eec in $\\mathcal { G }$ corresponds to an exact path cover (covering every vertex exactly once), which is computable in polynomial time.\n\nA faster (linear time) algorithm can be achieved by using the endpoint-tracking approach from Prop. 5.1. Since the walks are strict, two edges at the same time step need to be taken by two different walks, and since the graph is directed, the possible extensions are clearly defined. If an edge cannot extend an existing walk, a new walk starting with that edge has to be introduced. Furthermore, the starting points of the walks at the first time step are uniquely defined. This way, at each time step, there is exactly one possible position for walks of an exact edge-cover.\n\nTheorem 5.2 $( \\star )$ . S-TWALKEEC on directed temporal graphs can be solved in $\\mathcal { O } ( | \\mathcal { E } | )$ if the edgestream is given.\n\n# 5.2 Non-Strict Walks or Undirected Graphs – Hard to Compute Efficiently\n\nWe proceed with the complexity of the other three variants of walk exact edge-covers. For NS-TWALKEEC in directed graphs we prove W[2]-hardness and in undirected graphs we show that both (N)S-TWALKEEC are NP-hard.\n\nTowards the first result, observe that non-strict walks can traverse directed cycles appearing at one time step, unlike strict walks. Given such a directed cycle in which every edge has the same time label, any non-strict walk covering these edges must either omit some edges of the cycle or return to the vertex is started at. We exploit this behavior of returning to a chosen vertex to cover a cycle, for a reduction from $k$ - HITTING SET to NS-TWALKEEC on directed graphs.\n\nTheorem 5.3 $( \\star )$ . NS-TWALKEEC on directed temporal graphs is NP-complete and W[2]-hard when parameterized by the number of walks in the exact edge-cover.\n\nMoving on to undirected graphs, a walk must choose the direction of its starting edge. Using this choice as an assignment, we can construct a reduction from 3-SAT. The strict and non-strict variants require slightly different constructions but share the same idea: Each variable corresponds to an undirected edge at time step 1. Traversing that edge from left to right sets the variable to True, while traversing it from right to left, sets the variable to False.\n\nTheorem 5.4 $( \\star )$ . (N)S-TWALKEEC on undirected temporal graphs is NP-complete.\n\n# 6 Walks with Fixed Terminals – Polynomial Time Algorithms\n\nIn this section, we focus on exact edge-covers with fixed terminals. Observe that this also fixes the number of journeys (one journey per terminal pair), but we emphasize that this is not the same as having a constant number of journeys.\n\nIt is easy to see that our hardness constructions for paths and trails inherently fix the terminals, thereby translating directly. In contrast, for walks, we chose the terminals to simulate a Boolean assignment. This is not incidental, as having fixed terminals makes finding an eec with walks tractable.\n\n# 6.1 Directed Graphs\n\nStrict walks in directed graphs can be solved without fixing terminals using a dynamic program computing possible endpoints with increasing time. For non-strict walks with fixed terminals, this program can be adapted, as we avoid the issue of choosing the vertices to start on (in particular on a cycle). So, we initiate one walk per start-terminal and extend those at each time step, possibly by multiple edges.\n\nTheorem 6.1 $( { \\star } )$ . NS-TWALKEEC on directed temporal graphs can be solved in polynomial time if the startterminals along with their multiplicity are part of the input.\n\n# 6.2 Undirected Graphs\n\nIn undirected graphs, even with terminals, we must choose the direction of each temporal edge connecting two walks. This resembles the problem of finding a circulation flow.\n\nFor non-strict walks, this can be simulated in a static mixed multigraph, similar to the static expansion by Kostakos (2009), and solved via SWALKEEC with fixed terminals in polynomial time using a flow algorithm.\n\nTheorem ${ \\bf 6 . 2 \\ ~ ( \\star ) }$ . SWALKEEC with fixed terminals on static mixed multigraphs (containing directed and undirected multiedges) can be computed in polynomial time.\n\nLet us now state the main theorem of this section.\n\nTheorem 6.3 $( { \\star } )$ . NS-TWALKEEC on undirected temporal graphs can be computed in polynomial time if the startterminals along with their multiplicity are part of the input.\n\nProof sketch. Given a temporal graph $\\mathcal { G }$ and a set of terminals, we construct a mixed static multigraph $s$ with directed and undirected multiedges, and the same terminal sets. The construction will ensure that there is a temporal walk eec in $\\mathcal { G }$ if and only if there is a static walk eec in $s$ . The claim then follows from Thm. 6.2, which states that a static walk eec with fixed terminals can be computed in polynomial time.\n\nTerminals. For each start- and end-terminal at vertex $v$ , we add an additional vertex with a single edge to $v$ with a unique time label that is smaller, respectively larger, than all labels in $\\mathcal { G }$ . All other time labels are increased accordingly. Note that a vertex in $\\mathcal { G }$ can be a start and end of multiple walks, while at the constructed terminals there is exactly one walk starting or ending. From now, the term “vertices” will refer specifically to non-terminal vertices.\n\nConstruction. For each vertex $v$ , we create a $v$ -gadget simulating the connections of $v$ at the each time step. Let $T ( v )$ denote the multiset of labels on edges incident to $v$ . For each time step $t \\in T ( v )$ , create a vertex $\\boldsymbol { v } _ { t }$ . We say these vertices are placed from left to right by increasing time label. Now, we connect each $\\boldsymbol { v } _ { t }$ with its right neighbor $v _ { t + 1 }$ to simulate the maximum amount of walks going through $v$ time $t$ : Let $\\delta _ { \\leq t } ( v )$ and $\\delta _ { \\geq t + 1 } ( v )$ be the number of temporal edges incident to $v$ with time label $\\leq t$ and $\\geq \\ t + 1$ , respectively. The maximum amount of walks passing through has to enter before $t$ and leave after $t + 1$ . Thus, we create $\\operatorname* { m i n } ( \\delta _ { \\leq t } ( v ) , \\delta _ { \\geq t + 1 } ( v ) )$ edges between $\\boldsymbol { v } _ { t }$ and $\\boldsymbol { v } _ { t + 1 }$ . To allow some of these walks to enter before $t$ and also exit before $t$ , half of these edges rounded up are directed from $\\boldsymbol { v } _ { t }$ to $v _ { t + 1 }$ , while the others are undirected. A directed-undirected edge pair can then form a cycle attachable to any walk at $\\boldsymbol { v } _ { t }$ .\n\nFor each edge $( \\{ v , u \\} , t )$ in $\\mathcal { G }$ , we add $\\{ v _ { t } , u _ { t } \\}$ to $s$ , and for each terminal in $\\mathcal { G }$ connected to vertex $v$ , we add a terminal in $s$ with an edge to $\\scriptstyle v _ { 0 }$ . See Figure 3 for an illustration.\n\nTemporal eec in $\\mathcal { G }$ to static eec in $s$ . For every temporal walk $W$ , we construct a static walk with the same terminals: If $W$ sequentially traverses the edges $( \\{ a , v \\} , t )$ and $( \\{ \\boldsymbol { v } , \\boldsymbol { b } \\} , t ^ { \\prime } )$ , the corresponding static walk enters $v$ -gadget via $\\{ a _ { t } , v _ { t } \\}$ , travels $v _ { t } \\sim v _ { t ^ { \\prime } }$ using directed edges (or undirected, if no directed edges remain), and exits $v$ -gadget via $\\{ v _ { t ^ { \\prime } } , b _ { t ^ { \\prime } } \\}$ . Observe that there is a sufficient amount of edges between neighbouring vertices $\\boldsymbol { v } _ { t }$ and $\\boldsymbol { v } _ { t + 1 }$ so that every walk crossing these vertices can use a different edge.\n\nAfter translating the temporal walks into static walks this way, some edges between some $\\boldsymbol { v } _ { t }$ and its right neighbor $v _ { t + 1 }$ may remain unused. We show that this number is always even and the edges can be attached to existing walks: The number of edges between $\\boldsymbol { v } _ { t }$ and $v _ { t + 1 }$ equals the maximum walks possibly present in $\\boldsymbol { v }$ right at time $t$ , which is achieved when every undirected edge before $t$ is directed towards $v$ . If there is one less walk present, then this walk had to enter at $\\{ a _ { i } , v _ { i } \\}$ and exit at $\\{ v _ { j } , b _ { j } \\}$ , both before $t$ . Therefore, the walk which would have entered at $\\{ v _ { j } , b _ { j } \\}$ is also missing. Since directed edges are used before undirected edges, at least half of the remaining edges are undirected. These edges form a cycle going back and forth between $\\boldsymbol { v } _ { t }$ and $v _ { t + 1 }$ , which can be inserted into any walk visiting $\\boldsymbol { v } _ { t }$ .\n\nStatic eec in $s$ to temporal eec in $\\mathcal { G }$ . A static eec in $s$ cannot be directly translated into a temporal eec in $\\mathcal { G }$ . For a temporal eec, each walk must exit a vertex via a time label greater than the one by which it entered the vertex. In $s$ , this corresponds to every walk exiting a gadget to the right of its entry point, which is not guaranteed due to the undirected edges. Refer to Figure 4 (top) for an illustration of a walk violating this property. However, we can modify any static eec on $s$ to be time-respecting. The general idea is that any walk going “back in time” has to overlap with at least one walk with which it can swap suffixes. Refer to Figure 4 (bottom) for an illustration of such a swap, working as follows:\n\nLet $W _ { 1 }$ enter at $v _ { t _ { j } }$ and exit at $\\boldsymbol { v } _ { t _ { i } }$ with $t _ { i } < t _ { j }$ . Then it used an undirected edge $\\{ v _ { t _ { i + 1 } } , v _ { t _ { i } } \\}$ . By construction, there is at least one directed edge $( v _ { t _ { i } } , v _ { t _ { i + 1 } } )$ taken by some walk $W _ { 2 }$ that entered to the left of $\\boldsymbol { v } _ { t _ { i } }$ and exits to the right. Otherwise, by the parity argument for the edges, at least one edge between $\\boldsymbol { v } _ { t _ { i } }$ and $\\boldsymbol { v } _ { t _ { i + 1 } }$ would not be covered. We now swap the suffixes of $W _ { 1 }$ and $W _ { 2 }$ and therefore reduce the number of backwards taken edges by at least one. This is continued until no edges are taken backwards.\n\n![](images/81ba98736f4b3fe30ed4ad7bdfb65e68c2653173d78202d8eb82580a2e76b335.jpg)  \nFigure 3: Illustration of how a temporal graph $\\mathcal { G }$ (left) is translated into a static graph $s$ (right) for Thm. 6.3, with start-terminal $V _ { S } = \\{ s _ { 1 } , s _ { 2 } \\}$ and end-terminals $V _ { E } = \\{ e _ { 1 } , e _ { 2 } \\}$ . Vertices are replaced with gadgets based on their temporal degree.\n\n![](images/ad3fcf8103c96f382ad9156db9b6b0b8be733a8f6fe03b3129d555b068dacda3.jpg)  \nFigure 4: Suffix-switch between two walks $W _ { 1 }$ and $W _ { 2 }$ .\n\nFinally, we can translate the time-respecting static eec into a temporal eec by contracting the gadgets back into vertices.\n\nFor strict walks, this construction fails as it allows exact edge-covers which are valid for non-strict walks but invalid for strict walks and, unfortunately, it cannot be directly modified to handle such cases. However, on temporal graphs where adjacent edges are never present at the same time, every strict walk is inherently non-strict, allowing the algorithm to work. Such graphs are commonly referred to as proper temporal graphs (Casteigts, Corsini, and Sarkar 2024; Christiann, Sanlaville, and Schoeters 2024).\n\nCorollary 6.4. S-TWALKEEC with fixed terminals on proper undirected temporal graphs, i. e., $| N _ { t } ( v ) | \\in \\{ 0 , 1 \\}$ for all $t \\in \\mathsf { \\Gamma } [ t _ { \\mathrm { m a x } } ]$ , can be computed in polynomial time, where $N _ { t } ( v )$ is the multiset of neighbours of v at time step $t$ .\n\nLastly, we cover the other extreme of undirected temporal graphs with exactly $k$ or 0 edges per time step. Here, once again a dynamic program tracking possible walk endpoints is able to compute the eecs. This is possible because each walk must cover one edge per time step.\n\nTheorem ${ \\bf 6 . 5 \\ ( \\star ) }$ . S-TWALKEEC with fixed terminals $V _ { S }$ , $V _ { E }$ on undirected temporal graphs where $| E _ { t } | \\in \\{ 0 , k \\}$ for all $t \\in [ t _ { \\operatorname* { m a x } } ] ;$ , can be computed in time $\\mathcal { O } ( 2 ^ { | V _ { S } | } \\cdot | V _ { S } | \\cdot t _ { \\operatorname* { m a x } } )$ .\n\nFor temporal graphs with an arbitrary number of edges per time step, the complexity of S-TWALKEEC with fixed terminals remains an open question.\n\n# 7 Conclusion\n\nWe introduce exact edge-covers (eecs) on temporal graphs with three journey variants: paths, trails and walks, aiming to capture the subclass of temporal graphs that model realworld transit networks. We provide a comprehensive analysis of the computational complexity of the eec problem and observe fundamental differences between covering with paths/trails and covering with walks.\n\nSeveral open problems remain, motivated by both theory and practical considerations. On the theoretical side, it would be interesting to explore whether walk eecs can be approximated and to resolve the open case for strict walks on undirected graphs with fixed terminals. Additionally, for paths, we observed that eecs are efficiently computable on DAGs and bidirected trees. So, an open question is to classify the subclasses of graphs for which these generally hard problems are polynomial-time solvable. Designing efficient algorithms for paths and trails with parameters arising from real-life applications is also an important direction.\n\nOn the applied side, several variants of the model could be explored. Our focus was on the exact covering version of the problem, as it captures scenarios where a connection cannot be used by multiple vehicles at the same time, such as railroads, where only one train can occupy a track at a time. Additionally, studying the exact version implicitly minimizes the resources, like fuel, needed to satisfy the connections. However, the non-exact case is also interesting to explore. While our negative results still apply, the algorithms would need significant adjustments or entirely new approaches.\n\nA completely different, and “complementary”, direction is to consider that the underlying temporal graph is provided as a collection of “few” temporal journeys and study scheduling and other combinatorial problems on this class of graphs. This natural parameter which, to the best of our knowledge, has not been studied yet, defines a structured family of temporal graphs. Can this parameter allow for efficient algorithms in temporal graphs? If yes, then this will be a very positive exception in the literature.\n\n# Acknowledgments\n\nMichelle Do¨ring was supported by the German Federal Ministry for Education and Research (BMBF) through the project “KI Servicezentrum Berlin Brandenburg” (01IS22092). Georg Tennigkeit was supported by the HPI Research School on Data Science and Engineering. Argyrios Deligkas was supported by EPSRC Grant EP/X039862/1 “NAfANE: New Approaches for Approximate Nash Equilibria”.",
    "institutions": [
        "Royal Holloway, University of London",
        "Hasso Plattner Institute, University of Potsdam"
    ],
    "summary": "{\n  \"core_summary\": \"### 核心概要\\n\\n**问题定义**\\n论文旨在解决使用时间图模型最小化实现动态网络所需资源数量的问题。在物流和运输网络中，资源通常是有限的，如何有效分配这些资源以实现高效运输，同时平衡成本和需求，是网络规划和设计中的关键挑战。特别是在多公司运营的网络中，分散规划往往导致资源利用效率低下，因此该问题具有重要的实际意义。\\n\\n**方法概述**\\n论文对“给定时间图和自然数 $k$，能否用最多 $k$ 个时间旅程恰好覆盖图中的每个时间边一次”这一问题，从四个维度（旅程类型、时间顺序严格性、图的类型、旅程起止点是否固定）进行了全面的复杂性研究，并针对不同情况提供了相应的算法和复杂度分析。\\n\\n**主要贡献与效果**\\n- 形式化了规划问题，将其作为时间图上的优化问题，并几乎完全解决了所研究问题的复杂性，针对每个维度提供了关于 $k$ 的二分法。例如，对于 $k = 1$ 的情况，提供了线性时间算法；对于 $k = 2$ 的情况，多数版本问题可通过转化为 2 - SAT 问题在多项式时间内解决，但 2 - NS - TTRAILEEC 在有向和无向图上是 NP 完全问题。\\n- 证明了对于 $k \\geq 3$ 的路径和轨迹问题，所有版本均为 NP 完全问题，且不存在常数 $\\alpha$ - 近似算法，除非 ${ \\tt P } = { \\tt N P }$。\\n- 对于步行问题，当 $k$ 为常数时可在多项式时间内求解；对于严格步行在有向图中的情况，可在 $\\mathcal{O}(|\\mathcal{E}|)$ 时间内求解；非严格步行在有向图中可在多项式时间内求解，在特定无向图（如满足一定条件的非严格步行和严格步行情况）中也提供了多项式时间算法。\",\n  \"algorithm_details\": \"### 算法/方案详解\\n\\n**核心思想**\\n通过对时间图上的精确边缘覆盖问题进行多维度分析，利用不同类型的时间旅程和图的特性，结合计算复杂度理论，研究在不同条件下问题的可解性和复杂度。核心思想是通过对时间图中时间旅程的类型、时间顺序、图的方向以及旅程起止点等多个维度进行分类研究，利用不同的算法策略来解决精确边覆盖问题。其有效性在于对问题进行了细致的分类和分析，针对不同情况采用了合适的算法策略。\\n\\n**创新点**\\n先前的工作主要集中在静态图的边覆盖问题，或者是特定类型的网络资源优化问题（如最小车队规模问题、机车车辆问题等），且与本文研究的问题存在差异，如覆盖目标不同（节点或边）、图的类型不同（静态或时间图）等。本文针对时间图，考虑了更复杂的动态连接情况，对问题进行了更全面的多维度研究，并提供了丰富的复杂度结果。\\n\\n**具体实现步骤**\\n1. 定义时间图和时间旅程的相关概念，明确精确边缘覆盖问题。\\n2. 对 $k = 1$ 的情况，根据旅程是否严格，分别采用不同策略在多项式时间内求解。对于严格旅程，按时间顺序连接边缘检查是否形成所需旅程；对于非严格旅程，检查同一时间出现的边缘是否形成欧拉旅程。\\n3. 对 $k = 2$ 的情况，利用 2 - SAT 算法解决 2 - (N)S - TPATHEEC、2 - S - TTRAILEEC 和 2 - (N)S - TWALKEEC 问题，证明 2 - NS - TTRAILEEC 在有向和无向图上是 NP 完全问题。\\n4. 对于 $k \\geq 3$ 的情况：\\n    - 对于路径和轨迹，证明所有版本问题都是 NP 完全的，且不存在常数 $\\alpha$ - 近似算法，除非 ${ \\tt P } = { \\tt N P }$。\\n    - 对于步行，当 $k$ 为常数时，可在 $\\mathcal{O}(n^{\\mathcal{O}(k)})$ 时间内求解；对于严格步行在有向图中的情况，可通过图变换或端点跟踪方法在 $\\mathcal{O}(|\\mathcal{E}|)$ 时间内求解；非严格步行在有向图中证明为 NP 完全且 W[2] - 难，在无向图中（N)S - TWALKEEC 为 NP 完全问题。\\n5. 对于固定端点的情况：\\n    - 对于路径和轨迹，硬度结果仍然成立。\\n    - 对于步行，在有向图中为非严格步行提供动态规划算法；在无向图中，针对非严格步行通过构建静态混合多图将问题转化为可在多项式时间内求解的问题；对于严格步行，在特定条件（如相邻边不同时出现的无向图和每个时间步有 $k$ 或 0 条边的无向图）下提供解决方案。\\n\\n**案例解析**\\n论文中给出了公司运营线路的例子，公司 X 想在 08:00 从 A 到 B，20:00 从 B 到 A；公司 Y 想在 09:00 从 B 到 C，17:00 从 C 到 B。独立运营时两公司各需一辆车，而合作时可共用一辆车完成旅程，体现了资源优化的重要性。另外，在证明 (N)S - TPATHEEC 的 NP 完全性时，通过从 $\\mathrm{NAE}(k)\\mathrm{SA}^{\\prime}\\mathrm{T}$ 问题归约，构建时间图说明若公式 $\\varphi$ 可满足，则图有大小为 $k$ 的精确边缘覆盖；否则需要大小为 $k + 1$ 的覆盖。\",\n  \"comparative_analysis\": \"### 对比实验分析\\n\\n**基线模型**\\n论文未明确提供此部分信息\\n\\n**性能对比**\\n论文未明确提供此部分信息\",\n  \"keywords\": \"### 关键词\\n\\n- 时间图 (Temporal Graphs, N/A)\\n- 精确边覆盖 (Exact Edge - Cover, N/A)\\n- 计算复杂性 (Computational Complexity, N/A)\\n- 网络资源优化 (Network Resource Optimization, N/A)\\n- 时间旅程 (Temporal Journeys, N/A)\"\n}"
}