{
    "source": "Semantic Scholar",
    "arxiv_id": "2504.16837",
    "link": "https://arxiv.org/abs/2504.16837",
    "pdf_link": "https://arxiv.org/pdf/2504.16837.pdf",
    "title": "Approximating Optimal Labelings for Temporal Connectivity",
    "authors": [
        "Daniele Carnevale",
        "Gianlorenzo D'Angelo",
        "Martin Olsen"
    ],
    "publication_date": "2025-04-11",
    "venue": "AAAI Conference on Artificial Intelligence",
    "fields_of_study": [
        "Computer Science"
    ],
    "citation_count": 0,
    "influential_citation_count": 0,
    "paper_content": "# Approximating Optimal Labelings for Temporal Connectivity\n\nDaniele Carnevale1, Gianlorenzo D’Angelo1, Martin Olsen2\n\n1Gran Sasso Science Institute, L’Aquila, Italy 2Aarhus University, Aarhus, Denmark daniele.carnevale@gssi.it, gianlorenzo.dangelo@gssi.it, martino@btech.au.dk\n\n# Abstract\n\nIn a temporal graph the edge set dynamically changes over time according to a set of time-labels associated with each edge that indicates at which time-step the edge is available. Two vertices are connected if there is a path connecting them in which the edges are traversed in increasing order of their labels. We study the problem of scheduling the availability time of the edges of a temporal graph in such a way that all pairs of vertices are connected within a given maximum allowed time $a$ and the overall number of labels is minimum.\n\nThe problem, called Minimum Aged Labeling (MAL), has several applications in logistics, distribution scheduling, and information spreading in social networks, where carefully choosing the time-labels can significantly reduce infrastructure costs, fuel consumption, or greenhouse gases.\n\nProblem MAL has previously been proved to be NP-complete on undirected graphs and APX-hard on directed graphs. In this paper, we extend our knowledge on the complexity and approximability of MAL in several directions. We first show that the problem cannot be approximated within a factor better than $O ( \\log n )$ when $a \\ \\geq \\ 2$ , unless ${ \\mathrm { ~ \\bf ~ P ~ } } = { \\mathrm { ~ \\bf ~ N P ~ } }$ , and a factor better than $2 ^ { \\log ^ { 1 - \\epsilon } n }$ when $\\textbf { \\textit { a } } \\geq \\textbf { \\textit { 3 } }$ , unless $\\mathsf { N P \\subseteq }$ $\\mathrm { D T I M E } ( 2 ^ { \\mathrm { p o l y l o g } ( n ) } )$ , where $n$ is the number of vertices in the graph. Then we give a set of approximation algorithms that, under some conditions, almost match these lower-bounds. In particular, we show that the approximation depends on a relation between $a$ and the diameter of the input graph.\n\nWe further establish a connection with a foundational optimization problem on static graphs called Diameter Constrained Spanning Subgraph (DCSS) and show that our hardness results also apply to DCSS.\n\n# Introduction\n\nWe consider a scheduling problem on dynamic networks that is motivated by several applications in logistics, distribution scheduling, and information diffusion in social networks.\n\nAs a real-world example, consider a parcel-delivery scenario where there is a warehouse $W$ serving three cities as the center of a star topology, see Figure 1 for an illustration. Each city has a bunch of parcels to be delivered to the other cities and for each pair of cities $( A , B )$ there is at least one parcel that must be delivered from $A$ to $B$ . In each city $A$\n\nA A A 7am;9am 6am;7am 6am;8am W QW OW 7am;8am 6am;8am 6am;7am 6am;7am 7am 6am;8am B C B C B C 1st schedule 2nd schedule 3rd schedule\n\nthere is a vehicle that is used to deliver the parcels from its home city $A$ to the warehouse and vice-versa. Each vehicle can possibly depart from its home city at every hour and, once the vehicle reaches $W$ , it deposit the parcels and then comes back to its home city. A travel of a vehicle from its own town to $W$ and back is called a trip. For simplicity, we assume that the travel time is negligible. When a vehicle $V _ { 1 }$ moves from city $A$ to the the warehouse $W$ , it deposits in $W$ all the parcels that departs from $A$ and whose final destination is any of the other cities and then comes back to its home city $A$ . When a vehicle $V _ { 2 }$ returns to its home city $B$ it brings to $B$ all the parcels that have been deposited in $W$ so far and whose final destination is $B$ . If the trip of $V _ { 1 }$ is scheduled earlier than that of $V _ { 2 }$ , the parcels directed from $A$ to $B$ are delivered. Otherwise, they must wait for the next trip. Carefully scheduling the trips of all vehicles might reduce at the same time the delivery time and the costs in terms of number of required trips, fuel consumption, pollutants, and emission of greenhouse gasses. For example, the $1 ^ { \\mathrm { s t } }$ schedule in Figure 1, requires 6 trips to deliver all parcels and the last parcels are delivered at 9am. The $2 ^ { \\mathrm { n d } }$ schedule optimizes the latest arrival time and ensures that the last parcels are delivered two hours earlier than the previous solution, at 7am, but still requires 6 trips to deliver all parcels. The $3 ^ { \\mathrm { r d } }$ schedule, instead optimizes the required number of trips, reducing them to 5, but the last parcels are delivered at 8am, one hour later than the previous case.\n\nThe problem of scheduling trips becomes much more complex if we consider a general network in which each vertex might serve both as a warehouse and as a city, and connections among vertices are given by an arbitrary underlying graph. Moreover, similar problems arise in other contexts such as distribution scheduling (Deligkas and Potapov 2020) and information spreading, where the aim is to schedule a small number of meetings among employees of a company in such a way that each employee can share its own information with any other by a given time, see (Deligkas, Eiben, and Skretas 2023).\n\nMotivated by these applications, we consider the following question: What is the minimum number of trips needed to deliver all parcels within a given time?\n\nWe model a schedule of trips along edges of a network with a temporal graph (a.k.a. dynamic graph) in which the scheduling time of a vehicle is represented as an edge-label and a path in a graph is valid (or temporal) only if the edges are traversed in increasing order of their labels. We then consider the optimization problem of assigning the minimum number of labels to the edges of a graph in such a way that each pair of vertices is connected via a temporal path and the largest label is not greater than a given integer $a$ , called the maximum allowed age. This problem, called Minimum Aged Labeling (MAL), has been introduced by Mertzios, Michail, and Spirakis (2019), who proved that it is APX-hard in directed graphs. Later, Klobas et al. (2024) showed that MAL is NP-complete also for undirected graphs. To the best of our knowledge, there are no hardness or algorithmic results on the approximation of MAL in undirected graphs. Moreover, the reduction used to prove the APX-hardness in directed graphs (Mertzios, Michail, and Spirakis 2019) cannot be easily adapted to undirected graphs as in the constructed graph the direction of edges is used to bound the reachability of vertices. In this paper, we study the complexity of approximating MAL in undirected graphs showing when, depending on a relation between $a$ and the diameter $D _ { G }$ of the input graph, it is hard to approximate, or it can be approximated in polynomial time.\n\nMAL also has a theoretical motivation as it can be interpreted as a dynamic version of a foundational graph theoretical problem called the Diameter Constrained Spanning Subgraph (DCSS) problem, which asks to find a spanning subgraph $H$ of a graph $G$ such that the diameter of $H$ is at most a given integer and its number of edges is minimum.\n\nOur results. We provide both hardness of approximation lower-bounds and approximation algorithms for MAL.\n\nHardness of approximation. We first prove that, even when the maximum allowed age $a$ of a labeling is a fixed value greater or equal to 2, MAL cannot be approximated within a factor better than $O ( \\log n )$ , unless $\\mathbf { P } = \\mathbf { N P }$ . Then, we show that, unless $\\mathsf { N P } \\subseteq \\mathrm { D T I M E } ( 2 ^ { \\mathrm { p o l y l o g } ( n ) } )$ , we cannot find any $2 ^ { \\log ^ { 1 - \\epsilon } n }$ -approximation algorithm for MAL, even when $a$ is a fixed value greater or equal to 3 and $\\epsilon \\in ( 0 , 1 )$ .\n\nThese results advance our knowledge on the computational complexity of MAL in two directions. (1) From an exact computation point of view, the NP-hardness given in (Klobas et al. 2024) only holds for $a = D _ { G } = 1 0$ , while we show that MAL is NP-hard for any fixed $a \\geq 2$ (still, we require $a = D _ { G }$ ). This closes the characterization of the computational complexity of MAL with respect to the parameter $a$ , as the case $a = 1$ is trivial. Moreover, we provide a considerably simpler reduction than the one in (Klobas et al. 2024). (2) From an approximation point of view, the reduction in (Mertzios, Michail, and Spirakis 2019) shows that MAL is APX-hard for $a = D _ { G } = 9$ in directed graphs. We show two stronger lower-bounds on the approximation, namely that MAL is hard to approximate better than a logarithmic factor, under ${ \\bf P } \\neq { \\bf N P }$ , and a factor $2 ^ { \\log ^ { 1 - \\epsilon } n }$ , under a stronger complexity condition. The second lower-bound suggests that it is unlikely to approximate MAL to a factor better than a polynomial. Moreover, our lower-bounds hold even for any fixed $a \\geq 2$ and for $a \\geq 3$ , resp., and for undirected graphs (again, we require $a = D _ { G }$ ). Finally, we remark that our lower-bounds also apply to DCSS.\n\nApproximation algorithms. Like in (Klobas et al. 2024) and (Mertzios, Michail, and Spirakis 2019), all our reductions require that $a = D _ { G }$ . Hence, we investigate the approximability of MAL when $a \\geq D _ { G }$ , addressing an open question posed in (Klobas et al. 2024). We give three sets of results, which interestingly show how the approximation of MAL depends on a relation between $a$ and $D _ { G }$ .\n\n(1) We first consider the case in which $a$ is sufficiently larger than $R _ { G }$ , the radius of $G$ . If $a \\geq 2 R _ { G }$ $\\mathop { ( a ) } \\geq 2 R _ { G } + 1$ , resp.), we can compute in polynomial time a solution that requires at most only 2 labels (1 label, resp.) more than the optimum. Observe that these additive approximation bounds correspond to asymptotic multiplicative bounds with approximation factors that arbitrarily approach 1 as the input size grows. Moreover, if $a \\ge 2 D _ { G } + 2$ , we can compute an optimal solution in polynomial time. As MAL does not admit any feasible solution when $a < D _ { G }$ , this first set of results leaves open the cases when $D _ { G } \\leq a < 2 R _ { G }$ .\n\n(2) We then consider the case in which $a$ is slightly larger than $D _ { G }$ by exploiting a relation between MAL and DCSS. Specifically, we show that there is a gap of a factor $a$ between the approximation of MAL and that of DCSS. We first prove that when $a = D _ { G } = 2$ , MAL can be approximated with a logarithmic factor, which asymptotically matches our first hardness lower-bound.1 When $a \\ge D _ { G } + 2$ , we achieve an approximation factor of $O ( D _ { G } \\cdot n ^ { 1 / 2 } )$ , which is sublinear when $D _ { G }$ is sufficiently small. Moreover, if $a \\ge D _ { G } + 4$ or $a ~ \\ge ~ { \\cal D } _ { G } + 6$ , we reduce the approximation factor to $O ( D _ { G } \\cdot n ^ { 2 / 5 } )$ and $O ( D _ { G } \\cdot n ^ { 1 / 3 } )$ , respectively. Finally, for any value of $a \\ge D _ { G }$ we achieve an approximation factor of $O ( D _ { G } \\cdot n ^ { 3 / 5 + \\epsilon } )$ , for any $\\epsilon > 0$ . All these approximation factors linearly depend on $D _ { G }$ , due to the gap between the approximation of MAL and that of DCSS.\n\n(3) Our main algorithmic contribution consists in approximating MAL when $D _ { G } ~ \\leq ~ a ~ < ~ 2 R _ { G }$ without passing through DCSS, thus avoiding a linear dependency on $D _ { G }$ in the approximation ratio. We show that when $a \\ge \\lceil 3 / 2 \\cdot D _ { G } \\rceil$ $( a ~ \\ge ~ \\lceil 5 / 3 ~ \\cdot ~ D _ { G } \\rceil$ , resp.), then we can approximate MAL within a factor of $O ( \\sqrt { n \\log n } ) \\ ( O ( \\sqrt [ 3 ] { D _ { G } n \\log ^ { 2 } n } )$ , resp.). Both bounds are sublinear, and the second algorithm outperforms the first one when $D _ { G } = o ( \\sqrt { n / \\log n } )$ but requires greater values of $a$ .\n\nDue to space constraints, some proofs are deferred to the full version of the paper.\n\nRelated Work. Due to their versatility, temporal graphs have been considered from several perspectives and using different terminology, e.g. dynamic, evolving, and timevarying graphs or networks, see (Michail 2016). Mainly motivated by virus-spread minimization (see e.g. (Braunstein and Ingrosso 2016; Enright and Kao 2018)), an area that received considerable interest is the one related to the modification of a temporal network in such a way that some objective is optimized (see a recent survey (Meeks 2022)). Several operations were considered e.g. delaying labels and merging consecutive times (Deligkas and Potapov 2020), edgedeletion and label-deletion (Enright et al. 2021), and changing the relative order of times (Enright, Meeks, and Skerman 2021). Moreover, (Molter, Renken, and Zschoche 2024) studied how the choice between edge-deletion and delaying influences the parameterized complexity of the reachabilityminimization objective. In (Deligkas, Eiben, and Skretas 2023), the authors studied a problem similar but orthogonal to MAL in which one wants to minimize the maximum time a subset of vertices requires to reach every vertex, by shifting labels. Klobas et al. (2024), also considered a generalization of MAL where only a subset of terminal vertices must be connected, subject to a constraint on the maximum allowed age, and show that the problem is $W [ 1 ]$ -hard when parameterized by the number of labels.\n\n# Preliminaries\n\nFor an integer $k \\in \\mathbb { N }$ , let $[ k ] : = \\{ 1 , 2 , \\dots , k \\}$ and $[ k ] _ { 0 } : =$ $\\{ 0 \\} \\cup [ k ]$ . We consider simple undirected graphs $G = ( V , E )$ with $n = | V |$ vertices and $m = | E |$ edges. We also use $V ( G )$ and $E ( G )$ to refer to the vertex set and the edge set of the graph $G$ , respectively. We denote an edge $e \\in E$ between two vertices $\\boldsymbol { v }$ and $w$ with $\\boldsymbol { e } = \\{ v , w \\}$ , and say that $v$ and $w$ are the endpoints of $e$ . A subgraph $\\dot { H } = ( V ^ { \\prime } , E ^ { \\prime } )$ of a graph $G$ , written as $H \\subseteq G$ , is a graph whose vertex set $V ^ { \\prime }$ and edge set $E ^ { \\prime }$ are subsets of $V ( G )$ and $E ( G )$ respectively, with the additional constraint that if $\\{ v , w \\} \\in E ^ { \\prime }$ then $v , w \\in V ^ { \\prime }$ . If $V ^ { \\prime } = V$ and it is connected, then the subgraph $H$ is said to be a spanning subgraph.\n\nA path $P$ between vertices $v$ and $w$ in graph $G$ is a sequence of distinct vertices $v _ { 0 } , v _ { 1 } , \\dotsc , v _ { k } \\in V$ and sequence of distinct edges $\\{ v _ { i } , v _ { i + 1 } \\} \\ \\in \\ E$ , for each $i \\in [ k \\bar { \\textrm { -- } } 1 ] _ { 0 }$ , where $v _ { 0 } = v$ and $v _ { k } = w$ . The length of $P$ is equal to the number of its edges, i.e. $k$ . A shortest path is a path with minimum length. The distance between two vertices $v$ and $w$ in the graph $G$ is denoted $d _ { G } ( v , w )$ and is equal to the length of a shortest path between $v$ and $w$ . Let $S \\subseteq V$ , we denote by $d _ { G } ( v , S )$ the distance between $v$ to its closest vertex in $S$ , i.e. $\\begin{array} { r } { d _ { G } ( v , S ) = \\operatorname* { m i n } _ { s \\in S } d _ { G } ( v , s ) } \\end{array}$ . A graph $G$ is connected if there exists a path between any pair of vertices.\n\nA Shortest Path Forest (SPF) $F$ rooted at some set of vertices $S \\subseteq V$ is a forest spanning all vertices $V$ such that $d _ { F } ( w , S ) = d _ { G } ( w , S )$ , for each $w \\in V ( G )$ . If $S$ is a singleton, $S = \\{ v \\}$ , a SPF rooted at $S$ is called a Shortest Path Tree (SPT) rooted at $v$ .\n\nGiven a vertex $v \\in V$ , the eccentricity $\\csc _ { G } ( v )$ of $v$ in $G$ is the maximum distance between $v$ and any other vertex, i.e. $\\begin{array} { r } { \\operatorname { e c c } _ { G } ( v ) = \\operatorname* { m a x } _ { w \\in V } d _ { G } ( v , w ) } \\end{array}$ . The diameter and radius of $G$ are defined as $D _ { G } = \\operatorname* { m a x } _ { v \\in V } \\csc _ { G } ( v )$ and $R _ { G } \\ =$ $\\mathrm { m i n } _ { v \\in V } \\operatorname { e c c } _ { G } ( v )$ , respectively. We say that a vertex $v$ is a center of a graph $G$ if $\\csc _ { G } ( v ) = R _ { G }$ .\n\nWe will drop the subscript $G$ in the notation when the graph in question is clear from the context.\n\nA temporal graph is a pair $( G , \\lambda )$ where $G$ is a graph and $\\lambda : E \\longrightarrow 2 ^ { \\mathbb { N } \\setminus \\{ 0 \\} }$ is a function assigning to every edge of $G$ a set of discrete labels that we interpret as presence in time. The lifetime (a.k.a. age) $L _ { \\lambda }$ of a temporal graph $( G , \\lambda )$ is the largest label in $\\lambda$ i.e. $L _ { \\lambda } = \\operatorname* { m a x } \\{ t : t \\in \\lambda ( e ) , e \\in$ $E \\}$ . The total number of labels in a temporal graph is $| \\lambda | =$ $\\textstyle \\sum _ { e \\in E } | \\lambda ( e ) |$ .\n\nOne central notion in temporal graphs is that of a temporal path, in this paper we will use a definition often called a strict temporal path. A temporal path is a sequence $( e _ { 1 } , t _ { 1 } ) , ( e _ { 2 } , t _ { 2 } ) , \\hat { , } . . . , ( e _ { k } ^ { - } , t _ { k } )$ where $e _ { 1 } , e _ { 2 } , \\ldots , e _ { k }$ is a path in $G$ , $t _ { i } \\in \\lambda ( e _ { i } )$ for every $i \\in [ k ]$ , and $t _ { 1 } < t _ { 2 } < \\cdots < t _ { k }$ . We say that a vertex $v$ is temporally reachable from a vertex $w$ if there exists a temporal path from $w$ to $v$ . A temporal graph is called temporally connected if every vertex is temporally reachable from every other vertex.\n\nWe are ready to introduce the Minimum Aged Labelling (MAL) problem, which is the subject of this paper.\n\nDefinition 1. Given a graph $G = ( V , E )$ and an integer $a$ , the Minimum Aged Labelling (MAL) problem asks to find $a$ function $\\lambda : E \\to 2 ^ { \\mathbb { N } }$ such that $( G , \\lambda )$ is temporally connected, $L _ { \\lambda } \\leq a _ { ; }$ , and $| \\lambda |$ is minimum.\n\nWe assume that the graph $G$ is connected as otherwise MAL does not admit any feasible solution. The same holds if $a ~ < ~ D _ { G }$ , as already observed in (Klobas et al. 2024). On the other hand, if $a \\ge 2 D _ { G } + 2$ , then MAL is solvable in polynomial time as we will prove in Theorem $_ { 7 - ( i i i ) }$ by using a result from (Klobas et al. 2024). Hence, we will consider in the rest of the paper the case $D _ { G } \\leq a \\leq 2 D _ { G } + 2$ .\n\nA problem that is strictly related to MAL is the Diameter Constrained Spanning Subgraph (DCSS) problem.\n\nDefinition 2. Given a graph $G$ and an integer $d \\geq D _ { G }$ , the DCSS problem asks to find a spanning subgraph $H$ such that $D _ { H } \\leq d$ and the number of edges of $H$ is minimum.\n\nThere is a close connection between problems DCSS and MAL. Roughly, MAL can be seen as a temporal version of the DCSS problem. The next theorem relates the approximations of MAL and DCSS.\n\nTheorem 1. Let $G$ be a graph and b be an integer such that $b = O ( | V ( G ) | )$ .\n\ni) If there exists an $\\alpha$ -approximation algorithm for MAL, then there exists an $( \\alpha b )$ -approximation algorithm for DCSS, where $( G , b )$ is the input to DCSS.\n\nii) If there exists an $\\alpha$ -approximation algorithm for DCSS, then there exists an $( \\alpha b )$ -approximation algorithm for MAL, where $( G , b )$ is the input to MAL.\n\nTo the best of our knowledge the DCSS problem appeared, in a slightly different form, only in (Elkin and Peleg 2001). However, few other known optimization problems generalize DCSS and hence we can exploit the approximation algorithms known for these problems also for DCSS. In the following we summarize the approximation bounds that we can obtain by reducing DCSS to other problems; we defer to the full version for a detailed discussion of the reductions and how to obtain such bounds.\n\nCorollary 1. If $\\begin{array} { r l r } { d } & { { } = } & { 2 } \\end{array}$ , there exists a $O ( \\log n )$ - approximation algorithm for DCSS.\n\nCorollary 2. For any constant $\\epsilon \\ > \\ 0 ;$ , there exists a $O ( n ^ { 3 / 5 + \\mathbf { \\bar { \\epsilon } } } )$ -approximation algorithm for the DCSS problem.\n\nCorollary 3. Let $( G , d )$ be an instance of DCSS.\n\ni) If $d \\mathrm { ~ \\bf ~ \\geq ~ } \\mathrm { ~ \\bf ~ \\it ~ { ~ D ~ } ~ } + \\mathrm { ~ \\bf ~ 2 ~ }$ then there exists an $O ( n ^ { 1 / 2 } )$ - approximation algorithm for DCSS.   \nii) If $d \\geq D _ { G } + 4$ then there exists an $O ( n ^ { 2 / 5 } )$ - approximation algorithm for DCSS.   \niii) If $\\begin{array} { l l l } { d } & { \\geq } & { D _ { G } + 6 } \\end{array}$ then there exists an $O ( n ^ { 1 / 3 } )$ - approximation algorithm for DCSS.\n\n# Hardness of Approximation\n\nIn this section we show that MAL is hard to be approximated, even under some restrictions on the input instance.\n\nWe start by showing our logarithmic lower-bound for $a =$ 2 in the next theorem.\n\nTheorem 2. For every $\\epsilon \\in ( 0 , 1 / 4 )$ , there is no polynomial time $\\left( \\epsilon \\log | V | \\right)$ -approximation algorithm for $M A L ,$ unless $P = N P$ . The hardness holds even when the maximum allowed age a is equal to 2.\n\nObserve that Theorem 1 together with Theorem 2 imply that a logarithmic lower-bound also holds for DCSS when $d = 2$ .\n\nTo prove Theorem 2, we introduce the Set Cover (SC) problem. In SC we are given a universe $U = \\{ u _ { 1 } , \\ldots , u _ { \\eta } \\}$ , with $\\begin{array} { r l r } { | U | } & { { } = } & { \\eta , } \\end{array}$ and a collection of $\\mu$ subsets $\\begin{array} { r l } { \\mathcal { C } } & { { } = } \\end{array}$ $\\{ s _ { 1 } , \\ldots , s _ { \\mu } \\} \\subseteq 2 ^ { U }$ . The goal is to find a minimum size subcollection ${ \\mathcal { C } } ^ { * } \\subseteq { \\mathcal { C } }$ such that $\\begin{array} { r } { \\bigcup _ { s _ { i , \\in \\mathcal { C } ^ { * } } } s _ { i } = U } \\end{array}$ .\n\nThe next theorem proves the intractability of approximating SC to a factor smaller than $\\log N$ , where $N$ is the size of an instance.\n\nTheorem 3 ((Dinur and Steurer 2014)). For every $\\alpha \\in$ $( 0 , 1 )$ , it is NP-hard to approximate SC to within $( 1 ~ -$ $\\alpha ) \\log N$ , where $N$ is the size of the instance. The reduction runs in time N O(1/α).\n\nLet $( U , { \\mathcal { C } } )$ be an instance of SC. We construct a graph $G = ( V , E )$ which we will use to prove Theorem 2. See Figure 2 for a reference of the construction. Graph $G$ contains a vertex $s _ { j }$ for each set of $\\mathcal { C }$ , a vertex $u _ { i }$ for each element of the universe $U$ , and two sets of new vertices $T = \\{ t _ { 1 } , t _ { 2 } , t _ { 3 } \\}$ and $W = \\{ w _ { 1 } , w _ { 2 } , \\dots , w _ { x } \\}$ where $x$ is an integer to be defined later. Formally, $V ( G ) ^ { \\cdot } = { \\mathcal { C } } \\cup U \\cup T \\cup W$ . The set of edges of $G$ contains the edges induced by the instance of SC, that is $E _ { \\mathrm { s c } } = \\{ \\{ u _ { i } , s _ { j } \\} : \\bar { u _ { i } } \\in U \\wedge s _ { j } \\in \\mathcal { C } \\wedge u _ { i } \\in s _ { j } \\}$ . It also contains edges $E _ { t _ { 1 } } = \\{ \\{ t _ { 1 } , z \\} : z \\in U \\cup \\mathcal { C } \\cup \\{ t _ { 2 } \\} \\}$ and edges $E _ { t _ { 3 } } = \\{ \\{ t _ { 3 } , z \\} : z \\in W \\cup \\mathcal { C } \\cup \\{ t _ { 2 } \\} \\}$ . Moreover, we add to $G$ the edges between each $w _ { l } \\in W$ to all vertices in $\\mathcal { C }$ , more formally $E _ { \\mathrm { w s } } = \\{ \\{ w _ { l } , s _ { j } \\} : w _ { l } \\in W \\land s _ { j } \\in { \\mathcal { C } } \\}$ . Finally, the edge set of $G$ is equal to $E ( G ) = E _ { \\mathrm { s c } } \\cup E _ { t _ { 1 } } \\cup E _ { t _ { 3 } } \\cup E _ { \\mathrm { w s } }$ . The reader can check that the diameter of $G$ is equal to 2.\n\n![](images/cb817eca8307eab6bbdbabaaad086c18ff3ea5a180305922021b6b867230d97c.jpg)  \nFigure 2: The graph $G$ constructed starting from a SC instance $( U , { \\mathcal { C } } )$ in the proof of Theorem 2.\n\nThe idea of the reduction is that since the only paths of length 2 between any $w \\in W$ and any $u \\in U$ must cross $C$ , therefore for each $w \\in W$ we must select two, possibly identical, set covers – one to allow $w$ to reach all vertices in $U$ and the other one to allow all vertices in $U$ to reach $w$ . The vertices in $T$ help us to connect the other pairs of vertices. However, the labels in the edges incident to the nodes in $T$ might constitute a dominant term in the solution size. We solve this by inserting enough vertices in $W$ .\n\nBefore proving Theorem 2, we need the following lemma\n\nLemma 1. Let $( U , { \\mathcal { C } } )$ be an instance of SC and let $G$ be the graph constructed as above. Given an optimal set cover of size $k ^ { * }$ for $( U , { \\mathcal { C } } )$ , we can construct a feasible solution $\\lambda$ to the instance $( G , 2 )$ of MAL with $| \\lambda | \\le 6 x + 2 x k ^ { * }$ .\n\nNow, we are ready to prove Theorem 2.\n\nProof of Theorem 2. Let $( U , { \\mathcal { C } } )$ be an instance of SC with $\\eta \\ : = \\ : | U |$ and $\\mu = | C |$ , let $\\mathcal { C } ^ { * }$ be an optimal set cover, and let $k ^ { * } = | \\mathcal { C } ^ { * } |$ . Let $G$ be the graph constructed as previously described with $x = \\eta + \\mu + 1$ . Let $\\lambda ^ { * }$ denote an optimal solution to MAL on instance $( G , 2 )$ . Assume there is an $\\alpha$ -approximation algorithm for MAL and denote the solution given by such an algorithm with $\\lambda _ { \\mathrm { A P X } }$ . Denote with $G _ { p }$ where $p \\in [ 2 ]$ the subgraph of $G$ having only the edges that in $\\lambda _ { \\mathrm { A P X } }$ contain label $p$ , that is $E ( G _ { p } ) = \\{ e \\in E ( G ) \\ : \\ p \\in$ $\\lambda _ { \\mathrm { A P X } } ( e ) \\}$ . Observe that in $G _ { p }$ the existing edges going from $w _ { l } , l \\in [ x ]$ , to the vertices in $\\mathcal { C }$ must induce a set cover as the only paths of length 2 between $\\boldsymbol { w _ { l } }$ and any vertex in $U$ must go through a vertex in $\\mathcal { C }$ . More formally, the set of vertices $C _ { p , l } = \\{ s _ { j } \\in \\mathcal { C } : p \\in \\lambda _ { \\mathrm { A P X } } ( \\{ w _ { l } , s _ { j } \\} ) \\}$ is a set cover for every $p \\in [ 2 ] , l \\in [ x ]$ . Denote with $k$ the minimum among the size of sets $C _ { p , l }$ , that is $\\begin{array} { r } { k = \\operatorname* { m i n } _ { p \\in [ 2 ] , l \\in [ x ] } | C _ { p , l } | } \\end{array}$ . Observe that for each $p \\in$ [2] and $l \\in [ x ]$ , $\\lambda$ contains $| C _ { p , l } |$ distinct\n\nlabels to connect vertex $w _ { l }$ to all nodes in $C _ { p , l }$ with label $p$ .   \nHence, $\\begin{array} { r } { \\left| \\lambda _ { \\mathrm { A P X } } \\right| \\geq \\sum _ { p \\in [ 2 ] } \\sum _ { l \\in [ x ] } | C _ { p , l } | \\geq 2 x \\dot { k } } \\end{array}$ .\n\nBy Lemma 1, we can compute a labeling $\\lambda$ such that $| \\lambda | \\leq$ $6 x + 2 x k ^ { * }$ and therefore, $| \\lambda ^ { * } | \\leq 6 x + 2 x k ^ { * }$ .\n\nAs $\\lambda _ { \\mathrm { A P X } }$ is an $\\alpha$ -approximation algorithm for $( G , 2 )$ , then $| \\lambda _ { \\mathrm { A P X } } | \\leq \\alpha | \\lambda ^ { * } |$ , and therefore $2 x k \\leq | \\lambda _ { \\mathrm { A P X } } | \\leq \\alpha | \\lambda ^ { * } | \\leq$ $\\alpha ( 6 x + 2 x k ^ { * } )$ . Dividing by $2 x$ , we get that $k \\leq \\alpha ( k ^ { * } + 3 )$ . Let $\\alpha \\leq \\epsilon \\log ( | G | )$ , where $| G | = O ( N ^ { 2 } )$ . We have $k \\leq$ $\\epsilon ^ { \\prime } \\log ( N ^ { 2 } ) k ^ { * } = \\dot { 2 } \\dot { \\epsilon } ^ { \\prime } \\log ( N ) k ^ { * }$ , for any $\\epsilon ^ { \\prime } = \\dot { \\epsilon } + o ( 1 )$ , which contradicts Theorem 3 for any $\\epsilon ^ { \\prime } \\in ( 0 , 1 / 2 )$ . Hence, we have a contradiction for any $\\alpha \\leq \\epsilon \\log ( | G | )$ and $\\epsilon \\in ( 0 , 1 / 2 )$ . The theorem follows by observing that $| \\dot { G } | = O ( | V ( G ) | ^ { 2 } )$ .□\n\nIn the next theorem we extend our logarithmic lowerbound to the case in which $a$ is any fixed value greater or equal to 3. Indeed, we prove this result for DCSS and then use Theorem 1 to show the same result for MAL.\n\nTheorem 4. For every $\\epsilon \\in ( 0 , 1 / 6 )$ , there is no polynomial time $( \\epsilon \\log | V | )$ -approximation algorithm for DCSS, unless $P = N P$ . The hardness holds even when the required diameter d is a fixed parameter greater or equal to 3.\n\nCorollary 4. For every $\\epsilon \\in ( 0 , 1 / ( 6 a ) )$ , there is no polynomial time $\\left( \\epsilon \\log | V | \\right)$ -approximation algorithm for MAL, unless $P { = } N P$ . The hardness holds even when the maximum allowed age a is a fixed parameter greater or equal to 3.\n\nThe next theorem shows our second lower-bound, based on a stronger complexity hypothesis. Again, we prove the hardness for DCSS and then combine it with Theorem 1 to obtain a hardness bound for MAL. We highlight that in this last result, the interval for $\\epsilon$ does not depend on $a$ as $\\epsilon$ appears in the exponent.\n\nTheorem 5. For any constant $\\epsilon \\in ( 0 , 1 )$ , there is no polynomial time 2log $2 ^ { \\log ^ { 1 - \\epsilon } n }$ -approximation algorithm for DCSS, unless $N P \\subseteq D T I M E { \\big ( } { \\dot { 2 ^ { p \\widehat { o } } } } l y l o g ( n ) { \\big ) }$ . The hardness holds even when the required diameter $d$ is a fixed parameter greater or equal to $3$ .\n\nCorollary 5. For any constant $\\epsilon \\in ( 0 , 1 )$ , there is no polynomial time 2log1− $2 ^ { \\log ^ { 1 - \\epsilon } n }$ -approximation algorithm for MAL, unless $N P \\subseteq D T I M E { \\overset { \\cdot } { ( } 2 ^ { p o l y l o g ( n ) } ) }$ . The hardness holds even when the maximum allowed age a is a fixed parameter greater or equal to 3.\n\nIn order to prove Theorem 5, we will use reduction from a problem called MIN-REP, introduced in (Kortsarz 2001). In MIN-REP, we are given a bipartite graph $\\tilde { G } = ( A , B , \\tilde { E } )$ where $A$ and $B$ are disjoint set of vertices and $\\tilde { E }$ are edges between vertices of $A$ and $B$ . Set $A$ is partitioned into $r$ groups $A _ { 1 } , A _ { 2 } , \\ldots , A _ { r }$ and set $B$ is partitioned into $r$ groups $B _ { 1 } , B _ { 2 } , \\ldots , B _ { r }$ , with the additional property that every set $A _ { i }$ and every set $B _ { j }$ has the same size denoted with $\\sigma$ . Graph $\\tilde { G }$ induces a bipartite condensed graph $G ^ { \\prime } = ( U , W , E ^ { \\prime } )$ defined as follows, $U = \\{ a _ { i } : i \\in \\bar { [ } r ] \\bar  \\}$ , $W = \\{ b _ { j } \\ : \\ j \\in [ r ] \\}$ , and $E ^ { \\prime }$ contains an edge between vertices $a _ { i } \\in U$ and $b _ { j } \\in W$ if and only if there is an edge in $\\tilde { E }$ between some vertex in $A _ { i }$ and some vertex in $B _ { j }$ . The vertices in $V ( G ^ { \\prime } )$ are called condensed vertices and the edges in $E ( G ^ { \\prime } )$ are called condensed edges.\n\nA REP-cover is a set $C \\subseteq A \\cup B$ of vertices with the property that it “covers” every condensed edge, that is for all condensed edges $\\{ a _ { i } , b _ { j } \\}$ there are vertices $a \\in C \\cap A _ { i }$ and $b \\in C \\cap B _ { j }$ such that $\\{ a , b \\} \\in \\tilde { E }$ . The objective of MIN-REP is to construct a REP-cover of minimum size. Let us denote with $C ^ { * }$ an optimal solution to MIN-REP.\n\nWe will say that an instance of MIN-REP is a YESinstance if $| C ^ { * } | = 2 r$ (one vertex for each group) and is a NO-instance if $| C ^ { * } | \\geq 2 ^ { \\log ^ { 1 - \\epsilon ^ { \\prime } } n } r$ . The following theorem is due to Kortsarz (2001).\n\nTheorem 6 ((Kortsarz 2001)). For any constant $\\epsilon ^ { \\prime } \\in ( 0 , 1 )$ , there is no polynomial time algorithm that can distinguish between YES and NO instances of MIN-REP, unless $N P \\subseteq$ DTIME $( 2 ^ { p o l y l o g ( n ) } )$ .\n\nLet $\\tilde { G } = ( A , B , \\tilde { E } )$ be an instance of MIN-REP with associated condensed graph $G ^ { \\prime } = ( U , W , E ^ { \\prime } )$ . We denote with $\\Gamma ( w )$ the group in $\\tilde { G }$ corresponding to condensed vertex $w \\in U \\cup W$ . Therefore, for $u \\in U$ we have that $\\Gamma ( u ) = A _ { i }$ for some $i \\in [ r ]$ , and for $w \\in W$ we have that $\\Gamma ( w ) = B _ { j }$ for some $j \\in [ r ]$ . Let $x$ be a parameter which we will set later.\n\nBefore we go into the details of the reduction from MINREP to DCSS we give some intuition of the construction. We start with a MIN-REP instance $\\tilde { G } = ( A , B , \\tilde { E } )$ , we construct an instance $( G , 3 )$ of DCSS, where $G$ contains all vertices and edges of $\\tilde { G }$ plus a vertex for every group (corresponding to the condensed vertex), which is connected to all vertices in its group. The idea is that in the DCSS instance we want two condensed vertices to be connected through the edges in $\\tilde { G }$ if they are connected by a condensed edge in $G ^ { \\prime }$ , and to have some other path in the case they are not connected by a condensed edge. This will ensure that the selected edges will correspond to a REP-cover. For this purpose, we add an edge between two condensed vertices if and only if they are not connected by a condensed edge in $G ^ { \\prime }$ .\n\nTo connect all vertices in $G$ that are not condensed vertices, we add a vertex $t$ that will act as the center of a star to connect all such vertices. This new vertex will be adjacent to all the vertices in $A$ and $B$ , and it will be connected to the condensed vertices through disjoint paths of length two. In this way, the condensed vertices will be the only vertices that are not connected through a path of length at most 3 passing through the star.\n\nThe labels of edges incident to $t$ might induce a dominant term in the size of the solution. To fix this, we will replicate the condensed vertices into $_ { x + 1 }$ copies, where $x$ copies have the same role described before, i.e., trying to reach the other condensed vertices through the MIN-REP instance (therefore selecting their own vertices for the REP-cover), and the other one having the role to connect its copies to the other vertices.\n\nWe now construct our DCSS instance. See Figure 3 for an illustration. For simplicity, we describe a reduction for the case of diameter 3, and then discuss how to extend it to any fixed $d \\geq 3$ . We start by defining the vertex set $V = A \\cup B \\cup$ $V ^ { L } \\cup V ^ { R } \\cup S \\cup \\{ t \\}$ , where $V ^ { L } = \\overline { { U } } \\times [ x ]$ , $V ^ { R } = W \\times [ x ]$ , and $S = \\{ s _ { u } : u \\in U \\cup W \\}$ . In other words, the vertices of $V ^ { L }$ and $V ^ { R }$ are $x$ copies of the condensed vertices, $S$ contains one vertex for each condensed vertex, and we add a special vertex $t$ that will help us to easily connect the majority of the vertices in the instance.\n\n![](images/ea53e9efed1ea6337ae27a6424a1eb01ae832083d8389ba4ec4db2830ff60f4b.jpg)  \nFigure 3: The graph used in the proof of Theorem 5. Edges between a vertex and a set indicate that the vertex is connected to all vertices in the set.\n\nNow, we define the edge set of $G$ . We start with the edges of the MIN-REP instance, here denoted with $E _ { \\mathrm { m r } } \\ = \\ \\tilde { E }$ . We next add the edges connecting the vertices of $V ^ { L }$ and $V ^ { R }$ to their corresponding group. More formally, $E _ { \\mathrm { c o n } } =$ $\\{ \\{ ( u , i ) , a \\} : u \\in \\bar { U } \\cup W \\land a \\in \\Gamma ( u ) \\land i \\in [ x ] \\}$ . We next connect vertices in $S$ using two edge sets: one connecting $s _ { u } \\in$ $S$ to the vertices $( u , i ) \\in V ^ { L } \\cup V ^ { R }$ , $E _ { \\mathrm { s o } } = \\{ \\{ ( u , i ) \\bar { , } s _ { u } \\} \\ :$ : $u \\in U \\cup W \\land i \\in [ x ] \\}$ ; and one connecting the vertices inside $S$ in such a way that there is an edge between two vertices in $S$ if and only if there is no condensed edge connecting the two corresponding condensed vertices in $G ^ { \\prime }$ . Formally, $E _ { \\mathrm { s s } } = \\{ \\{ s _ { u } , \\bar { s _ { u ^ { \\prime } } } \\} : \\bar { u } , u ^ { \\prime } \\in U \\cup W \\land \\{ u , u ^ { \\prime } \\} \\not \\in E ( G ^ { \\prime } ) \\}$ Observe that if we take two vertices in $U$ the corresponding vertices of $S$ will be connected by an edge, the same hold for the vertices in $W$ . Finally, we add the edges having $t$ as an endpoint, $E _ { \\mathrm { s t a r } } = \\{ \\{ t , y \\} : y \\in A \\cup B \\cup S \\}$ . The final edge set of $G$ will be the union of the previous edge sets: $E ( G ) = E _ { \\mathrm { m r } } \\cup E _ { \\mathrm { c o n } } \\cup E _ { \\mathrm { s o } } \\cup E _ { \\mathrm { s s } } \\cup E _ { \\mathrm { s t a r } }$ .\n\nThe next lemma shows that $D _ { G }$ is equal to 3.\n\n# Lemma 2. The graph $G$ constructed above has diameter 3.\n\nWe will show that if there exists a $2 ^ { \\log ^ { 1 - \\epsilon } n }$ -approximation algorithm for an instance $( G , 3 )$ of DCSS, then Theorem 6 is contradicted. To this aim, we need two lemmas.\n\nLet $H$ be an arbitrary spanning subgraph of $G$ with $D _ { H } =$ 3. The first lemma proves that the size of $E ( H )$ is lower bounded by $x$ times the size of an optimal solution to the MIN-REP instance i.e. $| E ( H ) | > x \\cdot | C ^ { * } |$ , where $x$ is the number of copies in $G$ of each condensed vertex.\n\nLemma 3. For any feasible solution $H$ to the instance $( G , 3 )$ of DCSS we have $| E ( H ) | > x \\cdot | C ^ { * } |$ .\n\nThe second lemma shows that there exists a spanning subgraph of diameter 3 which does not cost much more than $C ^ { * }$ in a YES-instance of MIN-REP.\n\nLemma 4. Assume that $\\tilde { G }$ is a YES-instance of MIN-REP, then there exists a feasible solution $H$ to the instance $( G , 3 )$ of DCSS such that $| E ( H ) | \\leq 4 r x + 5 r ^ { 2 } \\sigma$ .\n\nWe are now ready to prove Theorem 5.\n\nProof of Theorem 5. Fix $\\epsilon \\in \\mathsf { \\Gamma } ( 0 , 1 )$ . Let $\\tilde { G }$ be an instance of MIN-REP of size $\\tilde { n }$ such that it holds $\\tilde { n } \\geq 2 ^ { \\frac { 2 } { \\epsilon ( 1 - \\epsilon ) } }$ . Let us set $x = r \\sigma$ . Clearly, the graph $G$ created as previously described has size $n$ that is polynomial in the size $\\tilde { n } = 2 r \\sigma$ of $\\tilde { G }$ . In particular $n \\leq ( 2 r \\sigma ) ^ { 2 }$ .\n\nAssume there is a polynomial time $\\bigl ( 2 ^ { \\log ^ { 1 - \\epsilon } n } \\bigr )$ - approximation algorithm for the DCSS problem, which we apply to the instance $( G , 3 )$ previously defined, and let us denote the approximate solution with $H _ { \\mathrm { A P X } }$ . Let $H ^ { * }$ denote an optimal solution of DCSS on instance $( G , 3 )$ .\n\nTheorem 6 implies that under the assumption that $\\mathsf { N P \\nsubseteq }$ DTIME $( 2 ^ { \\mathrm { p o l y l o g } ( \\bar { n } ) } )$ , there is no polynomial time algorithm that can distinguish between the YES case where $| C ^ { * } | = 2 r$ and the NO case where $| C ^ { * } | \\geq r 2 ^ { \\log ^ { 1 - \\epsilon ^ { \\prime } } ( 2 r \\sigma ) }$ . As Theorem 6 holds for any choice of $\\epsilon ^ { \\prime }$ , we fix $\\epsilon ^ { \\prime } = \\epsilon ^ { 2 }$ and we have $| C ^ { * } | \\geq$ $r 2 ^ { \\log ^ { 1 - \\epsilon ^ { 2 } } ( 2 r \\sigma ) }$ when $\\tilde { G }$ is a NO-instance for MIN-REP.\n\nSince $\\boldsymbol { x } ~ = ~ r \\boldsymbol { \\sigma }$ , Lemma 4 implies that if $\\tilde { G }$ is a YESinstance of MIN-REP, then $| H ^ { * } | \\leq 9 x r$ . Therefore, when $\\tilde { G }$ is a YES-instance, the solution of our approximation algorithm on $G$ has size $\\left| H _ { \\mathrm { A P X } } \\right| ~ \\leq ~ 9 x r ~ \\cdot ~ 2 ^ { \\log ^ { 1 - \\epsilon } n } ~ \\leq$ $9 x r 2 ^ { 2 \\log ^ { 1 - \\epsilon } ( 2 r \\sigma ) }$ . While, when $\\tilde { G }$ is a NO-instance of MINREP, by Lemma 3 we have that $| H ^ { * } | ~ > ~ x ~ \\cdot ~ | C ^ { * } | ~ \\geq$ $x r 2 ^ { \\log ^ { 1 - \\epsilon ^ { 2 } } ( 2 r \\sigma ) } = x r 2 ^ { ( \\log ^ { 1 - \\epsilon } ( 2 r \\sigma ) ) ^ { 1 + \\epsilon } }$ . But now using the facts that 2rσ = n′ ≥ 22 ϵ(1−ϵ) and $0 ~ < ~ \\epsilon ~ < ~ 1$ we get $9 x r 2 ^ { 2 \\log ^ { 1 - \\epsilon } ( n ^ { \\prime } ) } ~ < ~ x r 2 ^ { ( \\log ^ { 1 - \\epsilon } ( n ^ { \\prime } ) ) ^ { 1 + \\epsilon } }$ , which implies that we can use our approximation algorithm to distinguish between YES and NO instances of MIN-REP, contradicting Theorem 6. Hence, for any $\\epsilon$ , no such polynomial time $( 2 ^ { \\log ^ { 1 - \\epsilon } n } )$ -approximation algorithm can exist and the theorem follows for $d = 3$ .\n\nTo extend the hardness to the case in which the required diameter $d$ is any fixed value $d \\geq 3$ , we need to slightly adjust the reduction. For simplicity assume that $d = 2 k + 1$ with integer $k \\geq 2$ , we change the reduction by adding for each vertex $( u , i ) \\in V ^ { L } \\cup V ^ { R }$ a path on $k { - } 1$ copies of vertex $( u , i )$ i.e. we add vertices $( u , i , \\bar { 1 } ) , ( u , i , 2 ) , \\ldots , ( u , i , k - 1 )$ and edges $\\{ ( u , i ) , ( u , i , 1 ) \\}$ , $\\{ ( u , i , j ) , ( u , i , j + 1 ) \\}$ with $j \\in$ $[ k - 2 ]$ . In this graph, vertices $( u , i , k - 1 )$ have to select a REP-cover in order to reach every other vertices with a path of length at most $d$ . As before, by choosing $\\epsilon$ small enough and an instance of MIN-REP of size big enough we can prove that $d$ -DCSS cannot be approximated with a factor better than $2 ^ { \\log ^ { 1 - \\epsilon } n }$ for any $d \\geq 3$ . A similar construction can be done when $d$ is even, with some more technicalities introduced by the fact that the paths length will be different based on $( u , \\dot { \\boldsymbol { i } } ) \\in V ^ { L }$ or $( u , i ) \\stackrel { \\cdot } { \\in } V ^ { R }$ . □\n\n# Approximation Algorithms\n\nIn this section we introduce our approximation algorithms for MAL. We recall that $D _ { G } \\leq a \\leq 2 D _ { G } + 2$ . Our first set of results for the cases in which $a$ is sufficiently large is given in the following theorem.\n\nTheorem 7. Let $( G , a )$ denote an instance of MAL.\n\ni) If $a \\ge 2 R _ { G }$ then we can compute in polynomial time a solution $\\lambda$ for MAL such that $| \\lambda | \\leq | \\lambda ^ { * } | + 2$ .   \n$i i _ { . }$ ) If $a \\geq 2 R _ { G } + 1$ then we can compute in polynomial time a solution $\\lambda$ for MAL such that $| \\lambda | \\leq | \\lambda ^ { * } | + 1$ .   \niii) If $a \\geq 2 D _ { G } + 2$ then we can compute in polynomial time a solution $\\lambda$ for MAL such that $| \\lambda | = | \\lambda ^ { * } |$ .\n\nThe next corollary collects the approximation results for the cases in which $a$ is slightly larger than $D _ { G }$ , which are derived from the relation between MAL and DCSS established in Theorem 1.\n\nCorollary 6. Let $( G , a )$ denote an instance of MAL.\n\ni) For any $\\epsilon \\mathrm { ~  ~ { ~ > ~ } ~ } 0 \\mathrm { \\mathrm { \\ : \\ : \\ : } }$ , there exists an $O ( D _ { G } ~ \\cdot ~ n ^ { 3 / 5 + \\epsilon } ) .$ - approximation algorithm for MAL.   \nii) If $a = 2$ , then there exists an $O ( \\log ( n ) )$ -approximation algorithm for MAL.   \niii) If $a ~ \\geq ~ D _ { G } + 2$ , then there exists an $O ( D _ { G } \\cdot n ^ { 1 / 2 } )$ - approximation algorithm for MAL.   \n$i \\nu _ { . }$ ) If $a ~ \\geq ~ D _ { G } + 4$ , then there exists an $O ( D _ { G } \\cdot n ^ { 2 / 5 } )$ - approximation algorithm for MAL.   \nv) If $a ~ \\geq ~ D _ { G } + 6 ,$ , then there exists an $O ( D _ { G } \\cdot n ^ { 1 / 3 } )$ - approximation algorithm for MAL.\n\nProof. The statement follows by combining Theorem 1 with the approximations for DCSS given in Corollary 2, Corollary 1, and Corollary 3 and observing that $a = O ( D _ { G } )$ .\n\nIn the next theorem, we give our main algorithmic results, which consist of approximation algorithms for MAL that do not exploit the relation with DCSS and whose approximation ratios do not depend linearly on $D _ { G }$ .\n\nTheorem 8. Let $( G , a )$ be an instance of MAL.\n\ni) If $a ~ \\ge ~ \\lceil 3 / 2 \\cdot D _ { G } \\rceil$ , then there exists an $O ( { \\sqrt { n \\log n } } )$ - approximation algorithm for MAL. $i i$ ) If $a ~ \\geq ~ \\lceil 5 / 3 ~ \\cdot ~ D _ { G } \\rceil$ , then there exists an $O ( \\sqrt [ 3 ] { D _ { G } n \\log ^ { 2 } n } )$ -approximation algorithm for MAL.\n\nThe bounds in Theorem 8 hold when $a$ is sufficiently larger than $D _ { G }$ . Moreover, the approximation bounds of Theorem 8 outperform those of Corollary 6 when $D _ { G }$ is large enough.\n\nIn order to prove Theorem 8 we need to introduce some new concepts. The following definition is an adaptation to undirected graphs of the one contained in (Choudhary and Gold 2020).\n\nDefinition 3 ((Choudhary and Gold 2020)). For a graph $G = ( V , E )$ and a set-pair $( S _ { 1 } , S _ { 2 } )$ , where $S _ { 1 } , S _ { 2 } \\subseteq V$ , we say that $( S _ { 1 } , S _ { 2 } )$ is a $\\langle h _ { 1 } , h _ { 2 } \\rangle$ -dominating set-pair of sizebound $\\langle n _ { 1 } , n _ { 2 } \\rangle i f | S _ { 1 } | = O ( n _ { 1 } ) $ , $| S _ { 2 } | = O ( n _ { 2 } )$ , and one of the following conditions holds.\n\n1. For each $v \\in V ( G )$ , $d _ { G } ( v , S _ { 1 } ) \\leq h _ { 1 }$ ,   \n2. For each $v \\in V ( G )$ , $d _ { G } ( v , S _ { 2 } ) \\leq h _ { 2 }$ .\n\nThe next lemma follows by the results in (Choudhary and Gold 2020).\n\nLemma 5. Let $G = ( V , E )$ be an unweighted graph on $n$ vertices. For any $\\delta \\in ( 0 , 1 )$ and any integer $n _ { 2 } \\in [ n ]$ , we can compute in polynomial time a $\\langle \\lfloor \\delta D _ { G } \\rfloor , \\lceil ( 1 - \\delta ) \\bar { D } _ { G } \\rceil \\rangle$ - dominating set-pair of size-bound $\\langle n _ { 1 } , n _ { 2 } \\rangle$ , where $n _ { 1 } ~ \\leq$ $\\textstyle { \\frac { n \\log n } { n _ { 2 } } }$ .\n\nDue to space constraints, we give a sketch of the proof of Theorem 8. The complete proof will be given in the full version of the paper.\n\nProof sketch of Theorem 8. i) We apply the algorithm in Lemma 5 with $n _ { 2 } ~ = ~ \\lceil \\sqrt { n \\log n } \\rceil$ , and $\\delta \\ = \\ \\bar { 1 } / 2$ . With this choice of parameters we obtain a $\\langle \\lfloor D _ { G } / 2 \\rfloor , \\lceil D _ { G } / 2 \\rceil \\rangle .$ - dominating set-pair $( S _ { 1 } , S _ { 2 } )$ where both $S _ { 1 }$ and $S _ { 2 }$ have size $O ( { \\sqrt { n \\log n } } )$ and one of them can reach every other vertex with a path of length bounded by $\\left\\lceil 1 / 2 \\cdot D _ { G } \\right\\rceil$ . Let us denote with $S$ the set satisfying one of the two conditions in Definition 3. The labeling $\\lambda$ is then constructed as follows.\n\nFor every vertex $\\textit { v } \\in \\textit { S }$ we compute a SPT $\\boldsymbol { T _ { v } }$ rooted at $v$ . Let $\\mathit { e } = \\{ u , w \\}$ be an edge of $T _ { v }$ with $d _ { T _ { v } } ( v , u ) =$ $d _ { T _ { v } } ( v , w ) + 1$ , we add to $\\lambda ( e )$ the label $D _ { G } - d _ { T _ { v } } ( v , u ) + 1$ . Observe that, with this assignment of labels, each vertex $w \\in$ $V ( T _ { v } )$ can temporally reach the root $v$ through a temporal path ending with label $D _ { G }$ . We then compute a single SPF $F$ rooted in set $S$ . Let $\\boldsymbol { e } = \\{ u , w \\}$ be an edge of $F$ with the vertex $u$ being the one farther from $S$ . We add to $\\lambda ( e )$ the label $\\begin{array} { r } { D _ { G } + \\operatorname* { m i n } _ { v \\in S } d _ { F } ( v , u ) } \\end{array}$ .\n\nOverall, we added $O ( n { \\sqrt { n \\log n } } )$ labels and since the minimum number of labels to temporally connect a graph is $2 n - 4$ (see (Klobas et al. 2024)), we have $| \\lambda ^ { * } | \\geq 2 n - 4$ and therefore $| \\lambda | = O ( \\sqrt { n \\log n } ) \\cdot | \\lambda ^ { * } |$ . In conclusion, it can be proved that $( G , \\lambda )$ is temporally connected.\n\n$i i ^ { \\cdot }$ ) Let $( S _ { 1 } , S _ { 2 } )$ be computed by the algorithm in Lemma 5 with parameters $n _ { 2 } = \\left\\lceil \\sqrt [ 3 ] { D _ { G } n \\log ^ { 2 } n } \\right\\rceil$ and $\\delta = 1 / 3$ . We obtain a $\\langle \\lfloor 1 / 3 D _ { G } \\rfloor , \\lceil 2 / 3 \\dot { D } _ { G } \\rceil \\rangle$ -dominating set-pair $( S _ { 1 } , S _ { 2 } )$ of size-bound $\\langle n _ { 1 } , n _ { 2 } \\rangle$ , where $n _ { 1 } ~ \\le ~ \\sqrt [ 3 ] { D _ { G } ^ { - 1 } n ^ { 2 } \\log n }$ . If Condition 2 of Definition 3 holds for $( { \\dot { S } } _ { 1 } , { S } _ { 2 } )$ , then $\\lambda$ is constructed as in $\\ddot { i }$ ) with $S$ being $S _ { 2 }$ . In this case, the size of $\\lambda$ is upper-bounded by $O ( n \\sqrt [ 3 ] { D _ { G } n \\log ^ { 2 } n } )$ which is $O ( \\sqrt [ 3 ] { D _ { G } n \\log ^ { 2 } n } ) \\cdot \\left| { \\lambda ^ { * } } \\right|$ .\n\nTherefore, we assume in the remainder that $S _ { 1 }$ is such that for all $v \\in V ( G ) , d _ { G } ( v , S _ { 1 } ) \\leq \\lfloor 1 / 3 D _ { G } \\rfloor \\leq 1 / 3 D _ { G }$ . The labeling $\\lambda$ is then constructed as follows.\n\nLet $F$ be a SPF rooted in set $S _ { 1 }$ . Let $\\boldsymbol { e } = \\{ u , w \\}$ be an edge of $F$ with the vertex $u$ being the one further from $S _ { 1 }$ . We add to $\\lambda ( e )$ the two labels $1 / 3 D _ { G } - \\mathrm { m i n } _ { v \\in S } d _ { F } ( v , u ) + 1$ and $4 / 3 D _ { G } + \\mathrm { m i n } _ { v \\in S } d _ { F } ( v , u )$ .\n\nLet $s , s ^ { \\prime } \\in S _ { 1 }$ be two distinct vertices, let $\\begin{array} { r l } { P _ { s , s ^ { \\prime } } } & { { } = } \\end{array}$ $e _ { 1 } , e _ { 2 } , \\ldots , e _ { k }$ be a shortest path between $s$ and $s ^ { \\prime }$ in $G$ . We add to $\\lambda ( e _ { i } )$ the labels $1 / 3 { \\bar { D } } _ { G } + i$ and $1 / 3 D _ { G } + k - i + 1$ for $\\textit { i } \\in \\ [ k ]$ . Notice that with these labels we have created a temporal path from $s$ to $s ^ { \\prime }$ , and a temporal path from $s ^ { \\prime }$ to $s$ , both using labels in the range $\\bar { 1 } / 3 D _ { G } ^ { - } +$ $1 , 1 / 3 D _ { G } + 2 , \\dots , 4 / 3 D _ { G }$ . The overall number of labels is $| \\lambda | = { \\cal O } ( n \\sqrt [ 3 ] { D _ { G } n \\log ^ { 2 } n } ) = { \\cal O } ( \\sqrt [ 3 ] { D _ { G } n \\log ^ { 2 } n } ) \\cdot | \\lambda ^ { * } | .$ . Moreover, the largest label used is at most $5 / 3 D _ { G }$ and it can be proved that $( \\bar { G } , \\lambda )$ is temporally connected. □",
    "institutions": [
        "Gran Sasso Science Institute",
        "Aarhus University"
    ],
    "summary": "{\n    \"core_summary\": \"### 核心概要\\n\\n**问题定义**\\n论文聚焦于最小老化标记（Minimum Aged Labeling，MAL）问题，即对时态图的边的可用时间进行调度，使所有顶点对在给定的最大允许时间 $a$ 内相连，且标签总数最少。该问题在物流、配送调度和社交网络信息传播等领域有重要应用，合理选择时间标签可显著降低基础设施成本、燃料消耗或温室气体排放。\\n\\n**方法概述**\\n论文先证明了MAL问题在不同条件下的近似难度下限，当 $a \\geq 2$ 时，除非 $P = NP$，该问题无法以优于 $O ( \\log n )$ 的因子进行近似；当 $a \\geq 3$ 时，除非 $NP \\subseteq DTIME ( 2 ^ { polylog ( n ) } )$，无法以优于 $2 ^ { \\log ^ { 1 - \\epsilon } n }$ 的因子进行近似。随后给出一组近似算法，其近似效果取决于 $a$ 与输入图直径 $D_G$ 的关系。\\n\\n**主要贡献与效果**\\n- 从精确计算角度，证明了MAL对于任何固定的 $a \\geq 2$ 都是NP难的，完善了MAL关于参数 $a$ 的计算复杂度特征描述，而之前的NP难结果仅适用于 $a = D_G = 10$。\\n- 从近似角度，给出更强的近似下界，在 $P \\neq NP$ 条件下，MAL难以以优于对数因子的精度进行近似；在更强的复杂度条件下，难以以优于 $2 ^ { \\log ^ { 1 - \\epsilon } n }$ 的因子进行近似。\\n- 给出三组近似算法结果，当 $a \\geq 2 R_G$ 时，可在多项式时间内计算出比最优解多至多2个标签（$a \\geq 2 R_G + 1$ 时多1个标签）的解；当 $a \\geq 2 D_G + 2$ 时，可在多项式时间内计算出最优解。\",\n    \"algorithm_details\": \"### 算法/方案详解\\n\\n**核心思想**\\n论文核心思想是先确定MAL问题的近似难度下限，再依据 $a$ 与图的半径 $R_G$、直径 $D_G$ 的关系设计不同近似算法。通过将MAL问题与集合覆盖（Set Cover，SC）问题、直径约束生成子图（Diameter Constrained Spanning Subgraph，DCSS）问题、最小REP覆盖（MIN - REP）问题进行关联和转化，利用已知问题的复杂度和近似算法结果推导MAL问题的相关结论。同时，建立MAL问题与DCSS问题的联系，并利用这种联系设计近似算法，在保证图的时态连通性的前提下，尽量减少标签数量。\\n\\n**创新点**\\n- 先前工作中，MAL问题的NP难结果仅适用于特定的 $a$ 和 $D_G$ 值，本文证明了MAL对于任何固定的 $a \\geq 2$ 都是NP难的，完善了其计算复杂度特征描述。\\n- 先前仅证明了MAL在有向图上的APX难问题和无向图上的NP完全问题，本文进一步研究其近似难度和近似算法，拓展了对MAL问题复杂度和近似性的认识。\\n- 给出比之前更强的近似下界，为MAL问题的近似算法设计提供更严格的理论限制。\\n- 针对 $a \\geq D_G$ 的情况，给出三组近似算法，解决了之前工作中提出的开放性问题，且这些算法的近似效果与 $a$ 和 $D_G$ 的关系紧密相关。\\n\\n**具体实现步骤**\\n1. **近似难度下界证明**：\\n    - 对于 $a = 2$ 的情况，通过将集合覆盖（SC）问题归约到MAL问题，证明不存在多项式时间的 $( \\epsilon \\log | V | )$ - 近似算法，除非 $P = NP$。\\n    - 对于 $a \\geq 3$ 的情况，先证明DCSS问题在相同条件下的近似难度下限，通过将MIN - REP问题归约到DCSS问题，再利用MAL和DCSS的近似关系得出MAL问题的近似难度下界。\\n2. **近似算法设计**：\\n    - 当 $a$ 足够大于 $R_G$ 时，若 $a \\geq 2 R_G$，可在多项式时间内计算出比最优解多至多2个标签的解；若 $a \\geq 2 R_G + 1$，可在多项式时间内计算出比最优解多至多1个标签的解；当 $a \\geq 2 D_G + 2$ 时，可在多项式时间内计算出最优解。\\n    - 当 $a$ 略大于 $D_G$ 时，利用MAL和DCSS的关系，根据DCSS的近似算法结果推导出MAL的近似算法。当 $a = D_G = 2$ 时，MAL可通过对数因子近似；当 $a \\geq D_G + 2$ 时，实现 $O ( D_G \\cdot n ^ { 1 / 2 } )$ 的近似因子；当 $a \\geq D_G + 4$ 时，实现 $O ( D_G \\cdot n ^ { 2 / 5 } )$ 的近似因子；当 $a \\geq D_G + 6$ 时，实现 $O ( D_G \\cdot n ^ { 1 / 3 } )$ 的近似因子；对于任意 $a \\geq D_G$，实现 $O ( D_G \\cdot n ^ { 3 / 5 + \\epsilon } )$ 的近似因子，其中 $\\epsilon > 0$。\\n    - 当 $D_G \\leq a < 2 R_G$ 时，不通过DCSS，利用 $\\langle h_1, h_2 \\rangle$ - 支配集对的概念设计近似算法。当 $a \\geq \\lceil 3 / 2 \\cdot D_G \\rceil$ 时，存在 $O ( \\sqrt { n \\log n } )$ 的近似算法；当 $a \\geq \\lceil 5 / 3 \\cdot D_G \\rceil$ 时，存在 $O ( \\sqrt [ 3 ] { D_G n \\log ^ { 2 } n } )$ 的近似算法。\\n\\n**案例解析**\\n论文以包裹配送场景为例，假设有一个仓库 $W$ 为三个城市服务，每个城市有车辆往返于仓库和城市之间，通过不同的车辆调度方案（如不同的出发时间安排）来配送包裹。不同的调度方案在配送时间和所需行程次数上有不同的表现，如第一种方案需要6次行程，最后一个包裹在9点送达；第二种方案优化了最晚到达时间，最后一个包裹在7点送达，但仍需6次行程；第三种方案优化了所需行程次数，减少到5次，但最后一个包裹在8点送达。这个例子说明了合理调度的重要性，引出了MAL问题。\",\n    \"comparative_analysis\": \"### 对比实验分析\\n\\n**基线模型**\\n论文未明确提及用于对比的核心基线模型（Baseline）。\\n\\n**性能对比**\\n论文未进行明确的对比实验，没有将本文方法与基线模型在具体指标上进行对比。但通过证明近似难度下限，与理想的最优近似情况进行了理论上的对比，表明在某些条件下很难找到更好的近似算法。例如，证明了在 $a \\geq 2$ 时，MAL问题不能在优于 $O ( \\log n )$ 的因子内近似，除非 $P = NP$；在 $a \\geq 3$ 时，不能在优于 $2 ^ { \\log ^ { 1 - \\epsilon } n }$ 的因子内近似，除非 $NP \\subseteq DTIME ( 2 ^ { polylog ( n ) } )$。\",\n    \"keywords\": \"### 关键词\\n\\n- 时态图 (Temporal Graph, N/A)\\n- 最小老化标记 (Minimum Aged Labeling, MAL)\\n- 直径约束生成子图 (Diameter Constrained Spanning Subgraph, DCSS)\\n- 近似算法 (Approximation Algorithm, N/A)\\n- 集合覆盖问题 (Set Cover Problem, SC)\\n- 最小REP覆盖问题 (Minimum REP Cover Problem, MIN - REP)\\n- 物流与社交网络 (Logistics and Social Networks, N/A)\"\n}"
}