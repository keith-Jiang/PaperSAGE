{
    "link": "https://arxiv.org/abs/2502.00145",
    "pdf_link": "https://arxiv.org/pdf/2502.00145",
    "title": "Counting and Reasoning with Plans",
    "authors": [
        "David Speck",
        "Markus Hecher",
        "Daniel Gnad",
        "J. Fichte",
        "Augusto B. Correa"
    ],
    "publication_date": "2025-01-31",
    "venue": "AAAI Conference on Artificial Intelligence",
    "fields_of_study": [
        "Computer Science"
    ],
    "citation_count": 0,
    "influential_citation_count": 0,
    "paper_content": "# Counting and Reasoning with Plans\n\nDavid Speck1, Markus Hecher2,3, Daniel Gnad4, Johannes K. Fichte4, Augusto B. Correˆa1,\n\n1University of Basel, Switzerland 2Univ. Artois, CNRS, UMR 8188, Centre de Recherche en Informatique de Lens (CRIL), F-62300 Lens, France 3CSAIL, Massachusetts Institute of Technology, United States 4Linko¨ping University, Sweden 5University of Oxford, United Kingdom davidjakob.speck $@$ unibas.ch, hecher $@$ mit.edu, {daniel.gnad,johannes.fichte}@liu.se, augusto.blaascorrea@chch.ox.ac.u\n\n# Abstract\n\nClassical planning asks for a sequence of operators reaching a given goal. While the most common case is to compute a plan, many scenarios require more than that. However, quantitative reasoning on the plan space remains mostly unexplored. A fundamental problem is to count plans, which relates to the conditional probability on the plan space. Indeed, qualitative and quantitative approaches are well-established in various other areas of automated reasoning.\n\nWe present the first study to quantitative and qualitative reasoning on the plan space. In particular, we focus on polynomially bounded plans. On the theoretical side, we study its complexity, which gives rise to rich reasoning modes. Since counting is hard in general, we introduce the easier notion of facets, which enables understanding the significance of operators. On the practical side, we implement quantitative reasoning for planning. Thereby, we transform a planning task into a propositional formula and use knowledge compilation to count different plans. This framework scales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning functions and explainable planning.\n\n# Introduction\n\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that transforms the current state into a goal state. While in some scenarios a single plan is sufficient, in others, it may not be clear which plan is preferable based on the description of the planning task. To address this, solvers like top- $\\mathbf { \\nabla } \\cdot \\mathbf { k }$ or top-quality planners have been developed to enumerate the $k$ shortest plans or all plans up to a certain length bound allowing for post hoc consideration of the plan space and selection (Katz et al. 2018; Katz and Sohrabi 2020; Speck, Mattmu¨ller, and Nebel 2020; von Tschammer, Mattmu¨ller, and Speck 2022; Chakraborti et al. 2024). Although this paradigm has been successfully applied in practical areas such as malware detection (Boddy et al. 2005) and scenario planning for risk management (Sohrabi et al. 2018), it remains an indirect method for reasoning about the plan space of a planning task.\n\nConsidering fundamental problems in computer science, such as the propositional satisfiability problem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more directed reasoning schemes exist that are anchored around counting. The most prominent and canonical counting problem is #SAT, also called model counting, which asks to compute the number of models of a formula. While #SAT is considered computationally harder than asking whether a single model exists (SAT), it also allows for automated reasoning about the solution space (Darwiche 2001; Darwiche and Marquis 2002). Recent competitions illustrate that, despite high computational complexity, state-of-the-art solvers are effective in practice (Fichte, Hecher, and Hamiti 2021). Due favorable reasoning power and vast applications, counting techniques have been extended to other fields (Aziz et al. 2015; Fichte et al. 2017; Hahn et al. 2022; Eiter, Hecher, and Kiesel 2024).\n\nIn this paper, we bridge the gap between model counting and classical planning by introducing a new framework for reasoning and analyzing plan space. To do so, we consider all plans for a given planning task with polynomially bounded length, consistent with the approach used in topquality planning (Katz and Sohrabi 2020).\n\nContributions Our main contributions are as follows:\n\n1. We introduce a taxonomy of counting and reasoning problems for classical planning with polynomially bounded plan lengths and establish the computational complexity of these problems.   \n2. We identify a class of reasoning problems on the plan space, called facet reasoning, that are as hard as polynomially bounded planning and thus can be solved more efficiently than counting problems.   \n3. We present a practical tool, Planalyst, that builds on existing planning and knowledge compilation techniques to answer plan-space reasoning queries and demonstrate its practical feasibility.\n\nIn more detail, on the theoretical side, we formally define a taxonomy of counting and reasoning problems for planning and analyze the computational complexity of these problems. Among other results, we show that the problem of probabilistic reasoning about the plan space such as determining how many plans contain a given operator is ${ \\bf C } _ { = } ^ { \\mathrm { P } }$ - complete, which is considered computationally harder than counting the number of plans, known to be #P-complete (Speck, Mattmu¨ller, and Nebel 2020). We also introduce the notion of facet reasoning in the context of planning, which has origins in computational complexity (Papadimitriou and Yannakakis 1982) and is well studied in ASP (Alrabbaa, Rudolph, and Schweizer 2018; Fichte, Gaggl, and Rusovac 2022). We show that facet reasoning in planning is NPcomplete, and thus probably much simpler than counting the number of plans. This theoretical result is significant because it allows more efficient answers to complex reasoning queries about the plan space, such as identifying which operators can complement a given partial plan and which provide more flexibility for further complementation.\n\nOn the practical side, we present a solution to the studied counting and reasoning problems by transforming a planning task into a propositional formula, where satisfying assignments correspond one-to-one to plans, followed by subsequent knowledge compilation into a d-DNNF (Darwiche and Marquis 2002). We implement this as a tool called Planalyst, which builds on existing tools from planning (Rintanen 2014) and knowledge compilation (Lagniez and Marquis 2017; Sundermann et al. 2024) and thus readily allows plan counting and automated reasoning in plan space. Empirically, we compare Planalyst to state-of-the-art topquality planners on the computationally challenging problem of counting plans, and show that our tool performs favorably, especially when the plan space is large and reasoning over trillions of plans is critical. Finally, by constructing a d-DNNF, our approach not only supports plan counting, but can also answer reasoning questions such as conditional probability, faceted reasoning, and unbiased uniform plan sampling, all through efficient d-DNNF queries.\n\n# Related Work\n\nDarwiche and Marquis (2002) detailed the theoretical capabilities and limitations of normal forms in knowledge compilation. Established propositional knowledge compilers are c2d (Darwiche 1999) and d4 (Lagniez and Marquis 2017), new developments are extensions of SharpSAT-TD (Kiesel and Eiter 2023). Incremental and approximate counting has been considered for ASP (Kabir et al. 2022; Fichte et al. 2024). In SAT and ASP, advanced enumeration techniques have also been studied (Masina, Spallitta, and Sebastiani 2023; Spallitta, Sebastiani, and Biere 2024; Gebser, Kaufmann, and Schaub 2009; Alviano et al. 2023), which can be beneficial for counting if the number of solutions is sufficiently low or when (partial) solutions need to be materialized. Exact uniform sampling using knowledge compilation has also been implemented (Lai, Meel, and Yap 2021). Model counting has been applied to probabilistic planning in the past (Domshlak and Hoffmann 2007). In classical planning and grounding, Correˆa et al. (2023) argued that grounding is infeasible for some domains if the number of operators in a planning task is too high. Therefore, they manually employed model counting, but did not develop extended reasoning techniques or counting tools for planning. Fine-grained reasoning modes and facets have been studied for ASP (Alrabbaa, Rudolph, and Schweizer 2018; Fichte, Gaggl, and Rusovac 2022; Fichte, Hecher, and Nadeem 2022; Rusovac et al. 2024; Eiter et al. 2024) and significance notions based on facets (Bo¨hl, Gaggl, and Rusovac 2023).\n\n# Preliminaries\n\nWe assume that the reader is familiar with basics of propositional logic (Kleine Bu¨ning and Lettmann 1999) and computational complexity (Papadimitriou 1994). Below, we follow standard definitions (Bylander 1994; Speck, Mattmu¨ller, and Nebel 2020) to summarize basic notations for planning.\n\nBasics For an integer $i$ , we define $[ i ] : = \\{ 0 , 1 , \\ldots , i \\}$ . We abbreviate the domain of a function $f : \\mathcal { D } \\ \\to \\ \\mathcal { R }$ by $\\operatorname { d o m } ( f )$ . By $f ^ { - 1 } : \\mathcal { R } \\to \\mathcal { D }$ we denote the inverse function $f ^ { - 1 } : = \\{ f ( d ) \\to d \\mid d \\in \\operatorname { d o m } ( f ) \\}$ of function $f$ , if it exists. Let $\\sigma = \\langle s _ { 1 } , s _ { 2 } , . . . , s _ { \\ell } \\rangle$ be a sequence, then we write $s \\in \\sigma$ if $s = s _ { i }$ for some $ 1 \\leq i \\leq \\ell$ and $\\nabla ( \\sigma )$ the set of elements that occur in $\\sigma$ , i.e., $\\nabla ( \\sigma ) : = \\{ s \\ | \\ \\dot { s } \\in \\sigma \\}$ . For a propositional formula $F$ , we abbreviate by $\\operatorname { v a r s } ( F )$ the variables that occur in $F$ and by $\\operatorname { M o d } ( F )$ the set of all models of $F$ and the number of models by $\\Dot { \\# } ( F ) : = | \\operatorname { M o d } ( F ) |$ .\n\nComputational Complexity We follow standard terminology in computational complexity (Papadimitriou 1994) and the Polynomial Hierarchy (PH) (Stockmeyer and Meyer 1973; Stockmeyer 1976; Wrathall 1976). The complexity class $\\boldsymbol { \\mathrm { D } } ^ { \\mathsf { P } }$ captures the (independent) combination of an NP and a coNP problem, i.e., ${ \\bf D } ^ { \\mathsf { P } } \\ : = \\ \\{ L _ { 1 } \\cap L _ { 2 } \\ | L _ { 1 } \\ \\in$ NP, $, L _ { 2 } ~ \\in ~ \\mathsf { c o N P } \\}$ (Papadimitriou and Yannakakis 1982). Class PP (Gill 1977) refers to those decision problems that can be characterized by a nondeterministic Turing machine, such that the positive instances are those where at least $1 / 2$ of the machine’s paths are accepting. Counting class $\\# \\mathsf { P }$ captures counting problems that can be solved by counting the number of accepting paths of a nondeterministic Turing machine (Valiant 1979). Class ${ \\bf C } _ { = } ^ { \\mathrm { P } }$ (Fenner et al. 1999) refers to decision problems that can be characterized via nondeterministic Turing machines where positive instances are those with the same number of accepting and rejecting paths.\n\nClassical Planning A planning task is a tuple $\\boldsymbol { \\Pi } \\ =$ $\\langle \\mathcal { A } , \\mathcal { O } , \\mathcal { Z } , \\mathcal { G } \\rangle$ , where $\\mathcal { A }$ is a finite set of propositional state variables. A (partial) state $s$ is a total (partial) mapping $s :$ $\\mathcal { A }  \\{ 0 , 1 \\}$ . For a state $s$ and a partial state $p$ , we write $s \\ \\models \\ p$ if $s$ satisfies $p$ , more formally, $p ^ { - 1 } ( 0 ) \\subseteq s ^ { - 1 } ( 0 )$ and $p ^ { - 1 } ( 1 ) \\subseteq s ^ { - 1 } ( 1 )$ . $\\mathcal { O }$ is a finite set of operators, where each operator is a tuple $o = \\langle \\mathrm { p r e } _ { o } , \\mathrm { e f f } _ { o } \\rangle$ of partial states, called preconditions and effects. An operator $o \\in { \\mathcal { O } }$ is $a p$ - plicable in a state $s$ if $s \\ \\models \\ p \\ v { r } \\mathrm { e } _ { o }$ . Applying operator $o$ to state $s , s [ [ o ] ]$ for short, yields state $s ^ { \\prime }$ , where $s ^ { \\prime } ( a ) : = \\mathrm { e f f } _ { o } ( a )$ , if $a \\in \\mathrm { d o m } ( \\mathrm { e f f } _ { o } )$ and $\\dot { s } ^ { \\prime } ( a ) : = s ( a )$ , otherwise. Finally, $\\mathcal { T }$ is the initial state of $\\Pi$ and $\\mathcal { G }$ a partial state called goal condition. A state $^ { s _ { * } }$ is a goal state if $s _ { * } \\mapsto \\mathcal { G }$ . Let $\\Pi$ be a planning task. A plan $\\pi = \\langle o _ { 0 } , \\ldots , o _ { n - 1 } \\rangle$ is a sequence of applicable operators that generates a sequence of states $s _ { 0 } , \\ldots , s _ { n }$ , where $s _ { 0 } = \\mathcal { I }$ , $s _ { n }$ is a goal state, and $s _ { i + 1 } ~ = ~ s _ { i } [ [ o _ { i } ] ]$ for every $i \\in [ n - 1 ]$ . Furthermore, we let $\\pi ( i ) : = o _ { i }$ JandK denote by $| \\pi |$ the length of a plan $\\pi$ . We denote the set of all plans by Plans $( \\Pi )$ and the set of all plans of length at most $\\ell$ by ${ \\mathrm { P l a n s } } _ { \\ell } ( \\Pi )$ and call it occasionally plan space as done in the literature (Russell and Norvig 1995).\n\nA plan $\\pi$ is optimal if there is no plan $\\pi ^ { \\prime } \\in \\mathrm { P l a n s } ( \\Pi )$ where $| \\pi ^ { \\prime } | < | \\pi |$ . The notion naturally extends to boundedlength plans. Deciding or counting plans is computationally hard. More precisely, the BOUNDED-PLAN-EXIST problem, which asks to decide whether there exists a plan of length at most $\\ell$ , is PSPACE-complete (Bylander 1994). The #BOUNDED-PLAN problem, which asks to output the number of plans of length at most $\\ell$ , remains PSPACEcomplete (Speck, Mattmu¨ller, and Nebel 2020). We say that a plan is polynomially bounded if we restrict the length to be polynomial in the instance size, i.e., the length $\\ell$ of $\\Pi$ is bounded by $\\ell \\leq \\| \\Pi \\| ^ { c }$ for some constant $c$ , where $\\| \\Pi \\|$ is the encoding size of $\\Pi$ . For a planning problem $\\mathbb { P }$ with input $\\ell$ that bounds the length of a plan, we abbreviate by POLY- $\\mathbb { P }$ the problem $\\mathbb { P }$ where $\\ell$ is polynomially bounded. Then, the complexity drops. POLY-BOUNDED-PLAN-EXIST is NPcomplete (Bylander 1994) and #POLY-BOUNDED-PLAN is #P-complete, and the decision problem POLY-BOUNDEDTOP-K-EXIST is PP-hard, which asks to decide, given in addition an integer $k$ , whether there are at least $k$ different plans of length up to $\\ell$ (Speck, Mattmu¨ller, and Nebel 2020).\n\n<html><body><table><tr><td>Name</td><td>Given</td><td>Task</td><td>Compl.</td><td>Ref.</td></tr><tr><td>POLY-BOUNDED-PLAN-EXIST</td><td>II,e</td><td>π ∈Planse(II)</td><td>NP-c</td><td>[1]</td></tr><tr><td>POLY-BRAVE-PLAN-EXIST</td><td>II,l,o</td><td>π∈Planse(II) :o∈π</td><td>NP-c</td><td>Lem. 6</td></tr><tr><td>POLY-CAUTIOUS-PLAN-EXIST</td><td>II,l,o</td><td>∀π ∈ Planse(II) : o∈ π</td><td>coNP-c</td><td>Lem. 6</td></tr><tr><td>POLY-BOUNDED-TOP-K-EXIST</td><td>II,l</td><td>Planse|≥k</td><td>PP-h</td><td>[2]</td></tr><tr><td>#POLY-BOUNDED-PLAN</td><td>II,e</td><td>Planse</td><td>#P-c</td><td>[2]</td></tr><tr><td>POLY-PROBABILISTIC-REASON</td><td>II,l, Q,p</td><td>Pe[II,Q] = p</td><td>C_-c</td><td>Thm. 9</td></tr><tr><td>FACETREASON</td><td>II,l,o</td><td>0 EFe(II)</td><td>NP-c</td><td>Thm. 10</td></tr><tr><td>ATLEAST-K-FACETS</td><td>II,e,k</td><td>|Fe(II)|≥k</td><td>NP-c</td><td>Lem. 11</td></tr><tr><td>ATMOST-K-FACETS</td><td>II,e,k</td><td>jJFe(II)|≤k</td><td>coNP-c</td><td>Cor. 12</td></tr><tr><td>EXACT-K-FACETS</td><td>I,e, k</td><td>|JFe(II)| = k</td><td>DP-c</td><td>Thm. 13</td></tr></table></body></html>\n\nTable 1: Computational Complexity of Qualitative and Quantitative Reasoning Problems. We let Π be a planning task, $\\boldsymbol { \\ell } \\in  { \\mathbb { N } } _ { 0 }$ with $\\ell \\leq p o l y ( \\Pi )$ , $o \\in { \\mathcal { O } }$ , $\\boldsymbol { k } \\in \\mathbb { N } _ { o }$ , $0 \\leq p \\leq 1$ , and $Q$ a query. [1]: (Bylander 1994), [2]: (Speck, Mattmu¨ller, and Nebel 2020).\n\n![](images/7fecf98c609b5ecad11062c0780a7e5b7139d599351d4285fc0168ab2f5a01ca.jpg)  \nFigure 1: State space of our running example task $\\Pi _ { 1 }$ . The initial state is denoted by $s _ { 0 }$ ; the goal state is denoted by $s _ { * }$ .\n\nExample 1 (Running Example). Consider a planning task $\\Pi _ { 1 }$ consisting of a scenario with a slightly chaotic researcher, who has to wake up and give a talk at AAAI. Depending on how late they are, they can go straight to the talk without any preparation. However, they could also spend time getting ready. Less pleasant to the audience, they could also continue sleeping and not give the talk at all. Figure 1 illustrates the state space. The initial state is $s _ { 0 }$ , and the single goal state is $^ { s _ { * } }$ . The labels in each edge identify the operator being applied. We can easily identify two plans:\n\n$( i )$ wake-up; get-ready; go-to-AAAI; give-talk.   \n$( i i )$ wake-up; go-to-AAAI; give-talk.\n\nPlan (i) has length 4, while Plan (ii) has length 3. Observe that action sleep does not appear in any plan.\n\nLandmarks A fact landmark is a state variable that occurs in every plan (Porteous, Sebastia, and Hoffmann 2001). An operator landmark is an operator that occurs in every plan (Richter, Helmert, and Westphal 2008; Karpas and Domshlak 2009). We can extend these notions to bounded landmarks where we assume bounded length $\\ell$ .\n\nExample 2. Consider planning task $\\Pi _ { 1 }$ from Example 1. We observe that wake-up, go-to-AAAI, and give-talk are operator landmarks.\n\nPlanning as Satisfiability (SAT) Let $\\Pi = \\langle \\mathcal { A } , \\mathcal { O } , \\mathcal { I } , \\mathcal { G } \\rangle$ be a planning task and $\\ell > 0$ an integer to bound the length of a potential plan. We can employ a standard technique to encode finding a plan into a propositional formula and ask for its satisfiability (SAT) (Kautz and Selman 1992; Rintanen 2012). In more detail, we can construct a formula $F _ { \\leq \\ell } ^ { \\mathrm { p l a n } }$ [Π] whose models are in one-to-one correspondence with the $\\ell \\cdot$ - bounded plans of $\\Pi$ . For space reasons, we present only the core idea. The variables are as follows: $\\operatorname { v a r s } ( F _ { \\leq \\ell } ^ { \\mathrm { p l a n } } ) = \\{ a ^ { i } \\mid$ $a \\in \\mathcal { A } , i \\in [ \\ell ] \\} \\cup \\{ o ^ { i } \\mid o \\in \\mathcal { O } , i \\in [ \\ell ] \\}$ . Variable $a ^ { i }$ indicates the value of state variable $a$ at the $i$ -th step of the plan. Hence, if $M \\in \\operatorname { M o d } ( F _ { \\leq \\ell } ^ { \\mathrm { p l a n } } [ \\Pi ] )$ and $a ^ { \\ell } \\in M$ , then state variable $a$ has value 1 after applying operators $o ^ { 0 } , \\ldots , o ^ { \\ell - 1 }$ to the initial state. We assume sequential encodings, where the following constraints hold.\n\n1. a set of clauses encoding the value of each state variable at the initial state;   \n2. a set of clauses encoding the value of each state variable in the goal condition;   \n3. a set of clauses guaranteeing that no two operators are chosen at the same step; and   \n4. a set of clauses guaranteeing the consistency of state variables after an operator is applied. If $o ^ { i }$ is true and the effect of operator $o$ makes $a$ true, then $a ^ { i + 1 }$ must be true.\n\nSince plans might be shorter than $\\ell$ , we move “unused” steps to the end using the formula $\\Lambda _ { i \\in [ \\ell ] } ( \\bigwedge _ { o \\in { \\mathcal { O } } } \\neg o ^ { i } \\ $ $\\textstyle \\bigwedge _ { o \\in { \\mathcal { O } } } \\neg o ^ { i + 1 } )$ , which encodes that if no operator was assigned at step $i$ , then no operator can be assigned at step $_ { i + 1 }$ . Thereby, we obtain a one-to-one mapping between models of $F _ { \\leq \\ell } ^ { \\mathrm { p l a n } } [ \\mathrm { I I } ]$ and $l$ -bounded plans for the task.\n\n# From Qualitative to Quantitative Reasoning\n\nClassical planning aims at finding one plan or enumerating certain plans. But what if we want plans that contain a certain operator, or to count the number of possible plans given certain assumptions, or if we want to identify the frequency of an operator among all possible plans? Currently, there is no unified reasoning tool to deal with these types of questions. We introduce more detailed qualitative and quantitative reasoning modes for planning and analyze its complexity. We start with two extreme reasoning modes that consider whether an operator is part of some or all plans.\n\nDefinition 3. Let $\\Pi = \\langle { \\mathcal { A } } , { \\mathcal { O } } , { \\mathcal { T } } , { \\mathcal { G } } \\rangle$ be a planning task, $o \\in$ $\\mathcal { O }$ an operator, and $\\ell$ an integer. We define the\n\n• brave operator by $\\begin{array} { r } { B \\mathcal { O } _ { \\ell } ( \\Pi ) : = \\bigcup _ { \\pi \\in \\mathrm { P l a n s } _ { \\ell } ( \\Pi ) } \\bigtriangledown \\big ( \\pi \\big ) } \\end{array}$ and • cautious operator by $\\begin{array} { r } { \\mathcal { C O } _ { \\ell } ( \\Pi ) : = \\bigcap _ { \\pi \\in \\mathrm { P l a n s } _ { \\ell } ( \\Pi ) } \\bigtriangledown \\big ( \\pi \\big ) . } \\end{array}$ .\n\nThe problem POLY-BRAVE-PLAN-EXIST asks to decide whether $o \\in \\ B \\mathcal { O } _ { \\ell } ( \\Pi )$ . The problem POLY-CAUTIOUSPLAN-EXIST asks to decide whether $o \\in \\mathcal { C } \\mathcal { O } _ { \\ell } ( \\Pi )$ .\n\nNote that we use $\\nabla ( \\cdot )$ to convert sequences into sets, as we aim only for an operator occurring at any time-point.\n\nRemark 4. Our definition of cautious operators is similar to operator landmarks (Zhu and Givan 2003), but for plans with up to a given bounded length.\n\nExample 5. Consider task $\\Pi _ { 1 }$ from Example 1 and Plans (i) and (ii). Furthermore, let $\\ell = 4$ . Then, the brave and cautious operators of our task are the following:\n\n$$\n\\begin{array} { r l } & { \\mathcal { B } \\mathcal { O } _ { \\ell } ( \\Pi _ { 1 } ) = \\{ \\mathrm { w a k e - u p , g e t - r e a d y , g o - t o - A A A I , g i v e - t a l k } \\} , } \\\\ & { \\mathcal { C } \\mathcal { O } _ { \\ell } ( \\Pi _ { 1 } ) = \\{ \\mathrm { w a k e - u p , g o - t o - A A A I , g i v e - t a l k } \\} . } \\end{array}\n$$\n\nOperator get-ready is brave but not cautious, as it appears in Plan (i) but not in Plan (ii). Operator sleep is neither brave nor cautious, as it does not appear in any plan.\n\nLemma 6 $( \\star ^ { 1 } )$ . The problem POLY-BRAVE-PLAN-EXIST is NP-complete and the problem POLY-CAUTIOUS-PLANEXIST is coNP-complete.\n\nTo find brave operators in practice, we can employ a standard SAT (Audemard and Simon 2018) or ASP solver (Gebser et al. 2011, 2014; Alviano et al. 2015). For cautious operators, we can employ a dedicated backbone solver (Biere, Froleyks, and Wang 2023) or again ASP solvers.\n\n# Probability Reasoning\n\nBoth problems POLY-BRAVE-PLAN-EXIST and POLYCAUTIOUS-PLAN-EXIST give rise to extreme reasoning modes on plans. Cautious reasoning is quite strict and so unlikely to hold in general. Brave reasoning is too general and permissive, and thus quite weak in practice. Figure 2 illustrates the two reasoning modes and a more fine-grained mode, which we introduce below. This new mode asks whether the conditional probability of an operator is above a given threshold. It generalizes the known POLY-BOUNDEDTOP-K-EXIST planning problem, which only asks whether at least $k$ plans exists. The crucial ingredient is counting the number of possible plans and relating them to the number of possible plans which contain a given operator. More formally: Let $\\bar { \\Pi } = \\langle \\mathcal { A } , \\mathcal { O } , \\mathcal { Z } , \\mathcal { G } \\rangle$ be a planning task, $o$ be an operator. We abbreviate the set of all plans of $\\Pi$ containing $o$ by ${ \\mathrm { P l a n s } } _ { \\ell } ( \\Pi , o ) : = \\{ \\pi ~ | ~ \\pi ~ \\in { \\mathrm { ~ P l a n s } } _ { \\ell } ( \\Pi ) , o ~ \\in ~ \\pi \\}$ . Then, we define the conditional probability of $o$ in plans of $\\pi$ by $\\begin{array} { r } { \\mathbb { P } _ { \\ell } [ \\Pi , o ] : = \\frac { | \\operatorname { P l a n s } _ { \\ell } ( \\Pi , o ) | } { \\operatorname* { m a x } ( 1 , | \\operatorname { P l a n s } _ { \\ell } ( \\Pi ) | ) } } \\end{array}$ ma|x(P1l,a|nPslℓa(nΠs,ℓo()|Π)|) . Note that the usage of max prevents division by zero in case of no possible plan. Analogously, we can talk about operator $o$ in position $i$ by replacing $o \\in \\pi$ with $o = \\pi ( i )$ . With the help of conditional probability, we can define a fine-grained reasoning mode.\n\n![](images/e2ecaa43f415f2080f5a19d5e5f94a0fd335d617210776ee03fca36da0e61238.jpg)  \nFigure 2: Quantitative reasoning is a fine-grained reasoning mode between brave and cautious reasoning. It asks whether a literal matches $\\geq p \\cdot 1 0 0 \\%$ of the plans for planning task $\\Pi$ .\n\nTo be more flexible, we define $a$ query $Q$ as a propositional formula in conjunctive normal form (CNF) and assume its meaning as expected. We let $Q$ contain variables corresponding to the set $\\mathcal { A }$ of state variables, the set $\\mathcal { O }$ of operators, as well as of states and operators in position $i$ (similar to $F _ { \\leq \\ell } ^ { \\mathrm { p l a n } } )$ . Let $\\pi \\in \\mathrm { P l a n s } _ { \\ell } ( \\bar { \\Pi } )$ be a plan with $\\pi = \\langle o _ { 0 } , \\ldots , o _ { n - 1 } \\bar { \\rangle }$ that generates sequence $s _ { 0 } , \\ldots , s _ { n } .$ . $\\pi$ satisfies a variable $v \\in { \\mathcal { A } }$ if there is some $i \\in [ \\ell ]$ such that $s _ { i } ( v ) = 1$ ; satisfies an operator $o \\in \\mathcal { O }$ if there is some $i \\in [ \\ell ]$ such that $\\pi ( i ) ~ = ~ o$ , analogously for fixed time-points $i$ . Then, $\\pi$ satisfies $\\neg v$ if $\\pi$ does not satisfy $v$ . A plan $\\pi$ satisfies a clause $C$ in $Q$ , if $\\pi$ satisfies one of its literals; $\\pi$ satisfies $Q$ , denoted $\\pi \\models Q$ , if it satisfies every clause in $Q$ . We define $\\operatorname { P l a n s } _ { \\ell } ( \\Pi , Q ) : = \\{ \\pi \\mid \\pi \\in \\operatorname { P l a n s } _ { \\ell } ( \\Pi ) , \\pi \\mid = Q \\}$ .\n\nDefinition 7 (Probability Reasoning). Let $\\Pi = \\langle \\mathcal { A } , \\mathcal { O } , \\mathcal { Z } , \\mathcal { G } \\rangle$ be a planning task, $\\ell > 0$ be an integer, $Q$ be a query, and $0 { \\le } p { \\le } 1$ with $p \\in \\mathbb { Q }$ . Then, probability reasoning on $Q$ asks if Pℓ[Π, Q] = p, where Pℓ[Π, Q] := ma|xP(l1a,|nPsℓl(anΠs,ℓQ()Π|)|) .\n\nExample 8 (Probability Reasoning). Again, consider planning task $\\Pi _ { 1 }$ from Example 1 and let $\\ell = 4 .$ . Take the following probability reasoning queries: (i) $\\mathbb { P } _ { \\ell } [ \\Pi _ { 1 }$ , wake-up] $= 1$ , (ii) $\\mathbb { P } _ { \\ell } [ \\Pi _ { 1 }$ , get-ready] $= 0 . 5$ , and (iii) $\\mathbb { P } _ { \\ell } [ \\Pi _ { 1 } , \\mathrm { s l e e p } ] \\ = \\ 0$ . Reasoning (i) illustrates that the researcher must always use operator wake-up to reach a goal; (ii) indicates that getready occurs in half of the plans; (iii) allows us to conclude that no plan uses operator sleep. More complex queries might ask for the probability of a plan containing both wakeup and sleep, or at least one of them:\n\n$$\n\\begin{array} { r l } & { \\mathbb { P } _ { \\ell } [ \\Pi _ { 1 } , \\mathrm { w a k e - u p } \\land \\mathrm { s l e e p } ] = 0 , } \\\\ & { \\mathbb { P } _ { \\ell } [ \\Pi _ { 1 } , \\mathrm { w a k e - u p } \\lor \\mathrm { s l e e p } ] = 1 . } \\end{array}\n$$\n\nProbability reasoning can be achieved by counting twice, which is computationally hard. In more detail, we obtain:\n\nTheorem $\\textbf { 9 } \\left( \\star \\right)$ . The problem POLY-PROBABILISTICREASON is ${ \\bf C } _ { = } ^ { \\mathrm { P } }$ -complete.\n\n# Faceted Reasoning\n\nAbove, we introduced three different reasoning modes, namely brave, probability, cautious reasoning. Unfortunately the most precise reasoning mode —the probability mode— is the computational most expensive one and requires to count plans. Therefore, we turn our attention to reasoning that is less hard than probabilistic reasoning and allows us still to filter plans and quantify uncertainty among plans. We call this reasoning faceted reasoning following terminology from combinatorics (Papadimitriou and Yannakakis 1982) and ASP (Alrabbaa, Rudolph, and Schweizer 2018). At the heart of these tasks is a combination of brave and cautious reasoning. These are particularly useful if we want to develop plans gradually/incrementally to see at a given time point, which operators are still possible or have the biggest effect. We focus on operators that belong to some (brave) but not to all plans (cautious).\n\nMore formally, for a planning task $\\Pi$ and an integer $\\ell$ , we let $\\mathcal { F } _ { \\ell } ^ { + } ( \\Pi ) : = B \\mathcal { O } _ { \\ell } ( \\dot { \\Pi } ) \\setminus \\mathcal { C } \\bar { \\mathcal { O } } _ { \\ell } ( \\Pi )$ and call the elements of $\\mathcal { F } _ { \\ell } ^ { + } ( \\Pi )$ inclusive facets. In addition, we distinguish excluding facets $\\mathcal { F } _ { \\ell } ^ { - } ( \\Pi )$ , which indicate that operators are not part of a plan. More formally, we let $\\mathcal { F } _ { \\ell } ^ { - } : = \\{ \\neg o ~ | ~ o ~ \\in$ ${ \\mathcal { F } } ^ { + } ( \\Pi ) \\}$ and define the set $\\mathcal { F } _ { \\ell } ( \\Pi )$ of all facets by $\\mathcal { F } _ { \\ell } ( \\Pi ) : =$ $\\mathcal { F } _ { \\ell } ^ { + } ( \\Pi ) \\cup \\mathcal { F } _ { \\ell } ^ { - } ( \\Pi )$ . Interestingly, a facet $p \\in \\{ o , \\lnot o \\}$ is directly related to uncertainty, since the operator $o$ can either be included in or be excluded from a plan. When we enforce that a facet $p \\in \\{ o , \\neg o \\}$ is present in a plan, which we abbreviate by $\\Pi [ p ]$ , we immediately reduce uncertainty on operators among the plans. Based on this understanding, we define the notion of significance for a planning task $\\Pi = \\langle \\mathcal { A } , \\mathcal { O } , \\mathcal { Z } , \\mathcal { G } \\rangle$ and an operator $o \\in \\mathcal { O }$ :\n\n$$\n\\mathbb { S } _ { \\ell } ( \\Pi , o ) : = \\frac { | \\mathcal { F } _ { \\ell } ( \\Pi ) | - | \\mathcal { F } _ { \\ell } ( \\Pi [ o ] ) | } { | \\mathcal { F } _ { \\ell } ( \\Pi ) | } .\n$$\n\nNote that the notion of significance is particularly interesting when we already have a prefix $\\omega _ { k } = \\langle o _ { 0 } , \\ldots , \\ldots , o _ { k } \\rangle$ and are interested in plans that complete the prefix. Here, facets can assist in understanding which operator is the most significant for the next step or some step in the future. Furthermore, we can include state variables into significance notations without effect on the complexity. We omit these cases from the presentation due to space constraints and readability of our introduced notion.\n\n# Computational Aspects of Facets\n\nNext, we study the computational complexity for problems related to facets. We limit ourselves to including facets, assume the case where an operator occurs in some step, and we omit prefixes in the following. These restrictions have only a negligible effect on the complexity. We start with a natural reasoning problem: The FACETREASON problem asks, given a planning task $\\Pi$ and an operator $o \\in { \\mathcal { O } }$ , to decide whether $o \\in \\mathcal { F } ( \\Pi )$ . We start with a lower and upper bound on the FACETREASON problem.\n\nTheorem 10 $( { \\star } )$ . Let Π be a planning task and $o \\in { \\mathcal { O } }$ . The problem FACETREASON is NP-complete.\n\nNext, we look into counting facets and first observe that the number of facets is bound by $0 \\le | \\mathcal { F } ( \\Pi ) | \\le | \\mathcal { O } |$ for a planning task $\\Pi$ . Therefore, we consider a parameterized version by taking a bound $k$ on the number of facets as input. Then, the problem EXACT-K-FACETS asks, given a planning task $\\Pi$ and an integer $k$ , to decide whether $| \\mathcal { F } ( \\bar { \\Pi } ) | = k \\bar { \\ }$ . Before, we look into upper and lower bounds by the problems ATLEAST-K-FACETS and ATMOST-K-FACETS, which ask whether $| { \\mathcal { F } } ( \\Pi ) | \\geq k$ and $| { \\mathcal { F } } ( \\Pi ) | \\leq k$ , respectively.\n\nLemma 11 $( \\star )$ . Let Π be a planning task, and $\\boldsymbol { \\ell } \\in \\mathbb { N } , \\boldsymbol { k } \\in \\mathbb { N } _ { 0 }$ be integers. ATLEAST-K-FACETS is NP-complete.\n\nCorollary 12 $( { \\star } )$ . Let Π be a planning task, $\\ell \\in \\mathbb { N }$ , $\\boldsymbol { k } \\in \\mathbb { N } _ { 0 }$ .   \nThen, the problem ATMOST-K-FACETS is coNP-complete.\n\nBoth results together yield $\\boldsymbol { \\mathrm { D } } ^ { \\mathsf { P } }$ -completeness.\n\nTheorem ${ \\bf 1 3 } \\left( \\star \\right)$ . Let Π be a program, and $\\ell \\in \\mathbb { N }$ , $k \\in \\mathbb { N } _ { 0 } b e$ integers. The problem EXACT-K-FACETS is $\\boldsymbol { \\mathrm { D } } ^ { \\mathsf { P } }$ -complete.\n\n# Discussion: Applications of Plan Reasoning\n\nOur new reasoning modes offer a rich framework to query the solution space of planning tasks. In Remark 4, we discussed the connection between landmarks and cautious reasoning. Similarly, with brave and cautious reasoning it is easy to answer questions such as “does operator $o$ appear on any plan?”, or “does partial state $p$ occur on any trajectory?”\n\nThe expressiveness of the queries goes way beyond and can be leveraged in many existing planning techniques. For example, determining the set of operators that are always or never part of a plan is important for learning pruning functions (Gnad et al. 2019). We can generalize these more global queries to reason about operators being only (never) applied in states that satisfy certain conditions, which is essential for learning policies (Krajnansky´ et al. 2014; Bonet and Geffner 2015). Furthermore, brave and cautious reasoning can be helpful for model debugging, offering a convenient tool to find out if an operator expected to occur in a plan does in fact never appear (Lin, Grastien, and Bercher 2023; Gragera et al. 2023). In over-subscription planning (Smith 2004), we can determine the achievability of soft goals or compute the achievable maximum set of soft goals by answering multiple queries. This can be utilized in explainable planning, providing reasons for the absence of solutions that achieve the desired set of soft goals (Eifler et al. 2020; Krarup et al. 2021). We can even generalize the notion of soft goals to desired state atoms that are achieved along a plan, but which might no longer hold in the goal.\n\nWith faceted reasoning, we are able to answer plan-space queries without actually counting the number of solutions. This reduces the complexity of answering queries to NPcompleteness, making reasoning much more practically usable. What makes facet reasoning particularly interesting is that it allows to efficiently answer conditional queries, such as “if I want operator $o$ to occur at step $k$ , how much choice is left for the remaining operators?”. Similar to previous work in ASP, facet reasoning allows for an interactive querying mode in which users can gain insights about the particular solution space of a planning task (Fichte, Gaggl, and Rusovac 2022). For tasks with a large set of plans that cannot possibly be navigated manually, facets offer the possibility to systematically navigate the solution space, narrowing down the set of plans by committing to desired operators. The Planalyst tool, which we describe in more detail in the next section, enables this form of interactive exploration in the context of classical planning.\n\n# Empirical Evaluation\n\nWe implemented our reasoning framework for classical planning as a tool called Planalyst. Therefore, we transform planning tasks into SAT formulas based on the Madagascar planner (Rintanen 2011, 2014). To efficiently carry out counting, we use d4 (Lagniez and Marquis 2017; Audemard, Lagniez, and Miceli 2022), which compiles (potentially large) formulas into a specialized normal form called d-DNNF (Darwiche and Marquis 2002), enabling fast reasoning. Finally, we reason over the plan space via counting queries using the ddnnife reasoner (Sundermann et al. 2024), which works in poly-time on d-DNNFs.\n\n# Experimental Setup\n\nWe focus on solving #BOUNDED-PLAN, i.e., counting the number of plans, which is the computationally hardest problem studied above. This allows us to address all reasoning questions discussed, including computing conditional probabilities. For each task of the benchmark set, we defined an upper bound by collecting known bounds from planning.domains (Muise 2016) and running winning planners from the most recent International Planning Competitions (IPC) (Taitler et al. 2024). In the experiments, we count plans of length up to a multiplicative factor $c \\in$ $\\{ 1 . 0 , 1 . 1 , \\bar { 1 } . 2 , 1 . 3 , 1 . 4 , \\bar { 1 } . 5 \\}$ of the collected upper bounds. We consider two different configurations for our approach: Count, which only counts the number of plans, and Enum, which additionally enumerates all plans, resulting in a novel top-quality planner for classical planning with unit operator costs. For comparison, we have chosen two top-quality planners, ${ \\tt K } ^ { * }$ (Katz et al. 2018) and SymK (Speck, Mattmu¨ller, and Nebel 2020), both of which can be readily used to count the number of plans as they enumerate them, and both of which are considered to scale well to large numbers of plans. We ran both baseline planners in their recommended configurations2: $\\mathtt { K } ^ { * }$ , which implements orbit-space search (Katz and Lee 2023) with the landmark-cut heuristic (Helmert and Domshlak 2009), and SymK, which implements a variant of bidirectional symbolic search (Torralba et al. 2017). For enumeration approaches $\\mathrm { \\nabla { K ^ { * } } }$ , SymK, Enum), we let these solvers enumerate the plans only internally to avoid writing billions (or more) of plans to the disk. All experiments ran on Intel Xeon Silver 4114 processors running at $2 . 2 \\ : \\mathrm { G H z }$ . We used a time limit of 30 minutes and a memory limit of 6 GiB per task. Our benchmarks include all optimal planning domains from IPCs 1998-2023 with unit operator costs and without conditional effects or axioms. Source code, benchmarks, and data are available online (Speck et al. 2024).\n\nCoverage   \n#Plans   \nTable 2: (Left): Coverage, i.e., the number of tasks where the number of plans within a multiplicative factor of a length bound was found by ${ \\tt K } ^ { * }$ , SymK, and our SAT-based approaches, Count and Enum. Count only counts plans, while Enum additionally enumerates them. (Right): Statistics on the number of plans in the benchmark set, considering the length bound determined by the four solvers.   \n\n<html><body><table><tr><td>Lound</td><td></td><td>xuks</td><td>umu</td><td>tunoo</td><td></td><td></td><td></td></tr><tr><td>×1.0</td><td>351</td><td>309</td><td>253</td><td>335</td><td>>1015</td><td>>1013</td><td>>10²</td></tr><tr><td>×1.1</td><td>289</td><td>231</td><td>182</td><td>300</td><td>>1015</td><td>>1013</td><td>>104</td></tr><tr><td>×1.2</td><td>212</td><td>173</td><td>130</td><td>251</td><td>>1015</td><td>>1013</td><td>>105</td></tr><tr><td>×1.3</td><td>177</td><td>135</td><td>101</td><td>210</td><td>>1018</td><td>>1015</td><td>>105</td></tr><tr><td>×1.4</td><td>142</td><td>112</td><td>77</td><td>189</td><td>>1021</td><td>>1018</td><td>>106</td></tr><tr><td>×1.5</td><td>112</td><td>91</td><td>61</td><td>170</td><td>>1021</td><td>>1018</td><td>>106</td></tr></table></body></html>\n\n# Overall Performance\n\nTable 2 (left) compares the coverage, i.e., the number of tasks for which different approaches can determine the number of plans, for different multiplicative length bounds. $\\mathtt { K } ^ { * }$ has the best coverage for a length bound of 1.0. Our enumeration approach, Enum, ranks overall last, although being able to solve a notable number of tasks by first creating a dDNNF, followed by a subsequent enumeration query for all models, and finally mapping them to actual plans. For the 1.0 bound, our counting approach Count performs worse than $\\mathtt { K } ^ { * }$ , but has better coverage than the SymK planner. When considering higher length bounds, the counting approach, Count, has the highest coverage. The gap between Count and the other approaches gets larger as the length bound increases. This can be explained by the increasing number of plans, see Table 2 (right), where enumeration becomes less feasible due to the large plan space. This highlights the usefulness of our approach for sampling or reasoning in tasks with huge plan spaces. For example, in scenarios where end-users want to understand the plan space, enumerating over a sextillion $( 1 0 ^ { 2 1 } )$ different plans is infeasible, but counting them (and using the related reasoning) is possible. Moreover, a decent performance with larger bounds gives us more flexibility for problems where a good bound is not easily available but an over-approximation is, e.g., using a non-admissible heuristic to come up with a bound.\n\n# Domain-Wise Performance\n\nTable 3 shows a domain-wise comparison of the different approaches for the two extreme bounds in our experiments, 1.0 and 1.5. For both bounds, the performance differs a lot depending on the domain. Our SAT-based approach performs particularly well in the blocksworld and psr-small domains in both cases. In blocksworld, the largest task that we could still solve had $1 . 5 \\cdot 1 0 ^ { 9 }$ plans, while in psr-small the largest solved task had $8 . 9 \\cdot 1 0 ^ { 1 2 }$ . In contrast, ${ \\tt K } ^ { * }$ could only count up to a 10 million plans in these domains.\n\nBound: $\\times 1$ Bound: $\\times 1 . 5$   \nTable 3: Coverage per domain, i.e., number of tasks per domain where the number of plans within a factor 1.0 or 1.5 of a cost bound was found by ${ \\mathrm { K } } ^ { * }$ , SymK, and our SAT-based approaches, Count and Enum. Count only counts plans, while Enum outputs each plan.   \n\n<html><body><table><tr><td>Sum (1094)</td><td>storage ( satelit (36) grid (5) airport (49) (20)</td><td>Domains</td></tr><tr><td>351</td><td>6コｓ叽ｓΠ９ＳνиЗ６ηｓＬコΠＺＺε６ャεＺＳΠν０孔ｓＬ</td><td>K*</td></tr><tr><td>309</td><td>８卯Ｕ９９ＳＳν８わＬⅡＩＬиΠ０Ｚξ９ｃＺＺи８Ｚ０εοＬ</td><td>SymK</td></tr><tr><td>253</td><td>８卯７コＩＳν６めｓ００８ＷＺοεＩ７ＩＳ９７０иοＬ</td><td></td></tr><tr><td></td><td>８иｓＳＺＺＩ９Ｄ６Ｓ８и００８９幻６ａＬｃＩｓ８ｓ０８０ｎ</td><td>Enum</td></tr><tr><td>335|112</td><td></td><td>Count</td></tr><tr><td></td><td>νＳｓＩ０Ｌ７ＩοＺＡＺＺ０ＬＳｎＺοＡＩοＩＩ０ｌο０６０Ｌ ０Ｉ０ＩＷＩＩ０ＬＺ８Ｌ０幻Ｉ０Ｉ０</td><td>K*</td></tr><tr><td>16</td><td>cccI 0 9 0IO 0 80L</td><td>SymK</td></tr><tr><td>1</td><td>乙 9 I ０Ｓ０００Ｉ８ＩＩ００ＩＬＺ００００ 0 0 0I 0 0 L09</td><td>Enum</td></tr><tr><td>170</td><td>$9 →z忆zε v66忆εI- Ｉ０Ｓｏｎ</td><td>Count</td></tr></table></body></html>\n\nThe SAT-based approach is less effective in other domains. One reason is that they are less specialized than heuristic and symbolic search approaches to optimal planning. Among other factors, the sequential encoding is not concise enough for some tasks and bounds (e.g., airport), or the grounding algorithm of Madagascar is inferior to those of other planners built on top of the FastDownward grounder (Helmert 2006, 2009), making it impossible to ground certain tasks (e.g., organic-synthesis). It would be interesting to evaluate how other encodings perform (Rintanen 2012), but that brings the additional problem of losing the one-to-one correspondence between plans and SAT models.\n\nFor 1.5, counting is more feasible than enumeration in many domains: as the number of plans increases, enumeration becomes less practical. Counting works for many reasoning tasks, e.g., those based on conditional probabilities.\n\n# Beyond Counting\n\nAs illustrated above, our Planalyst tool effectively counts plans by compiling into a d-DNNF and performing a counting query. This method can not only answer conditional probability questions, such as the quantity of an operator in plans, but also addresses other reasoning questions more directly and efficiently through d-DNNF queries using ddnnife (Sundermann et al. 2024). Consider reasoning questions about the plan space of a given planning task, while respecting a cost bound. Given the d-DNNF representing the plan space, questions about brave and cautious operators can be answered directly, even without traversing the entire d-DNNF, when the number of plans is known (Sundermann et al. 2024). This can be achieved by traversing the literal nodes of the d-DNNF and collecting the backbone variables, i.e., the variables that are always true (core) or false (dead). In addition, given the d-DNNF, it is possible to uniformly sample plans without enumerating the full set by d-DNNF traversing with ddnnife. This allows to address planning biases when selecting plans (Paredes et al. 2024; Frank et al. 2024) and thus collect unbiased training data for different learning approaches (Shen, Trevizan, and Thie´baux 2020; Areces et al. 2023; Chen, Thie´baux, and Trevizan 2024; Bachor and Behnke 2024). We omit empirical results for these queries, as their overhead is negligible once the d-DNNF is constructed. Our experiments with the Count configuration of Planalyst have shown that this construction is feasible for many planning tasks.\n\n# Conclusion and Future Work\n\nWe count plans and reason in the solution space, which is orthogonal to previous works in planning (Katz et al. 2018; Speck, Mattmu¨ller, and Nebel 2020; Katz and Sohrabi 2020). Moreover, we reason about the plan space in the form of queries and introduce faceted reasoning to planning allowing for questions on the significance of operators. Although faceted reasoning is computationally hard (NP-c), it is, under standard theoretical assumptions, significantly more efficient than counting the number of plans (#P-c). Finally, we present our new reasoning tool, Planalyst, which can count the number of plans assuming fixed given length. It also supports different plan space queries. In general, Planalyst is competitive with state-of-the-art top- $\\mathbf { \\nabla } \\cdot \\mathbf { k }$ planners and outperforms all other methods when the plan space is too large, i.e., more than 10 million plans.\n\nIn the future, we plan to integrate Planalyst into other pipelines, such as goal recognition (Mirsky, Keren, and Geib 2021), grounding via learning (Gnad et al. 2019), and task rewriting (Areces et al. 2014; Elahi and Rintanen 2024), using counting and facet reasoning for guidance. Interesting topics for considerations could be to deal with inconsistencies (Ulbricht 2019) and certifying results (Alviano et al. 2019; Fichte, Hecher, and Roland 2022) as well as explaining reasoning behind decisions (Cabalar, Fandinno, and Mun˜iz 2020). We will study how our framework extends to other encodings, such as parallel operator encodings (Rintanen 2012) or lifted encodings (Ho¨ller and Behnke 2022).",
    "institutions": [
        "University of Basel",
        "Univ. Artois",
        "CNRS",
        "Centre de Recherche en Informatique de Lens (CRIL)",
        "CSAIL",
        "Massachusetts Institute of Technology",
        "Linko¨ping University",
        "University of Oxford"
    ],
    "summary": "{\n    \"core_summary\": \"### 核心概要\\n\\n**问题定义**\\n古典规划通常致力于找到一个将当前状态转换为目标状态的计划，但在许多场景中，仅找到一个计划是不够的，还需要对计划空间进行定量推理，然而目前这方面的研究仍相对较少。计划计数是一个基本问题，它与计划空间上的条件概率相关，在自动化推理的其他领域，定性和定量方法已得到广泛应用，但在计划空间的定量和定性推理方面的研究还很缺乏。这些问题的解决有助于在规划任务中做出更合理的决策，例如在风险场景规划、恶意软件检测等领域。\\n\\n**方法概述**\\n本文提出了一种新的框架，用于对计划空间进行定量和定性推理。理论上，研究了多项式有界计划的复杂性，引入了“面推理（facet reasoning）”的概念；实践上，将规划任务转化为命题公式，利用知识编译技术来实现计划计数和推理。\\n\\n**主要贡献与效果**\\n- 引入了多项式有界计划长度的计数和推理问题的分类法，并确定了这些问题的计算复杂性。例如，确定计划空间中包含给定操作符的计划数量等概率推理问题是 $\\mathbf{C}_{=}^{\\mathrm{P}}$ 完全的，而面推理问题是NP完全的，比计划计数问题（#P完全）可能简单得多。\\n- 识别了一类计划空间上的推理问题——面推理，其复杂度为NP - 完全，比计数问题更容易解决，可更高效地回答关于计划空间的复杂推理查询。\\n- 实现了定量推理工具Planalyst，通过将规划任务转化为命题公式并进行知识编译，该工具在大型计划空间中表现良好。在计数计划的实验中，当长度界限为1.5时，Planalyst的计数方法（Count）能解决170个任务，而 ${\\tt K}^*$ 只能解决112个，SymK只能解决16个，Enum只能解决1个，凸显了其在处理巨大计划空间时的优势。\",\n    \"algorithm_details\": \"### 算法/方案详解\\n\\n**核心思想**\\n本方法的核心思想是将规划任务转化为命题公式，使得满足赋值与计划一一对应，然后通过知识编译将其转化为d - DNNF，利用d - DNNF的特性实现计划计数和推理。面推理的引入是为了在不进行复杂的概率推理（需要计数计划）的情况下，对计划进行筛选和量化不确定性，它结合了勇敢推理（brave reasoning）和谨慎推理（cautious reasoning）的特点。通过这种方式，可以利用命题逻辑的工具和技术来处理规划问题，同时利用d - DNNF的特性高效地回答各种推理查询。其有效性在于命题逻辑和知识编译技术已经在相关领域得到了广泛研究和应用，具有成熟的理论和工具支持。\\n\\n**创新点**\\n先前的规划研究主要集中在寻找单个计划或枚举特定计划，缺乏对计划空间的统一推理工具。本文引入了多种推理模式，如勇敢推理、概率推理、谨慎推理和面推理，并分析了它们的复杂性。面推理的提出使得在不进行昂贵的计划计数的情况下，也能对计划空间进行有效推理，为计划空间的推理提供了更高效的方法。\\n\\n**具体实现步骤**\\n1. 将规划任务 $\\Pi = \\langle \\mathcal{A}, \\mathcal{O}, \\mathcal{I}, \\mathcal{G} \\rangle$ 编码为命题公式 $F_{\\leq \\ell}^{\\mathrm{plan}}[\\Pi]$，其变量包括状态变量和操作符变量，通过一系列约束保证公式的正确性。编码过程包括设置初始状态、目标条件、操作符选择和状态变量一致性的约束。\\n2. 对命题公式进行知识编译，将其转化为d - DNNF，满足赋值与计划一一对应。\\n3. 利用d - DNNF进行计划计数和推理，例如通过d - DNNF查询计算条件概率、进行面推理等。对于概率推理，需要计算满足特定条件的计划数量与总计划数量的比值；对于面推理，需要确定属于某些但不是所有计划的操作符。\\n\\n**案例解析**\\n论文中给出了一个规划任务 $\\Pi_1$ 的例子，该任务描述了一个有点混乱的研究人员需要醒来并在AAAI会议上做报告的场景。有两个计划：(i) wake - up; get - ready; go - to - AAAI; give - talk；(ii) wake - up; go - to - AAAI; give - talk。通过这个例子，展示了勇敢操作符和谨慎操作符的概念，如get - ready是勇敢操作符但不是谨慎操作符，sleep既不是勇敢操作符也不是谨慎操作符。wake - up、go - to - AAAI和give - talk是谨慎操作符，因为它们出现在所有计划中。同时也说明了概率推理和面推理的概念，例如可以计算get - ready在计划中出现的概率为0.5等。\",\n    \"comparative_analysis\": \"### 对比实验分析\\n\\n**基线模型**\\n论文中用于对比的核心基线模型为 ${\\tt K}^*$ 和SymK，这两个模型都是顶级质量的规划器，能够枚举计划，从而可以用于计数计划，并且被认为在处理大量计划时具有较好的扩展性。\\n\\n**性能对比**\\n*   **在 [覆盖任务数量/Coverage] 指标上：** 在长度界限为1.0时，${\\tt K}^*$ 覆盖的任务数量最多，为351个。本文的枚举方法Enum整体排名最后，能解决253个任务，但仍能解决不少任务；本文的计数方法Count在长度界限为1.0时，覆盖任务数量为335个，低于 ${\\tt K}^*$，但高于SymK的309个。当考虑更高的长度界限时，Count的覆盖任务数量最高，且与其他方法的差距随着长度界限的增加而增大，凸显了其在处理大计划空间时的优势。例如，在长度界限为1.5时，Count能解决170个任务，而 ${\\tt K}^*$ 只能解决112个，SymK只能解决16个，Enum只能解决1个。\\n*   **在 [处理大计划空间能力] 指标上：** 随着长度界限的增加，计划数量急剧增加，枚举变得不可行。本文的计数方法Count在处理大计划空间时表现出色，而枚举方法Enum和基线模型 ${\\tt K}^*$、SymK在处理大计划空间时能力有限。如在某些场景下，计划数量达到 $10^{21}$ 个，枚举这些计划是不可行的，但Count方法可以进行计数和相关推理。\",\n    \"keywords\": \"### 关键词\\n\\n- 古典规划 (Classical Planning, N/A)\\n- 计划空间推理 (Plan Space Reasoning, N/A)\\n- 面推理 (Faceted Reasoning, N/A)\\n- 知识编译 (Knowledge Compilation, N/A)\\n- 计划计数 (Plan Counting, N/A)\\n- 多项式有界计划 (Polynomially Bounded Plans, N/A)\"\n}"
}