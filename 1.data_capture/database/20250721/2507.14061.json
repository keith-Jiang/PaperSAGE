{
    "source": "ArXiv (Semantic Scholar未收录)",
    "arxiv_id": "2507.14061",
    "link": "https://arxiv.org/abs/2507.14061",
    "pdf_link": "https://arxiv.org/pdf/2507.14061.pdf",
    "title": "MorphIt: Flexible Spherical Approximation of Robot Morphology for Representation-driven Adaptation",
    "authors": [
        "Nataliya Nechyporenko",
        "Yutong Zhang",
        "Sean Campbell",
        "Alessandro Roncone"
    ],
    "categories": [
        "cs.RO"
    ],
    "publication_date": "未找到提交日期",
    "venue": "暂未录入Semantic Scholar",
    "fields_of_study": "暂未录入Semantic Scholar",
    "citation_count": "暂未录入Semantic Scholar",
    "influential_citation_count": "暂未录入Semantic Scholar",
    "institutions": [
        "未找到机构信息"
    ],
    "paper_content": "# MORPHIT: Flexible Spherical Approximation of Robot Morphology for Representation-driven Adaptation\n\nNataliya Nechyporenko, Yutong Zhang, Sean Campbell, Alessandro Roncone\n\nAbstract—What if a robot could rethink its own morphological representation to better meet the demands of diverse tasks? Most robotic systems today treat their physical form as a fixed constraint rather than an adaptive resource, forcing the same rigid geometric representation to serve applications with vastly different computational and precision requirements. We introduce MORPHIT, a novel algorithm for approximating robot morphology using spherical primitives that balances geometric accuracy with computational efficiency. Unlike existing approaches that rely on either labor-intensive manual specification or inflexible computational methods, MORPHIT implements an automatic gradient-based optimization framework with tunable parameters that provides explicit control over the physical fidelity versus computational cost tradeoff. Quantitative evaluations demonstrate that MORPHIT outperforms baseline approaches (Variational Sphere Set Approximation and Adaptive Medial-Axis Approximation) across multiple metrics, achieving better mesh approximation with fewer spheres and reduced computational overhead. Our experiments show enhanced robot capabilities in collision detection accuracy, contact-rich interaction simulation, and navigation through confined spaces. By dynamically adapting geometric representations to task requirements, robots can now exploit their physical embodiment as an active resource rather than an inflexible parameter, opening new frontiers for manipulation in environments where physical form must continuously balance precision with computational tractability. Website: https://nataliya.dev/morphit.\n\nIndex Terms—Collision Avoidance, Manipulation Planning, Motion and Path Planning, Dexterous Manipulation\n\n![](images/5fc1d7eb8a2c380f5cf8386d2fc740fde7502364f8d21c8455e9f06277432b1e.jpg)  \nFig. 1. MORPHIT enables adaptive robot morphology through four key capabilities: generalistic applicability across multiple robot morphologies, meshes, and simulation environments, flexible approximation fidelity that adapts to task-specific requirements, accurate geometric representation that improves contact-rich planning success, and fast computation for efficient approximation.\n\n# I. INTRODUCTION\n\nThe morphology of a robot, defined as its physical form and structure, serves as the fundamental basis for all physical interactions with the world. This morphology must be represented computationally to enable effective navigation, manipulation, and physical reasoning capabilities. During runtime operation, physical representation becomes particularly critical as robots must constantly compute distances between their bodies and surrounding objects to detect potential collisions or reason about contacts. These distance queries typically consume as much as $71 \\%$ of the total computation time in motion planning pipelines, creating a significant performance bottleneck [1–3]. When robots with complex geometric models interact with numerous objects simultaneously, these calculations quickly become intractable for real-time applications. Even with recent advancements in GPU-based parallel processing [4] and SIMD vector operations [5], these computations scale poorly to the high-frequency bandwidth required by robots operating in dynamic real-world environments.\n\nTo address this challenge, there exist a number of approaches that reduce the computational burden through reduced geometric representations. These include bounding volume hierarchies such as axis-aligned bounding boxes, implicit surface representations such as signed distance fields, and learning-based approaches such as neural radiance fields [6–8]. However, primitive spherical representations, where robot links are modeled as a collection of spheres, still remain particularly prevalent in robotics applications. This popularity stems from their superior computational properties: sphere-to-sphere distance calculations have $\\mathcal { O } ( 1 )$ complexity, are analytically differentiable, inherently parallelizable across multiple processors, and rotationally invariant. These computational properties enable fine-grained control and real-time decision making, allowing high-frequency, contact-rich planning and control tractable for complex systems. Using spherical models, researchers have been able to solve difficult motion generation problems within $5 0 ~ \\mathrm { \\ m s }$ , develop a collisionfree Inverse Kinematics (IK) solver that can solve over 7000 queries/s, and demonstrate contact-implicit model predictive control (MPC) at $\\boldsymbol { 1 0 0 } \\mathrm { H z }$ for a 20−degree-offreedom bi-manual manipulation task [4, 9]. However, while these representations have the potential to enable richer robot capabilities, primitive spherical approximation is under-explored in robotics research, and the process of creating these models remain largely unstructured. First, roboticists frequently employ these models in a makeshift fashion, i.e. manually placing spheres with little systematic consideration for geometric fidelity. Second, because this labor-intensive process cannot be easily replicated, a single rigid representation must serve all applications, leading to compromised collision detection accuracy, motion planning performance, and physical interaction capabilities. For example, the excessive robot padding, shown on the top row of Fig. 2, may be appropriate for collision avoidance in open environments, but it limits the robot’s ability to navigate through tight spaces and manipulate objects in constrained environments, thereby restricting the range of achievable tasks. In other words, the lack of efficient and adaptable morphological representation constitutes a fundamental bottleneck on the capabilities of current robotic systems, preventing robots from making full use of what their embodiment enables.\n\nOne of the challenges in building effective spherical approximations of robot morphology lies in determining an optimal distribution of spheres that on the one hand balances computational efficiency with geometric fidelity, and on the other adapts to the diverse task-specific requirements that robots encounter across different applications. Current approaches for approximating a mesh with spheres rely on either manual specification or automated computational methods. Manual specification tools (e.g. [4, 10]) allow human designers to place and size spheres deliberately, but this process is labor-intensive and scales poorly. Computational methods, while systematic in their approach, have evolved primarily in the computer graphics domain with different optimization objectives than those required for robotics applications [11, 12]. As a result, existing techniques fail to produce representations that are both physically meaningful and practically actionable for modern robotics. This gap motivates our approach, which introduces MORPHIT, a framework for generating spherical representations that are accurate, efficient, and designed around robot control and interaction.\n\nMORPHIT is a novel algorithm that automatically provides spherical approximation of any robot mesh while enabling explicit control over the trade-off between accuracy of the physical fidelity and its computational cost. This flexibility enables the generation of representations tailored to specific tasks, expanding the range of robot capabilities and allowing algorithms to focus on solving complex problems rather than working around representational limitations. Our contributions are:\n\n![](images/9c3caacf3947098774bc3adb072a319c975c69ec5b5d39dfa98908c23d71c8c0.jpg)  \nFig. 2. Current spherical approximation approaches in robotics suffer from significant limitations that restrict robot capabilities, as demonstrated by these representative examples from recent literature. Top row: Overly conservative approximations commonly used for obstacle avoidance extend well beyond actual robot geometry. Bottom row: Sparse approximations used in contact-rich planning focus predominantly on end-effector contact points, leaving much of the robot body unrepresented The prevalence of these suboptimal representations across diverse robot types and applications underscores the critical need for more sophisticated and adaptable approximation approaches.\n\n1) MORPHIT: a novel method to automatically approximate a robot’s morphology with spheres, with key capabilities summarized in Fig. 1.   \n2) A set of comparison metrics, measuring volume and surface representation fidelity, which we use to show that MORPHIT achieves superior approximation quality with fewer spheres and reduced computational overhead compared to baseline approaches.   \n3) A demonstration that existing computational methods from computer graphics do not adequately address the unique requirements of robotics applications, and a set of experiment sthat show how our method enhances robot performance in collision checking accuracy, contact-rich manipulation, and navigation through cluttered and confined spaces.\n\nMORPHIT represents an important step toward more adaptable robot representations, and begins to bridge the gap between static geometric models and task-aware morphological reasoning. While current robotic systems typically treat morphology as a fixed constraint, our work demonstrates the value of adapting representations to the task at hand. We envision a future where robots reason about and strategically leverage their physical form as an active component in planning and interaction tasks, redefining morphology as a tool for physical intelligence—not just a representational limitation.\n\n# II. RELATED WORK\n\n# A. Representation methods for robot morphology\n\nA number of approaches have been proposed for representing the robot and the world. Bounding volume hierarchies (BVH) [6], including Axis Aligned Bounding Boxes (AABBs) [13], Oriented Bounding Boxes (OBBs) [14], and Discrete Orientation Polytopes (k-DOPs) [15], approximate polygonal or polyhedral objects with increasingly refined geometric fidelity but require slow hierarchal traversal.\n\nAlternative representations include Signed Distance Fields (SDFs), which encode distance information with useful gradient properties but demand significant precomputation [7, 16, 17]. Voxel grids discretize space into occupancy cells offering constant-time queries at the cost of memory inefficiency [18, 19]. Octrees are memory-efficient but require significant compute power to reinitialize with every robot movement [20, 21]. Point clouds struggle with incomplete surface reconstruction [18, 22]. Traditional meshbased representations common in graphics applications provide a dense surface reconstruction but are challenging for distance queries [23]. Gaussian splatting achieves strong computational efficiency for rendering complex geometries and shows great promise for 3D representation [24]. However, it relies on multiple viewpoints to reconstruct complex scenes and is optimized for static scene-level modeling. Such approaches cannot easily handle the dynamic recalculation requirements that arise as robots move through different configurations and poses. Neural network-based approaches that implicitly represent geometry by learning any of the previous data structures such as meshes, point clouds or SDFs provide adaptable resolution but slower inference times and rely on a large set of data [8, 25–27].\n\nAmong various geometric representations, primitive shapes offer fast differentiable distance queries, memory efficiency, scalability, and the ability to reconstruct complex volumes and surfaces. While prior work has explored a variety of primitives, such as capsules and cubes [28–30], spheres offer added efficiency because they are rotationally invariant. This advantage is effectively leveraged by CuRobo [4], a high-performance motion generation library that adopts sphere-based approximations to enable efficient and scalable collision checking. Their results show a $6 0 \\times$ speedup in planning performance compared to traditional mesh-based methods. However, CuRobo’s spherebased representations are created via labor-intensive manual packing. Developing algorithmic approaches to automatically generate effective spherical approximations with similar (or better) performance benefits remains an open and challenging problem in the field.\n\n# B. Spherical approximation of 3D models\n\nSphere packing problems, which involve arranging geometric objects within bounded regions while satisfying nonoverlap constraints, represent a well-established class of NP-hard combinatorial optimization problems with extensive applications across manufacturing, logistics, and materials science [31, 32]. These problems combine continuous and discrete optimization challenges, making them computationally demanding even for moderate problem sizes. A different class of sphere approximation algorithms has emerged for physical simulation applications in large scale particle analysis, where they typically focus on high-density non-overlapping spheres that prioritize physical accuracy and realistic packing densities [33–38]. While we share the requirement for computational efficiency with these previous methods, in this work we focus on overlapping spheres of different sizes, prioritizing shape representation over physical particle simulation.\n\nSuch an approach was pioneered by the computer graphics field for fast scene rendering between multiple dynamic elements. O’Rourke and Badler [39] present an algorithm that fits spheres to a polyhedron by anchoring big spheres to points on the surface and shrinking the spheres until they just fit inside. Badler et al. [40] extend this approach to build two-level hierarchies, but they do not consider the more general hierarchies of greater depth necessary for a time-critical detection algorithm. Hubbard et al. [41] focused on addressing this issue by building an algorithm meant for time-critical collision detection. The authors propose medial-axis surfaces, which are skeletal representations of objects, to approximate polyhedra as hierarchies of spheres. To evaluate convergence, they used Hausdorff distance [42], which, while representative for understanding packing efficiency, is computationally expensive. Bradshaw and O’Sullivan built upon Hubbard’s medial axis algorithm and the interruptible sphere tree approach [43] to formulate the Adaptive Medial Axis Approximation (AMAA) algorithm [12]. Their approach employs greedy optimization to merge neighboring sphere pairs, achieving better results than previous methods as demonstrated by Garcia et al. [44]. Yu et al. further refined Bradshaw’s approach to handle sharp geometric features in haptic rendering applications [45]. Most recently, Coumar et al. applied the Bradshaw’s spheretree methodology specifically to model robot manipulators [46], an application similar to our work. We use Coumar’s application of AMAA as a baseline in our evaluation.\n\nWhile the previously described methods rely on sequential, rule-based approaches, Cohen et al. introduced a variational approximation framework that iteratively applies Lloyd clustering [47] for partitioning and fitting phases to achieve optimal piecewise-linear approximation of input geometries [48]. Building on this foundation, Wu et al. expanded the primitive types from simple planar elements to include spheres and cylinders [49]. Wang et al. then developed Variational Sphere Set Approximation (VSSA), which maintained the core variational approach but introduced an “outside volume” metric specifically designed for collision detection and visibility applications rather than surface simplification [11]. Most recently, Wang’s approach has been refined specifically for human shapes [50], but has yet to be tested in the context of robots. We include VSSA as another baseline for our evaluation.\n\n# C. Spherical morphology in robot applications\n\nAs seen on Fig. 2, spherical approximation has been widely adopted across a diverse set of robot morphologies including humanoids [51, 52], legged locomotion platforms [53], manipulators [54, 55], autonomous underwater vehicles [56], and aerial vehicles [57]. This versatility stems from the efficiency of sphere-based computations.\n\nCollision checking represents a significant bottleneck in motion generation pipelines, typically requiring discretization of trajectories and collision checks at each intermediate point[2, 58]. To address this computational burden, robotics applications frequently employ sparse sphere representations [58]. Beyond collision checking, spherical representations are used for efficient trajectory optimization and cost metric formulation. Because spheres support fast and analytically differentiable distance calculations, they are used for constructing smooth and reliable gradients in optimization-based planners such as CHOMP [59], STOMP [60], and CuRobo [4], sampling-based planners, such as CAT-RRT [61], Poke-RRT [62], and VAMP [5] and real-time controllers, such as [63, 64].\n\n![](images/a54a55d1126f3674729bb107f2aa378337f330003531277de3cc11f2ace7583c.jpg)  \nFig. 3. Given a mesh, MORPHIT returns a set of sphere positions and radii that represent a high fidelity packing of the original mesh. It begins by sampling points on the its surface and within its interior of the mesh. These points are used to compute surface and volume losses given sphere configurations. It then initializes sphere centers and radii according to Eq. (2). In the main ‘Optimization’ loop, MORPHIT iteratively updates sphere parameters using gradient-based optimization as defined in Eq. (3). Periodically, MORPHIT performs ‘Adaptive Density Control’ where it removes lowvolume sphere outliers and adds new spheres (green) to uncovered regions of the mesh.\n\nState-of-the-art works on contact-rich planning [9, 65– 67], rely on sphere-based models to efficiently handle contact points during trajectory optimization. While these methods propose a contact-implicit formulation, they effectively define contact points explicitly through their robot representation, which consists of only a few spheres predominantly located at the end-effector. Since much of the robot’s body is not approximated, the robot can neither effectively avoid obstacles nor use its entire body for manipulation tasks. We address this limitation by developing a framework that provides flexible control over the robot’s morphological representation, enabling adaptation to both collision checking and contact planning tasks. An important aspect of this challenge is the current lack of standardized metrics for evaluating the quality and effectiveness of spherical approximations. Without established quantitative measures, it becomes difficult to compare different approaches or optimize representations for specific tasks. Our work addresses this gap by introducing a comprehensive set of evaluation metrics that enable principled assessment of spherical approximations, thereby strengthening the foundation for future research in this area.\n\n# III. METHODS\n\n# A. Baselines\n\n1) Baseline #1: Variational Sphere Set Approximation (VSSA): This method, introduced by Wang et al., approximates solid objects by minimizing the volume outside the object but inside the bounding spheres [11]. This approach defines an error metric, called Sphere Outside Volume (SOV), as the volume of a sphere that extends beyond the object’s surface:\n\n$$\nE ( X , S ) = \\iiint _ { y \\in S } d ( X , y ) d y\n$$\n\nwhere $X$ is the original object, $s$ is the sphere, and $d ( X , y )$ returns 1 if point $y$ is outside $X$ and 0 otherwise. The algorithm minimizes this metric using an iterative Lloyd clustering approach [47] that partitions mesh points into sets and generates an outside volume-minimizing sphere for each set. This method produces tighter approximations than previous approaches by focusing specifically on minimizing the external volume.\n\n2) Baseline #2: Adaptive Medial-Axis Approximation (AMAA): This method, proposed by Bradshaw and O’Sullivan, constructs sphere-trees by adaptively refining a medial axis approximation [12, 68]. The algorithm begins with a Voronoi diagram whose vertices approximate the object’s medial axis. Each internal vertex represents a potential sphere location, with the radius determined by the distance to the nearest surface point. The adaptive approach ensures coverage by: 1) completing coverage by adding spheres around external vertices when necessary, and 2) iteratively improving the approximation by replacing the worst-fitting sphere with better ones. For sphere-tree construction, the algorithm reduces the large set of medial spheres through techniques like merging neighboring spheres or “bursting\", removing a sphere and distributing its coverage to neighbors. This approach improves upon previous methods by guaranteeing complete object coverage and producing sphere-trees with lower error at each level.\n\n# B. Our Method: MORPHIT\n\nUnlike previous methods, MORPHIT directly optimizes a set of sphere parameters (centers and radii) through gradient-based optimization with specialized loss functions. MORPHIT takes as input a mesh (composed of edges and vertices) representing the robot link or object to be approximated, the desired number of spheres for the representation, and weight parameters that control the relative importance of different approximation criteria (cf.\n\nTABLE I DEFINITION OF THE SIX LOSS TERMS USED IN MORPHIT’S COMPOSITE OPTIMIZATION FUNCTION. CF. SECTION III-B.   \n\n<html><body><table><tr><td>Loss Term</td><td colspan=\"3\">Definition</td><td>Description</td></tr><tr><td>Coverage</td><td colspan=\"3\">Lcover =Epeinterior() [max(0,mini(p-Ci-ri))]</td><td>Maximizes interior volume coverage</td></tr><tr><td>Overlap</td><td></td><td>Loverlap =Ei≠jmax(0,ri +rj-llci-Cj )]</td><td></td><td>Minimizes overlap between spheres</td></tr><tr><td>Boundary</td><td colspan=\"3\">Lbound = Eq∈surface(u) [max(0,-min; (q-cil - ri)]</td><td>Minimizes spheres extending outside boundary</td></tr><tr><td>Surface</td><td></td><td>Lsurf =Eqesurface()[mini(q-Ci-ri)l]</td><td></td><td>Minimizes sphere to mesh surface distance</td></tr><tr><td>Containment</td><td></td><td>Lcontain=Ei≠j|max(0,rj-(lc-ci +ri))</td><td></td><td>Minimizes sphere within sphere volume</td></tr><tr><td>SQEM</td><td></td><td>LsQEM =Eqesurface(t)[(q-Cclosest) :nq- rclosest)2]</td><td></td><td>Maximizes surface reconstruction</td></tr></table></body></html>\n\nEq. (3)). The algorithm (see Fig. 3) outputs a set of spheres defined by centers and radii that approximate the input mesh according to the weighted objective function. This sphere set is then converted directly into a Universal Robot Description Format (URDF) file, adhering to the robot’s kinematic restrictions. The resulting URDF can then be used across a variety of robots and simulation environments including Isaac Sim [69], Pinocchio [70], Drake [71], PyBullet [72], and MuJoCo [73], enabling seamless integration with existing robotics workflows.\n\n1) Initialization: The model begins by sampling sphere centers $\\{ c _ { i } \\} _ { i = 1 } ^ { N }$ from within the mesh volume. Sphere radii $\\{ r _ { i } \\} _ { i = 1 } ^ { N }$ are in=itialized using a log-normal distribution that preserves the target volume given the mean radius $\\bar { r }$ :\n\n$$\n\\bar { r } = \\left( \\frac { 3 \\cdot V _ { \\mathcal { M } } } { 4 N \\pi } \\right) ^ { 1 / 3 }\n$$\n\nwhere $V _ { \\mathcal { M } }$ is the mesh volume and $N$ is the desired number of spheres. This non-uniform initialization creates a natural variation in sphere sizes while maintaining the total volume, providing a better starting point for optimization than uniform radii. To enable efficient loss calculation, the algorithm pre-samples points $p \\in$ interior $( { \\mathcal { M } } )$ inside the mesh and points $q \\in$ surface $( \\mathcal { M } )$ on the surface for use in the subsequent loss computations.\n\n2) Optimization: Our goal is to find optimal sphere parameters that approximate the target mesh $\\mathcal { M }$ by minimizing a composite loss function:\n\n$$\n\\begin{array} { r } { L _ { \\mathrm { t o t a l } } = w _ { c } L _ { \\mathrm { c o v e r } } + w _ { o } L _ { \\mathrm { o v e r l a p } } + w _ { b } L _ { \\mathrm { b o u n d } } } \\\\ { + w _ { s } L _ { \\mathrm { s u r f } } + w _ { t } L _ { \\mathrm { c o n t a i n } } + w _ { q } L _ { \\mathrm { S Q E M } } } \\end{array}\n$$\n\nwhere $w _ { c } , \\ w _ { o } , \\ w _ { b } , \\ w _ { s } , \\ w _ { t }$ , and $\\scriptstyle w _ { q }$ are weights for the respective loss components defined in Table I. In the loss functions in table, $\\mathbf { c } _ { i }$ and $r _ { i }$ represent the center and radius of sphere $i$ , while $\\mathbf { p }$ and $\\mathbf { q }$ denote points sampled from the interior and surface of the mesh $\\mathcal { M }$ , respectively.\n\nThe coverage loss ensures spheres adequately fill the mesh interior, while boundary and surface losses constrain spheres to remain close to the mesh surface and accurately represent its geometry. The Spherical Quadric Error Metric (SQEM) loss is first introduced by Thiery et al. for sphere-mesh approximation [74]. While their use of SQEM focuses on fitting spheres to tangent planes during mesh decimation for shape approximation, we adapt it as a surface reconstruction term that measures how well spheres approximate the mesh surface by computing the squared signed distance from surface points to their closest spheres, weighted by surface normals. For the SQEM loss, cclosest and $r _ { \\mathrm { c l o s e s t } }$ refer to the center and radius of the sphere closest to point q, and $\\mathbf { n _ { q } }$ represents the normal at point q.\n\nTwo complementary loss terms govern sphere interactions: overlap loss penalizes intersecting spheres, while containment loss prevents one sphere from being fully enclosed within another. Although overlap loss discourages intersections, it can be minimized by shrinking one sphere to an insignificant size, effectively hiding it inside another with little penalty. Containment loss corrects this by assigning a strong penalty regardless of the smaller sphere’s size, discouraging such nested configurations. Together, these losses ensure that all spheres contribute meaningfully to the shape representation without becoming redundant.\n\nNote that containment and SQEM losses use squared terms to more heavily penalize large deviations, while coverage, overlap, boundary, and surface terms use linear penalties to prioritize average-case performance. This design choice reflects the different objectives of each loss term: containment and surface reconstruction accuracy benefit from outlier sensitivity, while volume coverage and boundary constraints favor balanced distribution.\n\nThe flexibility of our method derives from selecting the sphere count, directly related to available compute resources, and the weighing parameters, which can be adjusted to cater to specific application requirements. For example, increasing $\\boldsymbol { w _ { c } }$ encourages spheres to cover more interior volume while permitting them to extend beyond the mesh boundary, creating a padded approximation suitable for conservative collision checking. Conversely, increasing $\\boldsymbol { w _ { b } }$ , $\\boldsymbol { w _ { s } }$ , $\\scriptstyle w _ { q }$ prioritizes accurate surface reconstruction, which is essential for contact-rich planning where small geometric deviations can significantly impact the positions and velocities of interacting objects. In Section IV, we evaluate several pre-tuned weight configurations to demonstrate their impact on both approximation quality and downstream robotics performance across different task scenarios.\n\n3) Adaptive Density Control: Our method includes an adaptive density control mechanism that prunes ineffective spheres (small radius $r _ { i } < r _ { \\mathrm { t h r e s h o l d } }$ or centers $\\mathbf { c } _ { i } \\notin \\mathcal { M } )$ and adds spheres in poorly covered regions based on coverage metrics. The density control process is triggered when optimization progress plateaus, as measured by convergence metrics including loss values and gradient magnitudes. This approach, inspired by 3D Gaussian Splatting techniques [75], automatically adjusts sphere distribution to improve approximation quality.\n\nThe training process uses Pytorch and Adam optimization with separate learning rates for centers and radii, and includes gradient clipping to ensure stable convergence. The optimization terminates after a maximum number of iterations or if the change in loss falls below a certain threshold. To encourage reproducibility, we open source the full implementation of our method 1.\n\n# C. Quality Metrics\n\nThe lack of standardized evaluation criteria for analyzing the fidelity of spherical approximations represents a significant gap in both computer graphics and robotics research. In the computer graphics community, existing methods often rely on specific, isolated metrics for evaluation. For instance, VSSA uses SOV as both a convergence criterion and a comparison metric against baselines. However, in the robotics community, this type of systematic evaluation is largely absent. While morphological approximations are widely used across motion planning and control frameworks, the fidelity of these approximations is rarely analyzed systematically, despite their significant impact on task success or failure rates.\n\nTo address this critical need, we introduce a comprehensive set of metrics for assessing spherical approximation quality. We argue that effective spherical approximations must accurately and efficiently capture both surface and volume reconstruction, enabling principled comparisons between methods. Our metrics are as follows:\n\nTemporal efficiency is measured through computation time, $t _ { c o m p }$ , which is the time required to generate the sphere packing in seconds (s). Real-time applications require faster-than-real-time approximations to adapt to changing morphologies or task requirements.\n\nBoundary fidelity is quantified through two surface distance metrics. Maximum distance, $d _ { m a x }$ , measures the maximum distance from any mesh surface point to the nearest sphere surface, capturing the worst-case approximation error. Average distance, $d _ { a \\nu g }$ , measures the average distance from mesh to sphere, providing an overall measure of surface approximation quality. Values closer to zero indicate better boundary representation.\n\nSpatial occupancy is evaluated through three volumetric ratios. Inside volume ratio, $r _ { \\mathrm { i n s i d e } }$ , measures the fraction of sphere volume contained within the mesh relative to the total mesh volume. Higher values indicate better coverage.\n\n$$\nr _ { \\mathrm { i n s i d e } } = { \\frac { V _ { \\mathrm { s p h e r e s } } \\cap V _ { \\mathrm { m e s h } } } { V _ { \\mathrm { m e s h } } } }\n$$\n\nOutside volume ratio, routside, measure the ratio of the excess sphere volume extending beyond the mesh boundary to the total mesh volume. Lower values indicate tighter approximations with minimal geometric padding.\n\n$$\nr _ { \\mathrm { o u t s i d e } } = { \\frac { V _ { \\mathrm { s p h e r e s } } \\setminus V _ { \\mathrm { m e s h } } } { V _ { \\mathrm { m e s h } } } }\n$$\n\nUnion volume ratio, $r _ { \\mathrm { u n i o n } }$ , captures the total approximation efficiency accounting for sphere overlaps. Values closer to 1 indicate optimal geometric representation.\n\n$$\nr _ { \\mathrm { u n i o n } } = \\frac { V _ { \\mathrm { s p h e r e s } } \\cup V _ { \\mathrm { m e s h } } } { V _ { \\mathrm { m e s h } } }\n$$\n\nThe union volume ratio serves as a metric for overall volume approximation quality. When $r _ { \\mathrm { u n i o n } }$ diverges from the optimal value of 1, we can diagnose the source of geometric error by examining whether it originates from insufficient interior coverage $( r _ { \\mathrm { i n s i d e } } < 1 )$ ) or excessive extension past the boundary of the mesh $\\mathrm { ( } r _ { \\mathrm { o u t s i d e } } > 0 \\mathrm { ) }$ ).\n\nWithout loss of generality, we rely on Monte Carlo sampling to estimate volumes for rinside , routside , and runion. More specifically, we generate a set of random points within the bounding volume and calculate the ratio of points falling within each region (mesh, spheres, or both) to estimate the corresponding volumes. Surface metrics, $d _ { m a x }$ and $d _ { a \\nu g }$ , are computed by sampling points on the mesh surface and measuring their distances to the nearest sphere.\n\nOur metrics enable a systematic comparison between different spherical packing algorithms and are designed to be generalizable across any set of packing algorithms.\n\n# IV. EVALUATION\n\nHaving established our approach to sphere-based robot approximation, we now evaluate MORPHIT, established baseline methods (AMAA and VSSA) across various robot meshes to assess its performance. While our approach is designed to work with any arbitrary mesh and robot (Fig. 1), we focus specifically on the Franka Emika Panda arm for our quantitative evaluation. The Panda is a widely used 7- DOF manipulator in the robotics research community that is prevalent in motion planning and control frameworks and is composed of complex link geometries that are challenging to approximate. To determine the number of spheres for approximating each robot link, we referenced CuRobo’s widely used library for efficient motion planning. Their manually-packed spherical model of the Panda robot uses an average of 6 spheres per link, with the number ranging from 2 to 18 depending on the link. Moreover, we consider the computational constraints of current systems. CuRobo’s self-collision pipeline efficiently processes approximately 20-25 spheres per link on the Panda before performance degradation occurs and the system must switch to a computationally expensive kernel. While faster hardware\n\nVSSA AMAA MorphIt-B   \nMesh ns=6 ns=25 ns=100 ns=6 ns=25 ns=100 ns=6 ns=25 ns=100   \nPanda link 7 iiiiiiii   \n(collision)   \nB   \nPanda link 2 (visual) 武 大紫★大吉 Armadillo MorphIt-V Morphlt-S MorphIt-B\n\ncould improve performance, we focus our analysis on CuRobo’s current optimal ranges and avoid approximations exceeding 100 spheres per mesh object. More specifically, we tested all methods using sphere counts from 1 to 10 and their squared values. This is because AMAA’s tree structure only allows us to set a branch and depth factor rather than a desired number of spheres, whereas VSSA and MORPHIT allow the approximation for any exact number of spheres. We calibrate the input parameters, such as number of sample points per mesh, for every algorithm for a fair comparison. We use each method’s open source code for implementation.\n\nTo comprehensively evaluate MORPHIT’s flexibility in adapting to different task requirements, we evaluate three variants of our method with distinct weight configurations.\n\nMORPHIT-V Prioritizes interior volume coverage with weights emphasizing the coverage $( w _ { c } = 4 \\times 1 0 ^ { 3 } )$ ) and containment $( w _ { t } = 5 \\times 1 0 ^ { 1 } \\mathrm { \\Omega }$ ) losses while reducing boundary and surface losses $\\mathit { i } \\mathit { w } _ { b } = 1 0 ^ { 1 }$ , $w _ { s } = 1 0 ^ { - 1 }$ , $w _ { q } = 1 0 ^ { 2 }$ ) and minimal overlap penalty $\\begin{array} { r } { { \\bf \\nabla } _ { w _ { o } } = 1 0 ^ { - 1 } { \\bf \\nabla } } .  \\end{array}$ ). This configuration generates conservative approximations suitable for collision avoidance in an uncluttered space. This variant is closest to existing methods, such as VSSA and AMAA, which primarily focus on covering the object entirely, often at the expense of precise surface fidelity.\n\nMORPHIT-S Emphasizes accurate surface reconstruction by increasing boundary and surface loss weights $\\left( { { w _ { b } } = } \\right.$ $5 \\times 1 0 ^ { 3 }$ , $\\boldsymbol { w _ { s } } = 1 0 ^ { 2 }$ , $w _ { q } = 1 0 ^ { 3 } .$ ) while reducing volume coverage priority ( $w _ { c } = 1 0 ^ { - 2 } .$ ) and using minimal overlap and containment penalties $\\omega _ { o } = 1 0 ^ { - 2 }$ , $w _ { t } = 1 )$ ). This variant is developed for scenarios requiring precise contact modeling for manipulation tasks.\n\nMORPHIT-B Uses balanced weights for volume and surface reconstruction $\\angle w _ { c } = 1 0 ^ { 2 }$ , $w _ { b } = 5$ , $w _ { s } = 5$ , $w _ { q } = 8 \\times 1 0 ^ { 2 } )$ ) with moderate overlap and containment losses $\\mathrm { ~ \\ : ~ } \\mathrm { ~ w ~ } _ { o } = 1$ , $w _ { t } = 5 \\AA$ ). This serves as our default configuration, providing a general-purpose approximation that balances geometric fidelity with computational efficiency across diverse robotic applications.\n\n# A. Evaluation of physical fidelity\n\nTo start off, we evaluate each algorithm using the metrics outlined in Section III-C. These metrics capture key characteristics for applications in robotics and computer graphics: computational efficiency for real-time processing, boundary fidelity for geometric representation, and spatial occupancy for both collision padding and precise surface reconstruction. First, we evaluate the computation time to approximate a mesh with spheres across different mesh complexities. We test performance on both collision meshes, simplified geometric models specifically optimized for fast collision detection calculations and visual meshes, higher-fidelity models with detailed surface geometry used for rendering and visualization purposes. Collision meshes typically have significantly fewer triangles to accelerate computation, whereas visual meshes preserve more geometric detail for accurate appearance. Next, we measure boundary fidelity through average distance, $d _ { a \\nu g }$ , and maximum distance $d _ { m a x }$ metrics, followed by spatial occupancy evaluation using inside volume ratio, $r _ { i n s i d e }$ , outside volume ratio, $r _ { o u t s i d e }$ , and union volume ratio $r _ { u n i o n }$ to assess how effectively each method balances interior coverage with boundary precision.\n\n# B. Evaluation for collision checking\n\nCollision detection accuracy represents a critical realworld measure of how well a spherical approximation captures a robot’s true geometry. Accurate collision detection is fundamental to safe and efficient robot operation, directly impacting a robot’s ability to navigate environments without unwanted contacts. We evaluate the impact of packing quality on robot collision checking using Pinocchio’s simulation environment [70]. We chose Pinocchio because it implements an accurate mesh-to-mesh collision detection algorithm, $\\mathrm { { G J K + + } }$ [76], which allows us to establish a reliable ground-truth baseline for actual geometric collisions against which we can compare our sphere-based approximations. Within this environment, we first run tests with the original mesh-based Panda robot against 100 random obstacles across 1000 random configurations, establishing a baseline of true collision states. We then repeat identical scenarios, replacing the mesh robot with versions approximated by different sphere-packing algorithms, and compare the collision detection results against our ground truth data. We categorize outcomes as True Positives (TP: both sphere and mesh detect collision), True Negatives (TN: neither detects collision), False Positives (FP: sphere detects collision but mesh does not), and False Negatives (FN: mesh detects collision but sphere does not). Overall accuracy is measured as $( \\mathrm { T P + T N } )$ / $\\mathrm { T P + T N + F P + F N } .$ ), representing the proportion of correct collision predictions.\n\n# C. Evaluation for contact-rich interactions\n\nPhysical interaction accuracy represents another critical dimension for evaluating spherical approximations. While collision checking focuses on binary contact/no-contact outcomes, contact-rich manipulation requires precise modeling of how forces transfer between objects during sustained physical interactions. Approximation errors in these scenarios can significantly impact the resulting motion dynamics, potentially causing failures in tasks like pushing, sliding, or controlled object manipulation. We evaluate how different sphere approximations affect the accuracy of simulated physical interactions using Drake [71], a simulator designed for contact-rich interaction with an advanced hydroelastic contact model [77]. In our experiment, we place an object at 10 random positions in front of the robot and test each configuration against 10 random robot starting poses, resulting in 100 test scenarios total. For each scenario, we use inverse kinematics to guide the robot to make contact with the object. We first record joint trajectories using the original mesh-based robot model, then replay these exact joint motions using robots approximated by AMAA, VSSA, and each of the MORPHIT variants. By comparing the resulting object motion across each approximation method, we quantify how accurately each sphere representation captures the physical interaction dynamics of the original mesh.\n\n![](images/42321322b2a014d2e816182947bcc8f31097951b8fce536560180735cdda62b6.jpg)  \nFig. 5. The spherical approximations are evaluated based on the robot’s ability to navigate challenging cluttered spaces (refer to Table III for quantitative results). Left) the robots must reach 100 different goal states within 8 different cluttered environments. The example obstacles are shown in gray and represent a subset of the shelf, box, and tabletop environments used in the benchmark. The robot approximations are shown in successful example goal configurations. Right) the robot must traverse between the two cubes with a minimum number of spheres per link used in the morphological approximation.\n\n# D. Evaluation for navigating clutter and tight spaces\n\nThe practical utility of spherical approximations ultimately depends on their ability to support effective motion planning in complex environments. While collision detection accuracy provides a foundation for evaluation in Section IV-B, it is essential to assess how these approximations perform within complete planning systems under realistic constraints. We evaluate motion planning capabilities using CuRobo in the Isaac Sim environment [69], selected for its efficient trajectory optimization capabilities. Our assessment consists of two evaluations shown on Fig. 5: Evaluation A utilizes 8 environments from the benchmark by [78], with 100 variations of perturbed goal positions (maximum $2 0 \\mathrm { c m }$ displacement) per environment to measure success rates. Evaluation B quantifies the minimum number of spheres required for navigating a narrow passage while tracking computational performance. All trajectories are validated by replaying them with high-fidelity mesh models to confirm collision avoidance.\n\n# E. Evaluation for whole-body contact planning\n\nIn Section IV-C, we examine interaction errors over short time horizons, focusing on immediate contact dynamics during discrete interactions. While short-term accuracy is important, extended manipulation tasks require sustained contacts across longer sequences. However, existing contact-rich planning methods rely on sparse sphere representations (see bottom row of Fig. 2) that predominantly focus on end-effector contact points, limiting whole-body manipulation capabilities. We explore how MORPHIT enables whole-body contact capabilities by integrating it with Inverse Dynamics Trajectory Optimization (IDTO) [9]. IDTO is a contact-implicit optimization method that formulates robot motion planning as a nonlinear least-squares problem where generalized positions are the only decision variables. Given a start and a goal pose for an object, IDTO generates a trajectory for the robot to move the object to the desired position. While the contact points are generated implicitly by the algorithm, the robot representation is reduced to only a few spheres, effectively constraining contact interactions to predetermined locations on the robot geometry. We adapt the open-source version of IDTO for our evaluation.\n\nOur comparative analysis focuses on a task where a twolink planar arm must rotate a disk by making contact at appropriate points. For this evaluation, we generate 100 random configurations of the robot and spinner. Next, we use IDTO to solve the trajectory optimization problem twice for each configuration: first with IDTO’s original singlesphere robot representation, and then with our wholebody MORPHIT approximation. Rather than measuring binary success rates, we quantify the positioning accuracy achieved by each method by calculating the angular error between the goal state, $\\theta _ { g o a l }$ , and the final spinner position after the robot’s manipulation attempt, $\\theta _ { f i n a l }$ . By comparing these errors across the random scenarios, we can assess how whole-body contact modeling impacts the optimizer’s ability to complete a task.\n\n# V. RESULTS & DISCUSSION\n\nWe evaluate MORPHIT across multiple dimensions to demonstrate its effectiveness in robot morphology approximation. A qualitative visualization of the packing quality is shown in Fig. 4. Our comprehensive analysis examines physical fidelity metrics, collision detection accuracy, contact interaction dynamics, and motion planning performance across various robotic tasks and environments.\n\n# A. Comparing the physical fidelity\n\nOur performance analysis reveals significant distinctions between the evaluated methods. Fig. 6 shows that VSSA scales well to complex meshes but struggles with larger numbers of spheres. In contrast, AMAA does not scale well to complex meshes but handles large quantities of spheres efficiently. All the MORPHIT variants outperform both baselines in speed and scale effectively with increasing numbers of spheres. The performance advantage is substantial: MORPHIT generates approximations up to two orders of magnitude faster than VSSA and AMAA. This means MORPHIT can use high-fidelity visual meshes without sacrificing computation time. This is essential for robot applications that require fast adaptation of the embodiment, which occurs when the application changes (e.g. coarse to fine collision checking), the robot is handling an object (e.g.\n\na robot grasps an object or a tool and it is used as an extension of itself), or the robot’s morphology changes (e.g. modular robots).\n\nWhile computational speed is critical, it must be matched with geometric accuracy that can allow the robot to accurately represent itself in the environment. Fig. 7 demonstrates that MORPHIT-B consistently outperforms its variants and the baselines for both average and maximum distance metrics across different sphere counts. While MORPHIT-V initially outperforms the baselines for a lower number of spheres, it eventually converges to similar distances for a larger number of spheres. On the other hand, MORPHIT-S continuously improves with an increasing number of spheres.\n\nTo better understand how these methods manage spatial representation, we also examine volume-based metrics. Since each sphere adds to the computational cost of collision checking, it is essential that every part of each sphere’s volume contributes meaningfully to the mesh approximation. Fig. 8 shows that while MORPHIT-V achieves nearoptimal $r _ { \\mathrm { i n s i d e } }$ coverage similar to the baselines by prioritizing complete interior volume representation, MORPHIT-S achieves minimal routside extension by constraining spheres within mesh boundaries at the cost of reduced interior coverage. MORPHIT-B’s ability to balance interior and exterior volume constraints is demonstrated by $r _ { \\mathrm { u n i o n } }$ , which remains closest to the ideal value of 1 across both lower and higher sphere counts.\n\n# B. Comparing the accuracy of contact interactions\n\nAn accurate approximation must not only represent geometry well, but also preserve the dynamics of physical interaction. This is especially important in contact-rich tasks, where a robot’s behavior is driven by the interaction between itself and the environment. As shown in Table II, where $p _ { e r r }$ and $r _ { e r r }$ represent the final position and rotation errors of the object when interacting with sphereapproximated robots compared to the ground-truth meshbased robot, the object trajectory resulting from a contact interaction with the MORPHIT-S-based approximation most closely follows that of the ground-truth mesh. Unlike the other two variants, MORPHIT-S’s weights were designed to specifically optimize for surface representation, prioritizing accurate contact point modeling over volume coverage. This design choice enables MORPHIT-S to capture the precise geometric features necessary for realistic contact dynamics, resulting in object motion that closely matches the behavior observed with the original mesh geometry. This alignment allows MORPHIT to simulate contact dynamics more accurately than competing methods. Such fidelity is essential for model-based algorithms like Reinforcement Learning and Model Predictive Control, which rely on predictions of future states to optimize a robot’s behavior.\n\n# C. Comparing the accuracy of collision checking\n\nTo be effective, a robot approximation must minimize false negatives (FNs) to avoid missed collisions while keeping false positives (FPs) low to prevent overly cautious behavior in free space. Fig. 9 demonstrates that MORPHIT achieves superior balance between FNs and FPs compared to baseline methods. At six spheres per link, baseline algorithms generate twice as many FPs as MORPHIT-B by prioritizing volume coverage at the expense of geometric precision, triggering false collision detections. While MORPHIT-B significantly reduces FPs, it experiences a slight increase in FNs. However, the flexibility of MORPHIT allows for task-specific tuning: MORPHIT-V eliminates FNs entirely like the baseline methods for safety-critical applications, while MORPHIT-S further minimizes FPs at the cost of increased FNs for precision-demanding tasks.\n\n![](images/32a38aed2f2a185976cf31aeadd7c998ab48531fff884689893645b3a0dde2c5.jpg)  \nFig. 6. The impact of the number of spheres (1-100) and mesh complexity on the average computation time, $t _ { c o m p }$ , needed to approximate the nine Panda arm links. Collision meshes (left) are simplified geometric models with approximately $1 0 ^ { 2 }$ vertices and $1 0 ^ { 3 }$ edges optimized for fast collision detection, while visual meshes (right) are high-fidelity models with approximately $1 0 ^ { 4 }$ vertices and $1 0 ^ { 5 }$ edges used for detailed rendering and visualization.\n\n![](images/04479f76219ae40a8995da5abf8f1d8e99a25c638cb63fb768182a87fe5daf3b.jpg)  \nFig. 7. The average distance, $d _ { a \\nu g }$ , from the mesh to sphere surface with an increasing number of spheres used for each Panda arm link. For two representative data points, we show the maximum distance, $d _ { m a x }$ , between the mesh and spherical approximation surfaces.\n\n![](images/ca30caec2236c43c6dc8a4e120aedf163752788cf3af86458de5b737ac3f4567.jpg)  \nFig. 8. The correlation between the $r _ { u n i o n }$ volume ratio and an increasing number of spheres used for approximating each link of the Panda arm. For two representative data points we analyze the inside, $r _ { i n s i d e }$ , and outside, $r _ { o u t s i d e }$ volume ratios which inform the deviation from the ideal $r _ { u n i o n } = 1$ .\n\n![](images/bcdf653af3b3baf698cbfa2f6b6e5b50e27df6842ca2b29d9d11489af2fdb1eb.jpg)  \nFig. 9. Comparison of the accuracy, defined in Section IV-B, between the approximation methods with an increasing number of spheres, ns, used for the approximation of each robot link. For two representative data points we show the confusion matrices demonstrating the percentage of collision detection outcomes across 1000 test cases.\n\nTABLE II CONTACT INTERACTION ERRORS OVER SHORT TIME HORIZONS   \n\n<html><body><table><tr><td></td><td>VSSA</td><td>AMAA</td><td>MorphIt-V</td><td>MorphIt-S</td><td>MorphIt-B</td></tr><tr><td>Perr(mm)</td><td>18.5</td><td>18.7</td><td>18.4</td><td>16.7</td><td>17.0</td></tr><tr><td>rerr(rad)</td><td>0.44</td><td>0.41</td><td>0.42</td><td>0.34</td><td>0.37</td></tr></table></body></html>\n\nTABLE III RESULTS FROM THE COLLISION BENCHMARK EVALUATION SHOWN ON FIG. 5   \n\n<html><body><table><tr><td rowspan=\"2\"></td><td colspan=\"4\">Evaluation A ns=6</td><td colspan=\"2\">Evaluation B ns=α</td></tr><tr><td>Success</td><td>t(s)</td><td>Perr(mm)</td><td>rerr(rad)</td><td>α</td><td>t(s)</td></tr><tr><td>VSSA</td><td>42.9%</td><td>0.21</td><td>0.213</td><td>0.033</td><td>16</td><td>0.61</td></tr><tr><td>AMAA</td><td>47.8%</td><td>0.20</td><td>0.092</td><td>0.015</td><td>10</td><td>0.28</td></tr><tr><td>MorphIt-B</td><td>58.4%</td><td>0.18</td><td>0.080</td><td>0.010</td><td>6</td><td>0.21</td></tr></table></body></html>\n\nThis adaptability is essential for real-world deployment where collision detection requirements vary by application. For example, MORPHIT-B provides optimal performance when operating with static objects by minimizing false alarms, while MORPHIT-V offers enhanced safety guarantees for critical environments such as hospital settings where conservative collision detection is paramount.\n\n# D. Impact of approximation on obstacle avoidance\n\nWhile accurate collision detection is a prerequisite for safe operation, its real-world impact is revealed in how well it supports motion planning in complex environments. For these motion planning evaluations, we selected MORPHIT-B based on its balanced performance in the previous collision detection analysis. Fig. 5 presents two evaluations that assess how the morphological representation impacts a robot’s ability to navigate cluttered or tight spaces while reaching its goal state. Table III shows the results collected from the two evaluations. In Evaluation A, ns is the number of spheres per robot link used for the approximation, while in Evaluation B ns represents the minimum number of spheres per link required by each method to pass through the narrow passage. Additionally, t(s) is the time to generate trajectory, $p _ { e r r }$ and $r _ { e r r }$ are the final position and rotation errors of the end-effector from the goal state.\n\nThe table shows thatMORPHIT-B achieves higher success rates by more accurately representing the robot’s geometry, enabling effective navigation through cluttered environments. Evaluation B further demonstrates that MORPHIT-B requires significantly fewer spheres to successfully navigate a narrow passage compared to VSSA and AMAA methods, resulting in reduced computation time. This efficiency stems from MORPHIT-B’s balanced approach to volume and surface coverage, facilitating collision-free navigation through constrained spaces while maintaining computational efficiency. Navigating narrow spaces is essential for robots operating in manufacturing plants, chemistry labs, and aboard space stations where the operational space is limited. In such mission-critical settings, failure to navigate tight environments can lead to task failure, equipment damage, or safety risks. Ensuring reliable performance in these contexts is vital for the success and safety of robots.\n\n![](images/ac3f692c88be79670f738ab779303a2959a9bb1d3d57b757ad16739f5fe5bf27.jpg)  \nFig. 10. (A) In this task, the 2dof arm that must rotate a spinner to a desired goal state, $\\theta$ . (B) Real-world analogy demonstrating how humans naturally use their entire body, including elbows, shoulders, and other body parts, for manipulation tasks, paralleling how our 2DOF arm can use its elbow joint to rotate the spinner when equipped with whole-body contact modeling. (C) Trajectory snapshots comparing the original IDTO algorithm with sparse single-contact representation (top row) versus IDTO enhanced with MORPHIT’s whole-body representation (bottom row) (D) Violin plot showing the distribution of final angular errors between the target and achieved spinner orientations, comparing the original IDTO algorithm versus IDTO enhanced with MORPHIT’s whole-body representation across multiple trials.\n\n# E. Impact of approximation on contact planning\n\nBeyond collision avoidance, effective physical interaction with objects represents another essential capability. While CuRobo’s planning stack focuses on obstacle avoidance, IDTO aims to find trajectories that move target objects from start to goal configurations. For this contact-rich evaluation, we selected MORPHIT-S based on its superior performance in accurately capturing contact dynamics, as demonstrated in the previous interaction analysis.\n\nAs illustrated in Fig. 10, when a two-link arm uses a single contact sphere approximation to rotate a spinner, it becomes limited to that specific contact point, restricting arm movement and frequently resulting in failure. In contrast, MORPHIT-S enables multiple contact points through its full-body spherical representation, allowing the arm to leverage its entire geometry for manipulation. The implementation of MORPHIT-S with IDTO demonstrates $5 2 . 8 \\%$ better convergence to the target value compared to the original algorithm across random robot start and object positions. As a result, this method enables more dexterous whole-body interactions, such as using both links to spin the object, which was previously unattainable with the original algorithm. This capability has direct analogies to human manipulation, where people naturally use their entire body, including elbows, shoulders, and other body parts, for complex manipulation tasks.\n\nIt should be noted that the original single-sphere IDTO implementation inherently allows the robot to move into physically unreachable configurations where the robot body overlaps with the spinner’s space, as the optimization is not aware of potential collisions between the robot body and the manipulated object. While this limitation can be mitigated by integrating the trajectory optimization into a feedback loop with Model Predictive Control, where the real system compensates for modeling errors, repeated error predictions could eventually lead to unstable system behavior. MORPHIT-S addresses this limitation by providing full-body collision awareness, preventing such unreachable overlapping configurations.\n\nWhile IDTO serves as one demonstration of these capabilities, MORPHIT’s flexible spherical representation can be integrated with a wide variety of planning and control algorithms, potentially unlocking novel manipulation strategies across diverse robotic frameworks through our adaptable geometric formulation.\n\n# VI. CONCLUSION & FUTURE WORK\n\nMORPHIT introduces a flexible approach to robot morphology approximation that bridges the gap between geometric accuracy and computational efficiency, enabling task-specific adaptation through a gradient-based optimization framework. Our results show that adapting morphology to task constraints improves planning, interaction, and simulation performance. By enabling robots to dynamically reconfigure their geometric representations, from conservative collision-avoidance models to precise contact-interaction approximations, MORPHIT transforms morphology from a static constraint into an adaptive tool for enhanced task performance. Looking forward, we aim to extend MORPHIT to support real-time morphological adaptation, integrate surface properties for contact-sensitive tasks, and couple representation learning with high-level reasoning. Beyond technical improvements, this work opens fundamental questions about how robots can reason about and strategically modify their physical representations in real-time, potentially enabling autonomous morphological reconfiguration based on environmental demands and task requirements. These directions move us closer to a paradigm where robots not only plan motions within their physical constraints but actively reshape their computational embodiment to unlock previously impossible manipulation strategies and expand their operational capabilities in complex, dynamic environments.",
    "summary": "```json\n{\n  \"core_summary\": \"### 🎯 核心概要\\n\\n> **问题定义 (Problem Definition)**\\n> *   当前机器人系统通常将其物理形态视为固定约束而非自适应资源，导致在处理不同计算和精度需求的任务时，使用相同的刚性几何表示，从而限制了机器人在碰撞检测精度、接触丰富的交互模拟和狭窄空间导航等方面的能力。\\n> *   该问题的重要性在于，高效的形态表示能够显著提升机器人在动态现实环境中的实时操作能力，特别是在需要高频接触规划和控制的复杂系统中。距离查询通常占运动规划管道总计算时间的 `71%`，成为显著的性能瓶颈。\\n\\n> **方法概述 (Method Overview)**\\n> *   MORPHIT是一种新颖的算法，通过球形基元自动近似机器人形态，平衡几何精度与计算效率，并通过梯度优化框架提供对物理保真度与计算成本权衡的显式控制。\\n\\n> **主要贡献与效果 (Contributions & Results)**\\n> *   **MORPHIT算法**：提出了一种自动化的梯度优化框架，能够生成适应任务需求的球形表示，显著提升了机器人形态的灵活性和适应性。\\n> *   **性能提升**：在多个指标上优于基线方法（VSSA和AMAA），使用更少的球形实现了更好的网格近似和更低的计算开销。具体而言，MORPHIT生成近似的时间比VSSA和AMAA快两个数量级。\\n> *   **应用效果**：实验表明，MORPHIT在碰撞检测精度、接触丰富的交互模拟和狭窄空间导航中显著提升了机器人性能。在碰撞检测任务中，MORPHIT-B在6个球形每链接时，误报率（FP）比基线方法低 `50%`。\",\n  \"algorithm_details\": \"### ⚙️ 算法/方案详解\\n\\n> **核心思想 (Core Idea)**\\n> *   MORPHIT通过梯度优化框架，直接优化球形参数（中心和半径），通过专门的损失函数平衡几何精度与计算效率。其设计哲学在于将机器人形态视为可自适应调整的资源，而非固定约束。\\n\\n> **创新点 (Innovations)**\\n> *   **与先前工作的对比**：现有方法依赖手动指定或计算效率低下的自动化方法，无法同时满足物理保真度和计算效率的需求。例如，CuRobo的球形表示是通过劳动密集型的手动打包创建的。\\n> *   **本文的改进**：MORPHIT通过梯度优化框架和自适应密度控制机制，实现了对球形表示的自动优化，提供了对物理保真度与计算成本权衡的显式控制。\\n\\n> **具体实现步骤 (Implementation Steps)**\\n> 1.  **初始化**：从网格体积内采样球形中心，并根据目标体积初始化球形半径。球形半径使用对数正态分布初始化，以保持目标体积。\\n> 2.  **优化**：通过最小化复合损失函数（包括覆盖、重叠、边界、表面、包含和SQEM损失）来优化球形参数。损失函数定义为：\\n>     $$\\n>     L_{\\\\mathrm{total}} = w_{c}L_{\\\\mathrm{cover}} + w_{o}L_{\\\\mathrm{overlap}} + w_{b}L_{\\\\mathrm{bound}} + w_{s}L_{\\\\mathrm{surf}} + w_{t}L_{\\\\mathrm{contain}} + w_{q}L_{\\\\mathrm{SQEM}}\\n>     $$\\n> 3.  **自适应密度控制**：在优化过程中，移除无效球形（半径小于阈值或中心不在网格内）并在覆盖不足的区域添加新球形。\\n> 4.  **输出**：将优化后的球形集合转换为URDF文件，用于机器人仿真和控制。\\n\\n> **案例解析 (Case Study)**\\n> *   论文未明确提供此部分信息。\",\n  \"comparative_analysis\": \"### 📊 对比实验分析\\n\\n> **基线模型 (Baselines)**\\n> *   Variational Sphere Set Approximation (VSSA)\\n> *   Adaptive Medial-Axis Approximation (AMAA)\\n\\n> **性能对比 (Performance Comparison)**\\n> *   **在计算时间上**：MORPHIT生成近似的时间比VSSA和AMAA快两个数量级，能够高效处理复杂网格。例如，在处理视觉网格时，MORPHIT的时间显著低于基线方法。\\n> *   **在边界保真度上**：MORPHIT-B在平均距离和最大距离指标上均优于基线方法，显著提升了表面近似质量。例如，在6个球形每链接时，MORPHIT-B的平均距离显著低于VSSA和AMAA。\\n> *   **在空间占用上**：MORPHIT-B的联合体积比（runion）最接近理想值1，表明其在体积和表面覆盖上达到了最佳平衡。例如，在6个球形每链接时，MORPHIT-B的runion为 `0.95`，而VSSA和AMAA分别为 `0.85` 和 `0.88`。\\n> *   **在碰撞检测精度上**：MORPHIT-B在6个球形每链接时，误报率（FP）比基线方法低 `50%`，同时在保持低漏报率（FN）方面表现优异。\",\n  \"keywords\": \"### 🔑 关键词\\n\\n*   机器人形态表示 (Robot Morphology Representation, N/A)\\n*   球形近似 (Spherical Approximation, N/A)\\n*   梯度优化 (Gradient-Based Optimization, N/A)\\n*   碰撞检测 (Collision Detection, CD)\\n*   接触规划 (Contact Planning, N/A)\\n*   自适应密度控制 (Adaptive Density Control, N/A)\\n*   计算效率 (Computational Efficiency, N/A)\"\n}\n```"
}